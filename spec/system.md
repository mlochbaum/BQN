*View this file with results and syntax highlighting [here](https://mlochbaum.github.io/BQN/spec/system.html).*

# Specification: BQN system-provided values

This portion of the spec is still potentially subject to major changes.

The `‚Ä¢` symbol is used to access values other than primitives provided by BQN.

All system values described in the BQN specification are optional: an implementation does not have to include any of them. However, if a system value with one of the names given below is included, then it must have the specified behavior. For namespaces this rule applies to individual fields as well: a namespace may be provided with only some of the fields, but a field with one of the given names must behave as specified.

## Execution and scope manipulation

| Name          | Summary
|---------------|--------------------------
| `‚Ä¢BQN`        | Evaluate the argument string in an isolated scope
| `‚Ä¢Eval`       | Evaluate the argument string in the current scope
| `‚Ä¢ScopedEval` | Evaluate the argument string in a child scope
| `‚Ä¢Using`      | Import all values from the argument namespace

The effect of `‚Ä¢Eval` should be the same as if its argument were written as source code in the scope where `‚Ä¢Eval` appears. It can define variables, and modify those in the current scope or a parent.

`‚Ä¢ScopedEval` creates as new scope for evaluation as it is loaded. Other than its syntactic role, it is effectively equivalent to `{‚Ä¢Eval}`. Parent scopes are visible from the created scope; to make a scope without this property use `‚Ä¢BQN"‚Ä¢Eval"` or `‚Ä¢BQN"‚Ä¢ScopedEval"`.

## Scripts

| Name       | Summary
|------------|---------------------
| `‚Ä¢Import`  | Load a script file
| `‚Ä¢args`    | Arguments passed to current file
| `‚Ä¢path`    | Current file's path
| `‚Ä¢name`    | Current filename

`‚Ä¢Import` loads another BQN script. The script is evaluated in its own isolated scope, and its result is either the result of the last line, or a module if it exports with `‚áê` at the top level. If it is a module, then it must be destructured immediately unless first-class namespaces are possible.

The right argument is a filename, which may be relative or absolute. Relative paths are taken relative to the source file where this instance of `‚Ä¢Import` was written. The left argument, if given, is the list of arguments that should be passed through to the file as `‚Ä¢args`. If no left argument is given then `‚ü®‚ü©` is used for `‚Ä¢args`. However, the behavior is different in this case. The same file will only be loaded once in a given BQN program by `‚Ä¢Import` calls with no left argument: the first such call saves the returned value, even if it is mutable, and subsequent calls return this saved value. To avoid this and reload the file, pass a left argument of `‚ü®‚ü©`.

`‚Ä¢args` is the arguments passed as the file was invoked, either from the command line or `‚Ä¢Import`. For command line calls it is a list of strings.

`‚Ä¢path` simply gives the path of the file in which it appears. It includes a trailing slash but not the name of the file itself.

`‚Ä¢name` gives the name, including the extension, of the file in which it appears. It doesn't include the path.

## Files

The system namespace value `‚Ä¢file` deals with file operations. For the purposes of `‚Ä¢file`, paths in the filesystem are always strings. As with `‚Ä¢Import`, file paths may be relative or absolute, and relative paths are relative to `‚Ä¢path`, except in `‚Ä¢file.At` which allows `ùï®` to specify an alternate base directory. The value `‚Ä¢path` used for a particular instance of `‚Ä¢file` is determined by the file that contains that instance.

When a `‚Ä¢file` function returns a file path or portion of a path, the path is always absolute and canonical, with `.` and `..` components removed.

Possible fields of `‚Ä¢file` are given in the subsections below.

### File paths

The following functions manipulate paths and don't access files. Each takes a relative or absolute path `ùï©`, and `At` may also take a base directory `ùï®`.

| Name        | Summary
|-------------|--------------------------
| `path`      | Path of this source file, that is, `‚Ä¢path`
| `At`        | Absolute path of file, with optional base `ùï®`
| `Name`      | File name including extension
| `Parent`    | Path of the containing directory, with trailing backslash
| `BaseName`  | File name, with dot and extension removed
| `Extension` | File extension, including leading dot
| `Parts`     | List of parent, base name, and extension

### File metadata

Metadata functions may query information about a file or directory but do not read to or write from it. Each takes a path `ùï©`, and some functions also allow new data in `ùï®`. The returned data in any case is the specified property.

| Name          | Summary
|---------------|--------------------------
| `Exists`      | `1` if the file exists and `0` otherwise
| `Type`        | A character indicating the file's type
| `Created`     | Time created
| `Accessed`    | Time of last access
| `Modified`    | Time of last modification
| `Size`        | Total size in bytes
| `Permissions` | Query or set file permissions
| `Owner`       | Query or set owner user ID and group ID number

Times are Unix timestamps, that is, seconds since the Unix epoch, as used by [time](#time) system values. File permissions on Unix are a three-element list of numbers giving the permissions for the owner, group, and other users. The file type is one of the following characters for the POSIX file types, matching Unix `ls -l` with `'f'` instead of `'-'`.

- `'f'`: File
- `'d'`: Directory
- `'l'`: Symlink
- `'p'`: Pipe (FIFO)
- `'s'`: Socket
- `'b'`: Block device
- `'c'`: Character device

### File access

File access functions read or write files, either by manipulating files as a whole or interacting with the contents. Whole-file functions cannot overwrite target files: that is, `Rename` and `Copy` must give an error if a file exists at `ùï®`, and `CreateDir` if a file exists at `ùï©`, while `Chars`, `Lines`, and `Bytes` can overwrite the contents of an existing file `ùï®`. However, these three functions must give an error if `ùï®` exists and is a directory.

| Name        | Summary
|-------------|--------------------------
| `Open`      | Return an open file object based on `ùï©`
| `Rename`    | Rename file `ùï©` with path `ùï®`
| `Copy`      | Copy file `ùï©` to path `ùï®`
| `CreateDir` | Create a directory at path `ùï©`
| `Remove`    | Delete file `ùï©`
| `RemoveDir` | Recursively delete directory `ùï©` and all contents
| `List`      | Return names of all files in directory `ùï©`
| `Chars`     | Read from or write to entire file, as characters
| `Lines`     | Read from or write to entire file, as lines
| `Bytes`     | Read from or write to entire file, as bytes

`Rename`, `Copy`, and `CreateDir` return the path of the new file. `Remove` and `RemoveDir` return `1` to indicate successful removal (and error otherwise).

`List` returns filenames only, without extensions. It lists all files and directories including hidden ones, but not the current and parent directory names `.` and `..`.

Functions `Chars`, `Lines`, and `Bytes` are all ambivalent. If only `ùï©` is given, then it is a filename, and the result is the contents of the file in the appropriate format. If there are two arguments, then `ùï®` is the filename and `ùï©` is the desired contents. These are written to the file, overwriting its contents, and the absolute filename `ùï®` is returned. The three formats are:

- Chars: BQN characters, or UTF-32. The file is assumed to be UTF-8 encoded.
- Lines: BQN strings. The file is decoded as with chars, then split into lines by CR, LR, or CRLF line endings.
- Bytes: Single-byte values, stored as BQN characters from `@` to `@+255`.

The following short names can also be provided for file access. They can be provided, and use the definitions from above even if `‚Ä¢file` is not provided.

| Name       | Equivalent
|------------|---------------
| `‚Ä¢FChars`  | `‚Ä¢file.Chars`
| `‚Ä¢FLines`  | `‚Ä¢file.Lines`
| `‚Ä¢FBytes`  | `‚Ä¢file.Bytes`

### Open file object

## Input and output

| Name   | Summary
|--------|----------------------
| `‚Ä¢Out` | Print argument string
| `‚Ä¢Fmt` | Format value for printing

## Operation properties

| Name         | Summary
|--------------|--------------------------
| `‚Ä¢Type`      | Return a number indicating type
| `‚Ä¢Glyph`     | Return the glyph for a primitive
| `‚Ä¢Source`    | Return the source of a block, as a string
| `‚Ä¢Decompose` | Show the parts of a compound function

Each function in this section is monadic.

`‚Ä¢Type` gives its argument's type, as a number from the table below:

| Number | Type
|--------|-----
| 0      | Array
| 1      | Number
| 2      | Character
| 3      | Function
| 4      | 1-modifier
| 5      | 2-modifier
| 6      | Namespace

`‚Ä¢Glyph` gives the glyph corresponding to a primitive as a single character, for example returning `'+'` given an argument matching `+`. It causes an error if the argument is not a primitive.

`‚Ä¢Source` gives a string containing a block's source, including the enclosing braces `{}`. It causes an error if the argument is not a block. In contrast to `‚Ä¢Glyph`, this function does not give full information about `ùï©` because the result cannot convey environment or mutable identity.

`‚Ä¢Decompose` breaks down one level of a compound function or modifier, returning a list with a code giving what kind of structure it has (as listed in the table below) followed by each of its components. Non-operations do not cause an error, but return code -1, then the argument as a single component. The result is thus a list of length 2 to 4, and `‚Ä¢Decompose` cannot cause an error.

| Kind          | Code | Components
|---------------|------|-----------
| Non-operation | -1   | `ùï©`
| Primitive     |  0   | `ùï©`
| Block         |  1   | `ùï©`
| 2-train       |  2   | `  g,h`
| 3-train       |  3   | `f,g,h`
| 1-mod         |  4   | `ùïó,ùï£`
| 2-mod         |  5   | `ùïó,ùï£,ùïò`
| Left partial  |  6   | `ùïó,ùï£`
| Right partial |  7   | `  ùï£,ùïò`

## Time

| Name          | Summary
|---------------|--------------------------
| `‚Ä¢UnixTime`   | Time between Unix epoch and function call
| `‚Ä¢MonoTime`   | Monotonically-increasing time counter for relative measurement
| `‚Ä¢Delay`      | Wait at least `ùï©` seconds, and return the actual wait time
| `‚Ä¢_timed`     | Call `ùîΩ` on `ùï©` `ùï®‚ä£1` times, and return the average duration
| `‚Ä¢_maxTime_`  | Call `ùîΩ` on the arguments, but fail if it takes over `ùï®ùîæùï©` seconds

All times are measured in seconds.

The [Unix epoch](https://en.wikipedia.org/wiki/Unix_time) is 1970-01-01 00:00:00 UTC. `‚Ä¢UnixTime` is intended for absolute time measurement and should be implemented with the method that gives the most accurate result at any given time. `‚Ä¢MonoTime` is intended for relative measurement and should use the method that gives the most precise time differences over the course of the program. Its return value must never decrease between calls.

`‚Ä¢_timed` returns the total time taken divided by the number of function calls (`ùï®` if provided and 1 otherwise), including the overhead required for the outer loop that counts iterations (which will typically be negligible in comparison to the BQN code).

More accurately the modifier `‚Ä¢_maxTime_` *may* fail if execution of `ùîΩ` takes over `ùï®ùîæùï©` seconds, and should fail as quickly as it is practically able to. The most likely way to implement this modifier is to interrupt execution at the given time. If `ùîΩ` completes before the interrupt there is no need to measure the amount of time it actually took.
