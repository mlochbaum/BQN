*View this file with results and syntax highlighting [here](https://mlochbaum.github.io/BQN/spec/system.html).*

# Specification: BQN system-provided values

This portion of the spec is still potentially subject to major changes.

The `‚Ä¢` symbol is used to access values other than primitives provided by BQN.

All system values described in the BQN specification are optional: an implementation does not have to include any of them. However, if a system value with one of the names given below is included, then it must have the specified behavior. For namespaces this rule applies to individual fields as well: a namespace may be provided with only some of the fields, but a field with one of the given names must behave as specified.

## Execution

| Name          | Summary
|---------------|--------------------------
| `‚Ä¢BQN`        | Evaluate the argument string in an isolated scope
| `‚Ä¢ReBQN`      | Create a BQN-like evaluation function with options `ùï©`
| `‚Ä¢primitives` | List of primitives as glyph-value pairs

The left argument to `‚Ä¢BQN` or the result of `‚Ä¢ReBQN`, if given, is a list of up to three elements, giving a prefix of `‚Ä¢state` (see next section) during evaluations of that function. Thus `‚ü®"","xyz"‚ü©‚Ä¢BQN"‚Ä¢name"` returns `"xyz"`.

`‚Ä¢ReBQN` accepts a namespace `ùï©`. The following options are specified if supported:

| Option        | Values (default first)
|---------------|--------------------------
| `repl`        | `"none"`, `"strict"`, `"loose"`
| `primitives`  | List of glyph-value pairs; default `‚Ä¢primitives`
| `system`      | `"all"`, `"none"`, `"safe"` or list of names
| `scope`       | `"none"`, `"read"`, `"modify"` or list of name-setting pairs

The option `repl` indicates how variables are retained across calls: with "none" they are not saved; with "strict", they are saved and can't be redefined; and with "loose" they may be redefined. Each element in `primitives` gives the glyph and value for a primitive to be made available. The value must have an operation type and its type determines the primitive's role. `system` in general gives the list of system values to be made available, with shorthand values to indicate all currently-available ones, none of them, or only a subset that cannot be used to interact with anything outside of the execution context. `scope` indicates allowed interaction with the scope in which `‚Ä¢ReBQN` is *called* (not loaded): with "read" variables may be read and with "modify" they may be read or modified.

## Scripts

| Name       | Summary
|------------|---------------------
| `‚Ä¢Import`  | Load a script file
| `‚Ä¢state`   | `‚ü®‚Ä¢path, ‚Ä¢name, ‚Ä¢args‚ü©`
| `‚Ä¢args`    | Arguments passed to current file
| `‚Ä¢path`    | Current file's path
| `‚Ä¢name`    | Current filename
| `‚Ä¢wdpath`  | Shell's working directory path
| `‚Ä¢Exit`    | Leave the top-level running program

`‚Ä¢Import` loads another BQN script. The script is evaluated in its own isolated scope, and its result is either the result of the last line, or a module if it exports with `‚áê` at the top level. If it is a module, then it must be destructured immediately unless first-class namespaces are possible.

The right argument is a filename, which may be relative or absolute. Relative paths are taken relative to the source file where this instance of `‚Ä¢Import` was written. The left argument, if given, is the list of arguments that should be passed through to the file as `‚Ä¢args`. If no left argument is given then `‚ü®‚ü©` is used for `‚Ä¢args`. However, the behavior is different in this case. The same file will only be loaded once in a given BQN program by `‚Ä¢Import` calls with no left argument: the first such call saves the returned value, even if it is mutable, and subsequent calls return this saved value. To avoid this and reload the file, pass a left argument of `‚ü®‚ü©`.

`‚Ä¢args` is the arguments passed as the file was invoked, either from the command line or `‚Ä¢Import`. For command line calls it is a list of strings.

`‚Ä¢path` simply gives the path of the file in which it appears. It includes a trailing slash but not the name of the file itself.

`‚Ä¢name` gives the name, including the extension, of the file in which it appears. It doesn't include the path.

`‚Ä¢wdpath` returns the path of the current working directory, like the Unix `pwd` command, but including a trailing slash.

`‚Ä¢Exit` immediately terminates the running BQN process. If the argument is a valid return code (on Unix, an integer), it is returned; otherwise, the default return code (the one returned when the end of the program is reached) is used.

## Files

The system namespace value `‚Ä¢file` deals with file operations. For the purposes of `‚Ä¢file`, paths in the filesystem are always strings. As with `‚Ä¢Import`, file paths may be relative or absolute, and relative paths are relative to `‚Ä¢path`, except in `‚Ä¢file.At` which allows `ùï®` to specify an alternate base directory. The value `‚Ä¢path` used for a particular instance of `‚Ä¢file` is determined by the file that contains that instance.

When a `‚Ä¢file` function returns a file path or portion of a path, the path is always absolute and canonical, with `.` and `..` components removed.

Possible fields of `‚Ä¢file` are given in the subsections below.

### File paths

The following functions manipulate paths and don't access files. Each takes a relative or absolute path `ùï©`, and `At` may also take a base directory `ùï®`.

| Name        | Summary
|-------------|--------------------------
| `path`      | Path of this source file, that is, `‚Ä¢path`
| `At`        | Absolute path of file, with optional base `ùï®`
| `Name`      | File name including extension
| `Parent`    | Path of the containing directory, with trailing backslash
| `BaseName`  | File name, with dot and extension removed
| `Extension` | File extension, including leading dot
| `Parts`     | List of parent, base name, and extension

### File metadata

Metadata functions may query information about a file or directory but do not read to or write from it. Each takes a path `ùï©`, and some functions also allow new data in `ùï®`. The returned data in any case is the specified property.

| Name          | Summary
|---------------|--------------------------
| `Exists`      | `1` if the file exists and `0` otherwise
| `Type`        | A character indicating the file's type
| `Created`     | Time created
| `Accessed`    | Time of last access
| `Modified`    | Time of last modification
| `Size`        | Total size in bytes
| `Permissions` | Query or set file permissions
| `Owner`       | Query or set owner user ID and group ID number

Times are Unix timestamps, that is, non-leap seconds since the Unix epoch, as used by [time](#time) system values. File permissions on Unix are a three-element list of numbers giving the permissions for the owner, group, and other users. The file type is one of the following characters for the POSIX file types, matching Unix `ls -l` with `'f'` instead of `'-'`.

- `'f'`: File
- `'d'`: Directory
- `'l'`: Symlink
- `'p'`: Pipe (FIFO)
- `'s'`: Socket
- `'b'`: Block device
- `'c'`: Character device

### File access

File access functions read or write files, either by manipulating files as a whole or interacting with the contents. Whole-file functions cannot overwrite target files: that is, `Rename` and `Copy` must give an error if a file exists at `ùï®`, and `CreateDir` if a file exists at `ùï©`, while `Chars`, `Lines`, and `Bytes` can overwrite the contents of an existing file `ùï®`. However, these three functions must give an error if `ùï®` exists and is a directory.

| Name        | Summary
|-------------|--------------------------
| `Open`      | Return an open file object based on `ùï©`
| `Rename`    | Rename file `ùï©` with path `ùï®`
| `Copy`      | Copy file `ùï©` to path `ùï®`
| `CreateDir` | Create a directory at path `ùï©`
| `Remove`    | Delete file `ùï©`
| `RemoveDir` | Recursively delete directory `ùï©` and all contents
| `List`      | Return names of all files in directory `ùï©`
| `Chars`     | Read from or write to entire file, as characters
| `Lines`     | Read from or write to entire file, as lines
| `Bytes`     | Read from or write to entire file, as bytes

`Rename`, `Copy`, and `CreateDir` return the path of the new file. `Remove` and `RemoveDir` return `1` to indicate successful removal (and error otherwise).

`List` returns filenames only, without full paths. It lists all files and directories including hidden ones, but not the current and parent directory names `.` and `..`.

Functions `Chars`, `Lines`, and `Bytes` are all ambivalent. If only `ùï©` is given, then it is a filename, and the result is the contents of the file in the appropriate format. If there are two arguments, then `ùï®` is the filename and `ùï©` is the desired contents. These are written to the file, overwriting its contents, and the absolute filename `ùï®` is returned. The three formats are:

- Chars: BQN characters, or UTF-32. The file is assumed to be UTF-8 encoded.
- Lines: BQN strings. The file is decoded as with chars, then split into lines by CR, LR, or CRLF line endings.
- Bytes: Single-byte values, stored as BQN characters from `@` to `@+255`.

The following short names can also be provided for file access. They can be provided, and use the definitions from above even if `‚Ä¢file` is not provided.

| Name       | Equivalent
|------------|---------------
| `‚Ä¢FChars`  | `‚Ä¢file.Chars`
| `‚Ä¢FLines`  | `‚Ä¢file.Lines`
| `‚Ä¢FBytes`  | `‚Ä¢file.Bytes`

### Open file object

## Input and output

| Name    | Summary
|---------|----------------------
| `‚Ä¢Out`  | Print argument string
| `‚Ä¢Show` | Print argument value
| `‚Ä¢Repr` | String representation of `ùï©`, if possible
| `‚Ä¢Fmt`  | Format value for printing

`‚Ä¢Out` prints a string to stdout, with a trailing newline. `‚Ä¢Show` displays a BQN value to the programmer (the representation is not specified, and does not need to be plain text). `‚Ä¢Fmt` returns a string (not a character table: lines are separated by linefeeds) indicating how `ùï©` would be printed by the interactive environment. Both `‚Ä¢Show` and `‚Ä¢Fmt` may take a left argument configuring how the value should be formatted.

`‚Ä¢Repr` attempts to return a string so that `‚Ä¢BQN ‚Ä¢Repr ùï©` matches `ùï©`. If `ùï©` contains any mutable values (operations or namespaces), this is not possible. However, if such a values is stateless, in the sense that they don't access variables outside of their own scopes, it is permissible for `‚Ä¢Repr` to return source code that would create a value with identical behavior.

## Interface

| Name    | Summary
|---------|----------------------
| `‚Ä¢SH`   | Execute shell command and return `exitcode‚Äøstdout‚Äøstderr`

The argument to `‚Ä¢SH` is a list of strings giving the command and its arguments (for example `"mv"‚Äø"old"‚Äø"new"`). The command is executed synchronously, and the result is a list of three elements: the command's exit code, text written to stdout, and text written to stderr. In both cases the text is a plain string containing all text emitted by the program. Text is interpreted as UTF-8, with an error if it's not valid UTF-8.

## Operation properties

| Name         | Summary
|--------------|--------------------------
| `‚Ä¢Type`      | Return a number indicating type
| `‚Ä¢Glyph`     | Return the glyph for a primitive
| `‚Ä¢Source`    | Return the source of a block, as a string
| `‚Ä¢Decompose` | Show the parts of a compound function

Each function in this section is monadic.

`‚Ä¢Type` gives its argument's type, as a number from the table below:

| Number | Type
|--------|-----
| 0      | Array
| 1      | Number
| 2      | Character
| 3      | Function
| 4      | 1-modifier
| 5      | 2-modifier
| 6      | Namespace

`‚Ä¢Glyph` gives the glyph corresponding to a primitive as a single character, for example returning `'+'` given an argument matching `+`. It causes an error if the argument is not a primitive.

`‚Ä¢Source` gives a string containing a block's source, including the enclosing braces `{}`. It causes an error if the argument is not a block. In contrast to `‚Ä¢Glyph`, this function does not give full information about `ùï©` because the result cannot convey environment or mutable identity.

`‚Ä¢Decompose` breaks down one level of a compound function, returning a list with a code giving what kind of structure it has followed by each of its components. Possible codes are listed in the table below according to the rule that forms the derived function‚Äîtrain or 2-modifier application. Non-function values, and some functions, can't be broken down. They are still classified with a code: -1 for a non-operation, 0 for a primitive, and 1 for other operations. "Other" includes blocks and system operations. The result is thus a list of length 2 to 4, and `‚Ä¢Decompose` cannot cause an error.

| Kind          | Code | Components
|---------------|------|-----------
| Non-operation | -1   | `ùï©`
| Primitive     |  0   | `ùï©`
| Other         |  1   | `ùï©`
| 2-train       |  2   | `  g,h`
| 3-train       |  3   | `f,g,h`
| 1-mod         |  4   | `ùïó,ùï£`
| 2-mod         |  5   | `ùïó,ùï£,ùïò`

## Time

| Name          | Summary
|---------------|--------------------------
| `‚Ä¢UnixTime`   | Time between Unix epoch and function call
| `‚Ä¢MonoTime`   | Monotonically-increasing time counter for relative measurement
| `‚Ä¢Delay`      | Wait at least `ùï©` seconds, and return the actual wait time
| `‚Ä¢_timed`     | Call `ùîΩ` on `ùï©` `ùï®‚ä£1` times, and return the average duration
| `‚Ä¢_maxTime_`  | Call `ùîΩ` on the arguments, but fail if it takes over `ùï®ùîæùï©` seconds

All times are measured in seconds.

The [Unix epoch](https://en.wikipedia.org/wiki/Unix_time) is 1970-01-01 00:00:00 UTC, and [Unix time](https://en.wikipedia.org/wiki/Unix_time) is the number of seconds since this epoch, with adjustments for leap seconds. `‚Ä¢UnixTime` is intended for absolute time measurement and should use the source most accurate reflects Unix time when it's called. `‚Ä¢MonoTime` is intended for relative measurement and should use the method that gives the most precise time differences over the course of the program. Its return value must never decrease between calls.

`‚Ä¢_timed` returns the total time taken divided by the number of function calls (`ùï®` if provided and 1 otherwise), including the overhead required for the outer loop that counts iterations (which will typically be negligible in comparison to the BQN code).

More accurately the modifier `‚Ä¢_maxTime_` *may* fail if execution of `ùîΩ` takes over `ùï®ùîæùï©` seconds, and should fail as quickly as it is practically able to. The most likely way to implement this modifier is to interrupt execution at the given time. If `ùîΩ` completes before the interrupt there is no need to measure the amount of time it actually took.

## Random generation

`‚Ä¢MakeRand` initializes a deterministic pseudorandom number generator with seed value `ùï©`. `‚Ä¢rand`, if it exists, is a globally accessible generator initialized at first use; this initialization should use randomness from an outside source if available. These random generators aren't required to be cryptographically secure and should always be treated as insecure. A random generator has the following member functions:

| Name      | Summary
|-----------|------------------------------
| `Range`   | A number, or array of shape `ùï®`, selected from `‚Üïùï©`
| `Deal`    | A simple random sample of `ùï®‚ä£ùï©` elements of `‚Üïùï©`
| `Subset`  | A sorted SRS of `‚Üïùï©`, with `ùï®` elements if given

For each of these functions, `ùï©` is a natural number. For `Range`, `ùï®` must be a valid shape (natural number, or list or unit array of natural numbers) if given, and for `Deal` and `Subset` it's a natural number less than or equal to `ùï©`. All selections are made uniformly at random, that is, each possible result is equally likely. A simple random sample (SRS) of `k` elements from list `s` is a list of `k` distinct elements of `s` in any order. Both the choice of elements and their ordering must be uniformly random. [Recommended algorithms](../implementation/primitive/random.md#simple-random-sample) for SRS selection are variants of a partial Knuth shuffle.

When `ùï®` isn't given, `Deal`'s result contains all elements of `‚Üïùï©`, making it a random shuffle of those values, or random permutation. In `Subset`, a random choice is made uniformly from the `2‚ãÜùï©` subsets of `‚Üïùï©`, so that a subset of any length may be returned.

In `Range`, `ùï©` may be `0`. In this case the result consists of floating-point numbers in the unit interval from 0 to 1. The numbers should have an overall uniform distribution, but their precision and whether the endpoints 0 and 1 are possible may depend on the implementation.

Ranges up to `2‚ãÜ32` must be supported (that is, a maximum integer result of `(2‚ãÜ32)-1`) if the number system accommodates it. In implementations based on double-precision floats it's preferable but not required to support ranges up to `2‚ãÜ53`.
