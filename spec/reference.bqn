# This file gives reference implementations of BQN primitives assuming
# limited initial functionality. Implementations are designed to be
# simple and not fast.

# In some cases an operation is defined with limited functionality at
# first and later expanded. For convenience, rather than renaming these
# limited versions, every primitive use refers to the most recent
# definition in source code, as if redefinitions shadowed previous
# primitive definitions.


#âŒœ
# LAYER 0: Assumed functionality

# Arithmetic on the implementation-defined number system
# LIMITED to the stated cases and atomic arguments.
+          #                Add
-          # Negate         Subtract
Ã—          #                Multiply
Ã·          # Reciprocal     Divide
â‹†          # Exponential    Power
âŒŠ          # Floor
=          #                Equals
â‰¤          #                Less Than or Equal to

# Other basic functionality that we need to assume
Type       # 0 if ğ•© is an array, 1 if a number, >1 otherwise
!          # ğ•© is 0 or 1; throw an error if it's 0
â‰¢          # LIMITED to monadic case
â¥Š          # LIMITED to array ğ•© and (Ã—Â´ğ•¨)â‰¡â‰¢ğ•©
âŠ‘          # LIMITED to natural number ğ•¨ and list ğ•©
_amend     # {ğ•¨Ë™âŒ¾(ğ•—âŠ¸âŠ‘)ğ•©} for list ğ•©
â†•          # LIMITED to number ğ•©
Identity   # Left or right identity of function ğ•
â¼          # Inverse of function ğ”½
Fill       # Enclosed fill value for ğ•©
HasFill    # Whether ğ•© has a fill value


#âŒœ
# LAYER 1: Foundational operators and functions

# Combinators
â—¶ â† {ğ•¨((ğ•¨ğ”½ğ•©)âŠ‘ğ•˜){ğ”½}ğ•©}   # LIMITED to number left operand result
Ë™ â† {ğ•©â‹„ğ•—}
âŠ˜ â† {ğ”½ğ•©;ğ•¨ğ”¾ğ•©}
âŠ¢ â† {ğ•©}
âŠ£ â† {ğ•©;ğ•¨}
Ëœ â† {ğ•©ğ”½ğ•¨âŠ£ğ•©}
âˆ˜ â† {ğ”½ğ•¨ğ”¾ğ•©}
â—‹ â† {(ğ”¾ğ•¨)ğ”½ğ”¾ğ•©}
âŠ¸ â† {(ğ”½ğ•¨âŠ£ğ•©)ğ”¾ğ•©}
âŸœ â† {(ğ•¨âŠ£ğ•©)ğ”½ğ”¾ğ•©}
âŸ â† {ğ”¾â—¶âŠ¢â€¿ğ”½}            # LIMITED to boolean right operand result

IsArray â† 0=Type
Int â† (1=Type)â—¶âŸ¨0,âŒŠâŠ¸=âŸ©      # Is an integer (including Â¯âˆ and âˆ)
Nat â† (1=Type)â—¶âŸ¨0,0âŠ¸â‰¤Ã—âŒŠâŠ¸=âŸ©  # Is a natural number

â‰¢ â†© IsArrayâ—¶âŸ¨âŸ©â€¿â‰¢  # LIMITED to monadic case
â‹ˆ â† {âŸ¨ğ•©âŸ©;âŸ¨ğ•¨,ğ•©âŸ©}

# LIMITED to numeric arguments for arithmetic cases
âˆš â† â‹†âŸœ(Ã·2)   âŠ˜ (â‹†âŸœÃ·Ëœ)      # Higher precision allowed; see spec
âˆ§ â†            Ã—
âˆ¨ â†            +-Ã—
Â¬ â† 1+-
| â† Ã—âŸœÃ—      âŠ˜ {ğ•©-ğ•¨Ã—âŒŠğ•©Ã·ğ•¨}  # Higher precision allowed; see spec
< â† {âŸ¨âŸ©â¥ŠâŸ¨ğ•©âŸ©} âŠ˜ (Â¬â‰¤Ëœ)
> â†            (Â¬â‰¤)
â‰¥ â† !âˆ˜0      âŠ˜ (â‰¤Ëœ)
â‰  â† Length   âŠ˜ (Â¬=)
= â†© Rank     âŠ˜ =
Ã— â†© 0âŠ¸(<->)  âŠ˜ Ã—
# âŒŠâŒˆ defined after pervasion below

Â¨ â† _eachm   # LIMITED to monadic case and array ğ•©
Â´ â† _fold

Rank â† 0âŠ‘â‰¢âˆ˜â‰¢
Length â† (0<Rank)â—¶âŸ¨1,0âŠ‘â‰¢âŸ©

_eachmâ†{
  # Set ğ•¨âŠ‘â¥Šğ•© to ğ”½ğ•¨âŠ‘â¥Šğ•© for each index ğ•¨
  (â‰¢ğ•©) â¥Š 0 ğ”½{ğ•¨ (+âŸœ1 ğ•Š ğ”½âˆ˜âŠ‘ ğ•¨_amend âŠ¢)âŸ(<âŸœâ‰ ) ğ•©} â¥Šğ•©
}
_foldâ†{
  ! 1==ğ•©
  lâ†â‰ vâ†ğ•© â‹„ Fâ†ğ”½
  # If ğ•¨ isn't given, start with the last cell of ğ•©
  râ†ğ•¨ (0<l)â—¶{ğ•©â‹„Identity f}â€¿{l-â†©1â‹„lâŠ‘ğ•©}âŠ˜âŠ£ ğ•©
  # Apply râ†©(ğ•¨âŠ‘v)F r for ğ•¨ from l to 0
  l {ğ•¨ -âŸœ1âŠ¸(âŠ£ğ•ŠâŠ‘âŸœvâŠ¸F)âŸ(>âŸœ0) ğ•©} r
}

# Re-add identities for needed redefined functions
identity { fâ€¿iâ†ğ•¨ â‹„ fË™âŠ¸=â—¶ğ•©â€¿i }Â´â†© âŸ¨ Ã—â€¿1, âˆ¨â€¿0, âˆ§â€¿1 âŸ©


#âŒœ
# LAYER 2: Pervasion
# _pervasive should be applied to all arithmetic as an IMPLICIT STEP:
# +-Ã—Ã·â‹†âˆšâŒŠâŒˆ|Â¬ and dyadic âˆ§âˆ¨<>â‰ =â‰¤â‰¥

# Join: elements 0â€¦â‰ ğ•¨ come from ğ•¨ and the rest from ğ•©
âˆ¾ â† {kâ†â‰ ğ•¨â‹„kâŠ¸â‰¤â—¶âŸ¨âŠ‘âŸœğ•¨,-âŸœkâŠ‘ğ•©ËœâŸ©Â¨â†•k+â‰ ğ•©}  # LIMITED to two list arguments

ToArray â† IsArrayâ—¶<â€¿âŠ¢

_tableâ†{
  mâ†â‰ aâ†â¥Šğ•¨ â‹„ nâ†â‰ bâ†â¥Šğ•© â‹„ Fâ†ğ”½ â‹„ iâ†0
  # ğ•© is the result index; maintain index i in ğ•¨ and compute ğ•©-nÃ—i in ğ•©
  (ğ•¨âˆ¾â—‹â‰¢ğ•©)â¥Š{i+â†©ğ•©=nÃ—i+1â‹„(iâŠ‘a)F(ğ•©-nÃ—i)âŠ‘b}Â¨â†•mÃ—n
}

_eachdâ†{
  _eâ†{ # ğ•¨ has rank less than or equal to ğ•©
    kâ†â‰ pâ†â‰¢ğ•¨ â‹„ qâ†â‰¢ğ•©
    ! âˆ§Â´(âŠ‘âŸœp=âŠ‘âŸœq)Â¨â†•k    # pâ‰¡kâ†‘q
    lâ†Ã—Â´(qâŠ‘ËœkâŠ¸+)Â¨â†•qâ‰ âŠ¸-k # Ã—Â´kâ†“q, size of a cell in ğ•© (pairs with a unit)
    aâ†â¥Šğ•¨ â‹„ bâ†â¥Šğ•©
    # In the inner function, ğ•¨ indexes into a and (lÃ—ğ•¨)+ğ•© into b
    qâ¥Š (â‰ a) (âŠ‘âŸœa ğ”½ lâŠ¸Ã—âŠ¸+âŠ‘bË™)_tableâ—‹â†• l
  }
  >â—‹=â—¶âŸ¨ğ”½_e,ğ”½Ëœ_eËœâŸ©
}

âŒœ â† {(ğ”½_eachm)âŠ˜(ğ”½_table)â—‹ToArray}
Â¨ â†© {(ğ”½_eachm)âŠ˜(ğ”½_eachd)â—‹ToArray}

# Pervasion recurses whenever any argument is an array
_pervasiveâ†{
  âŠ¢âŠ˜âˆ¨â—‹IsArrayâ—¶âŸ¨ğ”½, ğ”½{ğ•¨ğ”½_pervasiveğ•©}Â¨âŸ©
}

# The modifier _pervasive applies to all arithmetic.
# For practicality when testing, basic functions are made pervasive
# instead, which works for all arithmetic except dyadic âŒŠâŒˆ.
âŒŠ â†© âŒŠ        âŠ˜ ({(ğ•¨>ğ•©)âŠ‘ğ•¨â€¿ğ•©}_pervasive)
âŒˆ â† -âˆ˜âŒŠâˆ˜-    âŠ˜ ({(ğ•¨<ğ•©)âŠ‘ğ•¨â€¿ğ•©}_pervasive)


#âŒœ
# LAYER 3: Remove other limits
# After this all implementations are full except âˆ¾; â†• is monadic only

Deshape â† IsArrayâ—¶{âŸ¨ğ•©âŸ©}â€¿â¥Š
Reshapeâ†{
  ! 1â‰¥=ğ•¨
  sâ†Deshape ğ•¨
  spâ†+Â´pâ†Â¬NatâŒœs        # Number of non-numeric elements
  ! 1â‰¥sp               # At most one allowed
  nâ†â‰ dâ†Deshape ğ•©
  lâ†spâ—¶(Ã—Â´)â€¿{
    # Handle computed shapes
    lpâ†Ã—Â´p 1âŸâŠ£Â¨ğ•©       # Product of numeric elements
    ! 0<lp             # Would imply division by zero
    Iâ†+Â´â†•âˆ˜â‰ âŠ¸Ã—          # Index from boolean list with a single 1 (âŠ‘/)
    eâ†âŸ¨âˆ˜,âŒŠ,âŒ½,â†‘âŸ©=p IâŠ¸âŠ‘s # Pick element and compare with possibilities
    ! +Â´e              # Must be one of âˆ˜âŒŠâŒ½â†‘
    tâ†I e              # Which one is it?
    aâ†(2âŒŠt)â—¶âŸ¨{!Natğ•©â‹„ğ•©},âŒŠ,âŒˆâŸ©nÃ·lp  # Compute and round length
    sâ†©p aâŸâŠ£Â¨s          # Insert it back into the shape
    # For element â†‘, append fill elements to d if necessary
    {dâˆ¾â†©(Fill d)âŒœâ†•ğ•©-nâ‹„nâ†©ğ•©}âŸ(nâŠ¸<)âŸ(3=t)lpÃ—a
  } s
  # Size of ğ•© is n, so n|ğ•¨ is a cyclic index into d. Final size is l.
  s â¥Š (â†•l) {!0<nâ‹„âŠ‘âŸœğ•©Â¨n|ğ•¨}âŸ(lâ‰ n) d
}

Rangeâ†{
  I â† {!Natğ•© â‹„ â†•ğ•©}             # ğ•© is a number
  M â† {!1==ğ•© â‹„ (<âŸ¨âŸ©)â‹ˆâŠ¸âˆ¾âŒœÂ´IÂ¨ğ•©}  # ğ•© is a list
  IsArrayâ—¶Iâ€¿M ğ•©
}

Pick1â†{
  ! 1==ğ•¨           # Index must be a list
  ! ğ•¨=â—‹â‰ sâ†â‰¢ğ•©       # with length equal to rank of ğ•©
  ! âˆ§Â´IntÂ¨ğ•¨        # consisting of integers
  ! âˆ§Â´ğ•¨(â‰¥âŸœ-âˆ§<)s    # in the range [-l,l) where l is an axis length
  ğ•¨ +â†© sÃ—ğ•¨<0       # Wrap negatives
  i â† 0(âŠ‘âŸœğ•¨+âŠ‘âŸœsÃ—âŠ¢)Â´-â†•âŠ¸Â¬â‰ ğ•¨  # Compute index with a reverse fold
  i âŠ‘ â¥Šğ•©
}
# Recurse if depth is greater than 1
Pickd â† {âˆ¨Â´â¥ŠIsArrayÂ¨ğ•¨}â—¶Pick1â€¿{PickdâŸœğ•©Â¨ğ•¨}
Pick â† IsArrayâ—¶â¥Šâ€¿âŠ¢âŠ¸Pickd
First â† {!0<â‰ ğ•© â‹„ 0âŠ‘ğ•©} Deshape

# Two arrays match if all the following conditions hold:
matchâ†{Â¬âˆ˜(0âŠ‘ğ•¨)â—¶(1âŠ‘ğ•¨)â€¿ğ•©}Â´âŸ¨
  âŸ¨â‰ â—‹IsArray , 0âŸ©  # They are both arrays, or both not arrays
  âŸ¨Â¬IsArrayâˆ˜âŠ¢, =âŸ©  # They are equal atoms, OR
  âŸ¨â‰ â—‹=       , 0âŸ©  # They have equal ranks
  âŸ¨âˆ¨Â´â‰ â—‹â‰¢     , 0âŸ©  # And equal length along each axis
  {âˆ§Â´â¥Šğ•¨MatchÂ¨ğ•©}    # And matching elements
âŸ©

Depth â† IsArrayâ—¶0â€¿{1+0âŒˆÂ´DepthÂ¨â¥Šğ•©}

âŠ‘ â†© First          âŠ˜ Pick
â¥Š â†© Deshape        âŠ˜ Reshape
â†• â†© Range
â—¶ â†© {ğ•¨((ğ•¨ğ”½ğ•©)âŠ‘ğ•˜){ğ”½}ğ•©}  # Same definition with updated Pick

â‰¡ â† Depth          âŠ˜ Match
â‰¢ â†© â‰¢              âŠ˜ (Â¬Match)


#âŒœ
# LAYER 4: Operators

> â†© MergeâŸIsArray  âŠ˜ >
â‰ â† >âˆ˜â‹ˆ
â‰ â† _rankOp_
âš‡ â† _depthOp_
âŸ â†© _repeat_
Ë˜ â† {ğ”½â‰Â¯1}
Ë â† _insert
` â† _scan

Drop1 â† {âŠ‘âŸœğ•©Â¨ğ•¨+â†•ğ•¨-Ëœâ‰ ğ•©}  # Drop from list
Cell  â† Drop1âŸœâ‰¢         # (-ğ•¨)-cell shape of array ğ•©

# Merge: if empty, append fill shape to array shape to reshape fill
# Otherwise, run all element ravels together
Mergeâ†(0<â‰ âˆ˜â¥Š)â—¶((âˆ¾â—‹â‰¢â¥ŠâŠ¢)âŸœFillâŸHasFill)â€¿{
  câ†â‰¢âŠ‘ğ•©
  ! âˆ§Â´â¥Š(câ‰¡â‰¢)Â¨ğ•©    # Shapes must match
  ğ•©âŠ‘âŸœToArrayËœâŒœâ†•c  # Shape is (â‰¢ğ•©)âˆ¾c, with corresponding axis structure
}

# Check if ranks/depths are valid: list of one to three integers
# Return â¥Šğ•©
ValidateRanksâ†{
  ! 1â‰¥=ğ•©
  ğ•©â¥Šâ†©
  ! (1âŠ¸â‰¤âˆ§â‰¤âŸœ3)â‰ ğ•©
  ! âˆ§Â´IntÂ¨ğ•©
  ğ•©
}
# Extract the appropriate ranks/depths for a call
# Use negative indexing and wrap with |
_ranks â† {âŸ¨2âŸ©âŠ˜âŸ¨1,0âŸ© ((âŠ£-1+|)ËœâŸœâ‰ âŠ‘Â¨<âˆ˜âŠ¢) ValidateRanksâˆ˜ğ”½}
_depthOp_â†{
  n â† ğ•¨ ğ”¾_ranks ğ•©
  negâ†0>n â‹„ Fâ†ğ”½
  _dâ†{
    Râ†(ğ•—+neg)_d                    # Increment
    rec â† 2â¥Š(negâˆ§ğ•—â‰¥0)âˆ¨(0âŒˆğ•—)â‰¥ğ•¨â‹ˆâ—‹â‰¡ğ•©  # Whether to recurse into ğ•¨âŠ£ğ•© and ğ•©
    ğ•¨ recâ—¶(âŸ¨RÂ¨,RâŸœ(ğ•©Ë™)Â¨âˆ˜âŠ£âŸ©â‰âŸ¨(ğ•¨{ğ•;ğ•¨Ë™âŠ¸ğ•}r)Â¨âˆ˜âŠ¢,FâŸ©) ğ•©
  }
  ğ•¨ n _d ğ•©
}
_rankOp_â†{
  kâ†ğ•¨(â‹ˆâ—‹= 0âŠ¸â‰¤â—¶âŸ¨âŒŠâŸœ-,0âŒˆ-âŸ©Â¨ ğ”¾_ranks)ğ•© # Effective frame length
  # Enclose (-ğ•¨)-cells of ğ•©, that is, <â‰((=ğ•©)-ğ•¨) ğ•©
  EncKâ†{
    fâ†âŠ‘âŸœ(â‰¢ğ•©)Â¨â†•ğ•¨  # ğ•¨â†‘â‰¢ğ•©
    câ†Ã—Â´sâ†ğ•¨Cellğ•©
    fâ¥ŠâŠ‘âŸœ(â¥Šğ•©)Â¨âˆ˜((sâ¥Šâ†•c)+cÃ—âŠ¢)Â¨â†•Ã—Â´f
  }
  # Use <âŠ¢ if k=0 (required to handle atoms correctly), and <âŒœâŠ¢ if k==ğ•©
  Encâ†(>âŸœ0Ã—1+â‰¥âŸœ=)â—¶âŸ¨<âŠ¢,EncK,<âŒœâŠ¢âŸ©
  > ((âŠ‘k)Encğ•¨) ğ”½Â¨ ((1-Ëœâ‰ )âŠ¸âŠ‘k)Encğ•©
}

_insertâ†{
  ! 1â‰¤=ğ•©
  ğ•¨ ğ”½Â´ <Ë˜ğ•©
}
_scanâ†{
  ! IsArray ğ•©
  ! 1â‰¤=ğ•©
  câ†Ã—Â´csâ†1 Cell ğ•©
  ! (csâ‰¡â‰¢)ğ•¨
  lâ†â‰ râ†â¥Šğ•© â‹„ Fâ†ğ”½
  ğ•¨ (0<l)â—¶âŠ¢â€¿{
    # Initial cell: csâ¥Šğ•¨FÂ¨câ†‘ğ•© if ğ•¨ is given
    {râ†©â‰¥âŸœcâ—¶âŸ¨âŠ‘âŸœ(â¥Šğ•©)âŠ¸F,âŠ¢âŸ©âŸœ(âŠ‘âŸœr)Â¨â†•l}ğ•¨
    # For non-initial elements, apply F to index i-c and i
    # Must be ordered to compute value i-c first
    (â‰¢ğ•©) â¥Š r {((ğ•¨-c)Fâ—‹(âŠ‘âŸœğ•©)ğ•¨)ğ•¨_amendğ•©}Â´ (l-1)-â†•l-c
  } ğ•©
}
_repeat_â†{
  nâ†ğ•¨ğ”¾ğ•©                       # Repetition numbers
  lâ†uâ†0                       # Min and max repetitions
  {!Intğ•©â‹„!âˆ>|ğ•©â‹„lâŒŠâ†©ğ•©â‹„uâŒˆâ†©ğ•©}âš‡0 n
  bâ†ğ•¨{âŠ¢;ğ•¨{ğ•—Ë™âŠ¸ğ•}}0             # Bind ğ•¨ to ğ• if necessary
  iâ†âŸ¨ğ•©âŸ©â‹„Pâ†{ğ•âŠ£}âˆ˜BâŠ¸{ğ•`iâˆ¾â†•ğ•©}     # P makes a list of repetition 0, 1, â€¦
  posâ†ğ•— P u                   # Positive repetitions
  negâ†ğ•— 0âŠ¸<â—¶âŸ¨i,{ğ•â¼}âŠ¸PâŸ© -l     # Negative repetitions
  (|âŠ‘<âŸœ0âŠ‘posâ€¿negË™)âš‡0 n
}


#âŒœ
# LAYER 5: Structural functions

âŠ â† 0âŠ¸Select       âŠ˜ Select
â†‘ â† Prefixes       âŠ˜ Take
â†“ â† Suffixes       âŠ˜ Drop
â†• â†© â†•              âŠ˜ Windows
Â» â† Nudge          âŠ˜ ShiftBefore
Â« â† NudgeBack      âŠ˜ ShiftAfter
âŒ½ â† Reverse        âŠ˜ Rotate
/ â† Indices        âŠ˜ Replicate

# Multi-axis primitive: ğ”¾ is applied to ğ•¨ and determines the maximum
# depth of the one-axis case
_onAxes_â†{
  Fâ†ğ”½
  (ğ”¾<â‰¡)âˆ˜âŠ£â—¶{ # One axis
    ! 1â‰¤=ğ•©
    ğ•¨Fğ•©
  }â€¿{ # Multiple axes
    ! 1â‰¥=ğ•¨
    ! (â‰ ğ•¨)â‰¤=ğ•©
    Râ†{(âŠ‘ğ•¨)F(1 Drop1 ğ•¨)âŠ¸RË˜ğ•©}âŸ{0<â‰ ğ•¨}  # Recurse, then handle one axis
    ğ•¨Rğ•©
  }âŸœToArray
}

SelSubâ†{
  ! IsArray ğ•¨
  ! âˆ§Â´â¥ŠIntÂ¨ ğ•¨         # All integers
  ! âˆ§Â´â¥Š ğ•¨ (â‰¥âŸœ-âˆ§<) â‰ ğ•©  # In range
  ğ•¨ +â†© (â‰ ğ•©)Ã—ğ•¨<0       # Wrap negatives
  câ†Ã—Â´sâ†1 Cell ğ•©
  âŠ‘âŸœ(â¥Šğ•©)Â¨(cÃ—ğ•¨)+âŒœsâ¥Šâ†•c  # Extend each index to a whole cell
}
Selectâ†ToArrayâŠ¸(SelSub _onAxes_ 1)

JoinToâ†{
  sâ†ğ•¨â‹ˆâ—‹â‰¢ğ•©
  aâ†1âŒˆÂ´kâ†â‰ Â¨s          # Argument ranks k and result rank a
  ! âˆ§Â´1â‰¥a-k           # Can add at most one axis
  câ†(kÂ¬a)+âŸœ(â†•a-1)âŠ¸âŠÂ¨s # Cell shapes
  ! â‰¡Â´c
  lâ†+Â´(a=k)âŠ£â—¶1â€¿(âŠ‘âŠ¢)Â¨s # Total length
  (âŸ¨lâŸ©âˆ¾âŠ‘c)â¥Šğ•¨âˆ¾â—‹â¥Šğ•©
}

Takeâ†{
  Tâ†{
    ! Int ğ•¨
    lâ†â‰ ğ•©
    # Indices, with clamp and modulus so that fills are all l
    iâ†(l+1)|Â¯1âŒˆlâŒŠ((ğ•¨<0)Ã—ğ•¨+l)+â†•|ğ•¨
    # Don't get the fill if not needed, as it can error
    iâŠJoinToâŸœ(1âŠ¸Cellâ¥ŠFill)âŸ(âˆ¨Â´l=i)ğ•©
  }
  # Add leading 1s to shape of ğ•© first if necessary
  ğ•¨ T _onAxes_ 0 (âŸ¨1âŸ©â¥ŠËœ0âŒˆğ•¨-â—‹â‰ âŠ¢)âŠ¸âˆ¾âˆ˜â‰¢âŠ¸â¥Šğ•©
}
Dropâ†{
  sâ†(â‰ ğ•¨)(âŠ£â†‘âŠ¢âˆ¾Ëœ1â¥ŠËœ0âŒˆ-âŸœâ‰ )â‰¢ğ•©  # Padded shape
  ((sÃ—Â¬âŠ¸-ğ•¨>0)+(-s)âŒˆsâŒŠğ•¨)â†‘ğ•©  # Clamp and complement, then use Take
}
Prefixes â† {!1â‰¤=ğ•© â‹„ (â†•1+â‰ ğ•©)TakeÂ¨<ğ•©}
Suffixes â† {!1â‰¤=ğ•© â‹„ (â†•1+â‰ ğ•©)DropÂ¨<ğ•©}

ShiftBefore â† {!ğ•¨1âŠ¸âŒˆâŠ¸â‰¤â—‹=ğ•© â‹„ ( â‰ ğ•©) â†‘ ğ•¨ JoinTo ğ•©}
ShiftAfter  â† {!ğ•¨1âŠ¸âŒˆâŠ¸â‰¤â—‹=ğ•© â‹„ (-â‰ ğ•©) â†‘ ğ•© JoinTo ğ•¨}
Nudge     â† (1â†‘0â†‘âŠ¢)âŠ¸ShiftBefore
NudgeBack â† (1â†‘0â†‘âŠ¢)âŠ¸ShiftAfter

Windowsâ†{
  ! 1â‰¥=ğ•¨
  ! (â‰ ğ•¨)â‰¤=ğ•©
  ! âˆ§Â´NatÂ¨â¥Šğ•¨
  sâ†ğ•¨â‰ âŠ¸â†‘â‰¢ğ•©
  ! âˆ§Â´ğ•¨â‰¤1+s
  ğ•¨{
    i â† s(Â¬+âŒœâ—‹â†•âŠ¢)â¥Šğ•¨  # Cell indices in ğ•©: add leading and trailing axes
    c â† ><Â¨âŠ¸âŠâŸœğ•©Â¨i    # Select the cells
    ((â‰¢i)âˆ¾ğ•¨â‰ âŠ¸â†“â‰¢ğ•©)â¥Šc  # Reshape in case it's empty
  }âŸ(0<â‰ ğ•¨)ğ•©
}âŸœToArray

Reverse â† {!1â‰¤=ğ•© â‹„ (-â†•âŠ¸Â¬â‰ ğ•©)âŠğ•©}
Rotate â† {!Intğ•¨ â‹„ lâ†â‰ ğ•©â‹„(l|ğ•¨+â†•l)âŠğ•©} _onAxes_ 0

Indicesâ†{
  ! 1==ğ•©
  ! âˆ§Â´NatÂ¨ğ•©
  âŸ¨âŸ©âˆ¾Â´ğ•©â¥ŠÂ¨â†•â‰ ğ•©
}
Rep â† IndicesâŠ¸âŠ
# Expand unit ğ•¨ to length of ğ•©, and check length match for a list
Replicate â† ({0<=ğ•¨}â—¶(âŠ£Ë˜)â€¿{!ğ•¨=â—‹â‰ ğ•©â‹„ğ•¨}RepâŠ¢) _onAxes_ (1-0=â‰ )


#âŒœ
# LAYER 6: Everything else

âˆ¾ â†© Join           âŠ˜ JoinTo
âŠ” â† GroupInds      âŠ˜ Group
â‰ â† Transpose      âŠ˜ ReorderAxes
âˆŠ â† MarkFirst      âŠ˜ (IndexOfËœ<â‰ âˆ˜âŠ¢)
â· â† âˆŠâŠ¸/            âŠ˜ Find
âŠ â† â·âŠ¸IndexOf      âŠ˜ IndexOf
â‹ â†   Cmp _grade   âŠ˜ (  Cmp _bins)
â’ â† -âˆ˜Cmp _grade   âŠ˜ (-âˆ˜Cmp _bins)
âˆ§ â†© â‹âŠ¸âŠ            âŠ˜ âˆ§
âˆ¨ â†© â’âŠ¸âŠ            âŠ˜ âˆ¨
âŠ’ â† OccurrenceCountâŠ˜ ProgressiveIndexOf

identity { fâ€¿iâ†ğ•¨ â‹„ fË™âŠ¸=â—¶ğ•©â€¿i }Â´â†© âŸ¨ âˆ¨â€¿0, âˆ§â€¿1 âŸ©

# Join of empty: multiply shape by (leading) fill shape
JoinEmpty â† ({!ğ•¨â‰¤â—‹â‰ ğ•©â‹„ğ•¨â‰ âŠ¸((ğ•¨Ã—â†‘)âˆ¾â†“)ğ•©}â—‹â‰¢â¥ŠâŠ¢)âŸœFillâŸHasFill

Joinâ†(0<â‰ âˆ˜â¥Š)â—¶âŸ¨JoinEmpty, (0<=)â—¶{!IsArrayğ•©â‹„>ğ•©}â€¿{
  ! IsArray ğ•©
  sâ†â‰¢Â¨ğ•©
  aâ†(â‰¢ğ•©){(sâŠ‘Ëœ(j=ğ•©)âŠ¸Ã—)Â¨â†•ğ•¨}Â¨jâ†â†•râ†=ğ•©    # Skeleton: elements 0,0,â€¦k,â€¦0 along each axis
  hâ†(Â¬âŸœ(âŒˆÂ´)â‰ Â¨)Â¨a                     # Which positions have the axis
  ! âˆ§Â´âˆ§Â´Â¨0â‰¤h                         # Rank can only change by 1 along a line
  oâ†+`âŠ‘Â¨h                            # Starting position of each axis in âŠ‘ğ•©
  tâ†(Â¯1âŠ‘o)â†“âŠ‘s                        # Trailing axes
  lâ†h{ğ•ğ•©}Â¨Ëœ(Â»o){âŠ£â—¶âŸ¨1,ğ•¨âŠ¸âŠ‘âŸ©Â¨âŸœğ•©}Â¨a      # Length of each position on each axis
  ! sâ‰¡(<t)âˆ¾âŒœÂ´hâ¥ŠÂ¨Â¨l                   # Shape agreement
  iâ†(<âŸ¨âŸ©)âˆ¾âŒœÂ´h{((â†•Â¯1âŠ¸âŠ‘)-ğ•©/ğ•¨â¥ŠÂ¨Â»)+`ğ•©}Â¨l # Indices: âˆ¾â†•âˆ˜â‰¢Â¨ğ•© if no trailing axes
  >i<Â¨âŠ¸âŠâŸ(0<â‰ âˆ˜âŠ£)Â¨l/ğ•©
}âŸ©

Groupâ†{
  ! IsArray ğ•©
  ğ•¨ â‹ˆâˆ˜ToArrayâŸ(2>â‰¡)â†©
  ! 1==ğ•¨
  {!âˆ§Â´IntÂ¨ğ•©â‹„!âˆ§Â´Â¯1â‰¤ğ•©}âˆ˜â¥ŠÂ¨ğ•¨  # Atoms in ğ•¨ must be integers â‰¥Â¯1
  nâ†+Â´râ†=Â¨ğ•¨               # Number of ranks grouped for each result axis (r); total (n)
  ! nâ‰¤=ğ•©
  ldâ†(âˆ¾â‰¢âŒœğ•¨)-nâ†‘â‰¢ğ•©          # Extra elements
  ! âˆ§Â´(0âŠ¸â‰¤âˆ§â‰¤âŸœ(r/1=r))ld   # Must be 0 extra, or possibly 1 for rank 1 components
  drâ†râŒŠ(0Â»+`r)âŠldâˆ¾âŸ¨0âŸ©     # Whether each result axis has a minimum length
  sâ†drâŠ£â—¶âŸ¨0,Â¯1âŠ¸âŠ‘âŸ©Â¨ğ•¨        # Minimum shape required by extra elements
  ğ•¨â†©dr(â¥ŠÂ¯1âŠ¸â†“âŸâŠ£)Â¨ğ•¨         # Remove extra elements; deshape components
  sâŒˆâ†©1+Â¯1âŒˆÂ´Â¨ğ•¨             # Result shape
  ğ•©â†©((â‰ Â¨ğ•¨)âˆ¾nâ†“â‰¢ğ•©)â¥Šğ•©        # Merge axes of ğ•© that are handled together in ğ•¨
  (ğ•¨âŠ¸=/ğ•©Ë™)Â¨â†•s             # Construct each result group by filtering
}
GroupIndsâ†{
  ! 1==ğ•©
  ğ•© âŠ” â†• (1<â‰¡)â—¶â‰ â€¿(âˆ¾â‰¢Â¨) ğ•©
}

# Searching: use all-pairs comparisons
IndexOfâ†{
  câ†1-Ëœ=ğ•¨
  ! 0â‰¤c
  ! câ‰¤=ğ•©
  ğ•¨ âˆ§â—‹(0<â‰ )âŸœâ¥Šâ—¶âŸ¨0â¥ŠËœc-âŠ¸â†“â‰¢âˆ˜âŠ¢, (+Ëâˆ§`)â‰¢â‰câ‰câ€¿âˆâŸ© ToArray ğ•©
}
MarkFirstâ†{
  ! 1â‰¤=ğ•©
  uâ†0â†‘ğ•©
  (0<â‰ )â—¶âŸ¨âŸ¨âŸ©,{âŠ‘ğ•©âˆŠu}â—¶{uâˆ¾â†©ğ•©â‹„1}â€¿0Ë˜âŸ©ğ•©
}
Findâ†{
  râ†=ğ•¨
  ! râ‰¤=ğ•©
  ğ•¨ â‰¡â‰r ((1+r-âŠ¸â†‘â‰¢ğ•©)âŒŠâ‰¢ğ•¨)âŠ¸â†•â‰r ğ•©
}â—‹ToArray

ReorderAxesâ†{
  ğ•©<âŸ(0=â‰¡)â†©
  ! 1â‰¥=ğ•¨
  ğ•¨â¥Šâ†©
  ! (â‰ ğ•¨)â‰¤=ğ•©
  ! âˆ§Â´NatÂ¨ğ•¨
  râ†(=ğ•©)-+Â´Â¬âˆŠğ•¨      # Result rank: duplicates in ğ•¨ reduce it
  ! âˆ§Â´ğ•¨<r
  ğ•¨âˆ¾â†©ğ•¨(Â¬âˆ˜âˆŠËœ/âŠ¢)â†•r    # Add unused axes to the end
  (ğ•¨âŠ¸âŠâŠ‘ğ•©Ë™)Â¨â†•âŒŠÂ´Â¨ğ•¨âŠ”â‰¢ğ•© # Reorder indices to select result elements
}
Transposeâ†(0<=)â—¶âŸ¨ToArray,(=-1Ë™)âŠ¸ReorderAxesâŸ©

# Sorting
Cmp â† âŒˆâ—‹IsArrayâ—¶{ # No arrays
  ğ•¨(>-<)ğ•©
}â€¿{ # At least one array
  edâ†-Â´eâ†ğ•¨â‹ˆâ—‹(âˆ§Â´0<â‰¢)ğ•©
  ğ•¨(ed=0)â—¶edâ€¿{
    # Backup ordering by rank
    câ†ğ•¨Ã—âˆ˜-â—‹(IsArray+=)ğ•©
    # l is the number of elements to compare
    # Also update backup ordering c if lengths differ
    sâ†â‰¢ğ•¨ â‹„ tâ†â‰¢ğ•© â‹„ râ†ğ•¨âŒŠâ—‹=ğ•©
    lâ†s{iâ†+Â´âˆ§`ğ•¨=ğ•©â‹„mâ†(Ã—Â´e)Ã—Â´iâ†‘ğ•¨â‹„{câ†©Ã—-Â´ğ•©â‹„mÃ—â†©âŒŠÂ´ğ•©}âˆ˜(âŠ‘Â¨âŸœğ•¨â€¿ğ•©)âŸ(râŠ¸>)iâ‹„m}â—‹(râ†‘âŒ½)t
    # Compare elements, stopping at the first difference
    aâ†â¥Šğ•¨â‹„bâ†â¥Šğ•©
    Travâ†(=âŸœl)â—¶{Travâˆ˜(1+ğ•©)âŸ(0âŠ¸=)a Cmpâ—‹(ğ•©âŠ¸âŠ‘)b}â€¿c
    Trav 0
  }ğ•©
}

_gradeâ†{
  ! 1â‰¤=ğ•©
  # Compare all cells and break ties with indices
  # Then sum and invert as a permutation
  iâŠËœ+Â´Ë˜(ğ”½â‰âˆâ€¿Â¯1â‰Â¯1â€¿âˆËœğ•©)(âŒˆâŸœ0+=âŸœ0âŠ¸Ã—)>âŒœËœiâ†â†•â‰ ğ•©
}
_binsâ†{
  câ†1-Ëœ=ğ•¨                       # Rank of compared cells
  ! 0â‰¤c
  ! câ‰¤=ğ•©
  LEâ†ğ”½â‰câ‰¤0Ë™                     # Does ğ•¨ precede ğ•©?
  ! (0<â‰ )â—¶âŸ¨1,âˆ§Â´Â·LEËË˜2â†•âŠ¢âŸ©ğ•¨       # ğ•¨ must be ordered
  ğ•¨ (0<â‰ ğ•¨)â—¶âŸ¨0â‰câˆ˜âŠ¢,+ËLEâ‰Â¯1â€¿âˆâŸ© ğ•©  # Number of ğ•¨ cells preceding or matching each ğ•© cell
}

# In the result of â‹â‹, matching cells get consecutive indices
# Select with âŠËœ to get the first, and subtract for the occurrence count
OccurrenceCount â† (âŠ¢-âŠ)âŸœ(â‹â‹)âŠËœ
# Tag each cell with an occurrence count, then search
ProgressiveIndexOf â† {ğ•¨âŠâ—‹(((â‰¢âˆ¾2Ë™)â¥Šâ‰Ë˜âŸœOccurrenceCountâˆ˜â¥Š)ğ•¨âŠ¸âŠ)ğ•©}
