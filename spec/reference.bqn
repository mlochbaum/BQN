â This file gives reference implementations of BQN primitives assuming
â limited initial functionality. Implementations are designed to be
â simple and not fast.

â Not yet included: characters, complex numbers, comparison tolerance,
â selective assignment, and Under.

â In some cases an operation is defined with limited functionality at
â first and later expanded. For convenience, rather than renaming these
â limited versions, every primitive use refers to the most recent
â definition in source code, as if redefinitions shadowed previous
â primitive definitions.


ââŒœ
â LAYER 0: Assumed functionality

â IEEE 754, except NaN results cause an error and -0 is converted to 0.
â LIMITED to the stated cases and real number arguments.
+          â                Add
-          â Negate         Subtract
Ã—          â                Multiply
Ã·          â Reciprocal     Divide
â‹†          â Exponential    Power
âŒŠ          â Floor
=          â                Equals
â‰¤          â                Less Than or Equal to

â Other basic functionality that we need to assume
IsArray    â Return 1 if ğ•© is an array
!          â ğ•© is 0 or 1; throw an error if it's 0
â‰¢          â LIMITED to monadic case
â¥Š          â LIMITED to array ğ•© and (Ã—Â´ğ•¨)â‰¡â‰¢ğ•©
âŠ‘          â LIMITED to natural number ğ•© and vector ğ•¨
_amend     â {(ğ•—âŠ‘ğ•©)â†©ğ•¨â‹„ğ•©}
â†•          â LIMITED to number ğ•©
Identity   â Left or right identity of function ğ•
â¼          â Inverse of function ğ”½
Type       â Scalar (enclosed) prototype of ğ•©


ââŒœ
â LAYER 1: Foundational operators and functions

â Combinators
â—¶ â† {ğ•¨((ğ•¨ğ”½ğ•©)âŠ‘ğ•˜){ğ”½}ğ•©}     â LIMITED to number left operand result
âŠ˜ â† {ğ•¨((1{ğ”½}ğ•¨)-0)â—¶ğ”½â€¿ğ”¾ ğ•©}
âŠ¢ â† {ğ•©}
âŠ£ â† {ğ•¨}âŠ˜{ğ•©}
Ëœ â† {ğ•©ğ”½ğ•¨âŠ£ğ•©}
âˆ˜ â† {ğ”½ğ•¨ğ”¾ğ•©}
â—‹ â† {(ğ”¾ğ•¨)ğ”½ğ”¾ğ•©}
âŠ¸ â† {(ğ”½ğ•¨)ğ”¾ğ•©}ËœËœ
âŸœ â† {ğ•¨ğ”½ğ”¾ğ•©}ËœËœ

â LIMITED to numeric arguments for scalar cases
âˆš â† 2âŠ¸âˆš      âŠ˜ (â‹†âŸœÃ·Ëœ)
âˆ§ â†            Ã—
âˆ¨ â†            (+-Ã—)
Â¬ â† 1+-
| â† Ã—âŸœÃ—      âŠ˜ {ğ•©-ğ•¨Ã—âŒŠğ•©Ã·ğ•¨}
< â† {âŸ¨âŸ©â¥ŠâŸ¨ğ•©âŸ©} âŠ˜ (Â¬â‰¤Ëœ)
> â†            (Â¬â‰¤)
â‰¥ â† !âˆ˜0      âŠ˜ (â‰¤Ëœ)
â‰  â† Length   âŠ˜ (Â¬âˆ˜=)
Ã— â†© 0âŠ¸(<->)  âŠ˜ Ã—
âŒŠ â†© âŒŠ        âŠ˜ {(ğ•¨>ğ•©)âŠ‘ğ•¨â€¿ğ•©}
âŒˆ â† -âˆ˜âŒŠâˆ˜-    âŠ˜ {(ğ•¨<ğ•©)âŠ‘ğ•¨â€¿ğ•©}
â‰¢ â†© IsArrayâ—¶âŸ¨âŸ©â€¿â‰¢  â LIMITED to monadic case

Â¨ â† _eachm   â LIMITED to monadic case and array ğ•©
Â´ â† _reduce

_eachmâ†{
  râ†â¥Šğ•© â‹„ Fâ†ğ”½
  Eâ†(â‰ r)âŸœâ‰¤â—¶{râ†©rğ•©_amendËœFğ•©âŠ‘râ‹„Eğ•©+1}â€¿âŠ¢
  E 0 â‹„ (â‰¢ğ•©)â¥Šr
}
_reduceâ†{
  ! 1=â‰ â‰¢ğ•©
  lâ†â‰ vâ†ğ•© â‹„ Fâ†ğ”½
  râ†ğ•¨ (0<l)â—¶{Identity f}â€¿{lâ†©l-1â‹„(l-1)âŠ‘ğ•©}âŠ˜âŠ£ ğ•©
  {râ†©(ğ•©âŠ‘v)F r}Â¨(l-1)âŠ¸-Â¨â†•l
  r
}
Length â† (0<0âŠ‘â‰¢)â—¶âŸ¨0â‹„0âŠ‘âŠ¢âŸ©âˆ˜â‰¢


ââŒœ
â LAYER 2: Pervasion
â After defining _perv, we apply it to all scalar functions,
â making them pervasive. I'm not going to write that out.

ToArray â† IsArrayâ—¶<â€¿âŠ¢

âˆ¾ â† {kâ†â‰ ğ•¨â‹„kâŠ¸â‰¤â—¶âŸ¨âŠ‘âŸœğ•¨â‹„-âŸœkâŠ‘ğ•©ËœâŸ©Â¨â†•k+â‰ ğ•©}  â LIMITED to two vector arguments

_tableâ†{
  mâ†â‰ aâ†â¥Šğ•¨ â‹„ nâ†â‰ bâ†â¥Šğ•© â‹„ Fâ†ğ”½
  râ†â†•mÃ—n
  {ğ•©âŠ¸{râ†©r((nÃ—ğ•¨)+ğ•©)_amendËœ(ğ•¨âŠ‘a)F(ğ•©âŠ‘b)}Â¨â†•n}Â¨â†•m
  (ğ•¨âˆ¾â—‹â‰¢ğ•©)â¥Šr
}

_eachdâ†{
  _eâ†{ â ğ•¨ has smaller or equal rank
    kâ†â‰ pâ†â‰¢ğ•¨ â‹„ qâ†â‰¢ğ•©
    ! âˆ§Â´(âŠ‘âŸœp=âŠ‘âŸœq)Â¨â†•k
    lâ†Ã—Â´(pâŠ‘ËœkâŠ¸+)Â¨â†•qâ‰ âŠ¸-k
    aâ†â¥Šğ•¨ â‹„ bâ†â¥Šğ•© â‹„ Fâ†ğ”½
    (â‰ a) (âŠ‘âŸœağ”½lâŠ¸Ã—âŠ¸+âŠ‘bËœ)_tableâ—‹â†• l
  }
  (>â—‹(â‰ â‰¢))â—¶âŸ¨ğ”½_eâ‹„ğ”½Ëœ_eËœâŸ©
}
_pervâ†{ â Pervasion
  (Â¬âˆ§â—‹IsArray)â—¶âŸ¨ğ”½â‹„ğ”½Â¨âŸ©
}

âŒœ â† {(ğ”½_eachm)âŠ˜(ğ”½_table)â—‹ToArray}
Â¨ â†© {(ğ”½_eachm)âŠ˜(ğ”½_eachd)â—‹ToArray}


ââŒœ
â LAYER 3: Remove other limits
â Now all implementations are full except âˆ¾; â†• is monadic only

Intâ†IsArrayâ—¶âŸ¨âŒŠâŠ¸=,0âŸ©
Natâ†IsArrayâ—¶âŸ¨0âŠ¸â‰¤âˆ§âŒŠâŠ¸=,0âŸ©

Deshapeâ†IsArrayâ—¶{âŸ¨ğ•©âŸ©}â€¿â¥Š
Reshapeâ†{
  ! 1â‰¥â‰ â‰¢ğ•¨
  ! âˆ§Â´NatÂ¨ğ•¨
  nâ†â‰ ğ•© â‹„ lâ†Ã—Â´ğ•¨
  ! nâ‰¤â—‹(0âŠ¸=)l
  ğ•¨â¥ŠâŠ‘âŸœğ•©Â¨n|â†•l
}âŸœDeshape

Rangeâ†{
  Iâ†{!Natğ•©â‹„â†•ğ•©}
  Mâ†{!1=â‰ â‰¢ğ•©â‹„(<âŸ¨âŸ©)â¥ŠâŠ¸âˆ¾âŒœÂ´IÂ¨ğ•©}
  IsArrayâ—¶Iâ€¿M ğ•©
}

Pick1â†{
  ! 1=â‰ â‰¢ğ•¨
  ! ğ•¨=â—‹â‰ sâ†â‰¢ğ•©
  ! âˆ§Â´NatÂ¨ğ•¨
  ! âˆ§Â´ğ•¨<s
  (â¥Šğ•©)âŠ‘Ëœ0(âŠ‘âŸœğ•¨+âŠ‘âŸœsÃ—âŠ¢)Â´â†•â‰ ğ•¨
}
Pickdâ†(âˆ¨Â´IsArrayÂ¨)â—¶Pick1â€¿{PickdâŸœğ•©Â¨ğ•¨}
Pickâ†IsArrayâˆ˜âŠ£â—¶âŠ‘â€¿Pickd

matchâ†{Â¬âˆ˜(0âŠ‘ğ•¨)â—¶(1âŠ‘ğ•¨)â€¿ğ•©}Â´âŸ¨
  âŸ¨â‰ â—‹IsArray , 0âŸ©
  âŸ¨Â¬IsArrayâˆ˜âŠ¢, =âŸ©
  âŸ¨â‰ â—‹(â‰ â‰¢)    , 0âŸ©
  âŸ¨âˆ¨Â´â‰ â—‹â‰¢     , 0âŸ©
  {âˆ§Â´â¥Šğ•¨MatchÂ¨ğ•©}
âŸ©
  
Depthâ†IsArrayâ—¶0â€¿{1âŒˆÂ´DepthÂ¨â¥Šğ•©}

âŠ‘ â†© (0Â¨âˆ˜â‰¢)âŠ¸Pick    âŠ˜ Pick
â¥Š â†© Deshape        âŠ˜ Reshape
â†• â†© Range
â—¶ â†© {ğ•¨((ğ•¨ğ”½ğ•©)âŠ‘ğ•˜){ğ”½}ğ•©}  â Same definition, new Pick

â‰¡ â† Depth          âŠ˜ Match
â‰¢ â†© â‰¢              âŠ˜ (Â¬Match)


ââŒœ
â LAYER 4: Operators

> â†© Unbox          âŠ˜ >
â‰ â† >âˆ˜Pair
â‰ â† _rankOp_
âš‡ â† _depthOp_
âŸ â† _iterate_
Ë˜ â† â‰Â¯1
` â† _scan

Cell â† {âŠ‘âŸœğ•©Â¨ğ•¨+â†•ğ•¨-Ëœâ‰ ğ•©}âŸœâ‰¢  â â†“âŸœâ‰¢
Pair â† {âŸ¨ğ•©âŸ©} âŠ˜ {âŸ¨ğ•¨,ğ•©âŸ©}

Unboxâ†(0<â‰ âˆ˜â¥Š)â—¶âŠ¢â€¿{
  câ†â‰¢âŠ‘ğ•©
  ! âˆ§Â´â¥Š(câ‰¡â‰¢)Â¨ğ•©
  ğ•©âŠ‘âŸœToArrayËœâŒœâ†•c
}
_ranks â† {âŸ¨2âŸ©âŠ˜âŸ¨1,0âŸ©((âŠ£-1+|)ËœâŸœâ‰ âŠ‘Â¨<âˆ˜âŠ¢)â¥Šâˆ˜ğ”½}
_depthOp_â†{
  negâ†0>nâ†ğ•¨ğ”¾_ranksğ•© â‹„ Fâ†ğ”½
  _dâ†{(âˆ§Â´(negâˆ§ğ•—=0)âˆ¨(0âŒˆğ•—)â‰¥Pairâ—‹â‰¡)â—¶âŸ¨(ğ•—+neg)_dÂ¨â‹„FâŸ©}
  ğ•¨ n _d ğ•©
}
_rankOp_â†{
  kâ†ğ•¨(Pairâ—‹(â‰ â‰¢) (0<âŠ£)â—¶âŸ¨0âŒˆ+,âŒŠâŸ© ğ”¾_ranks)ğ•©
  Encâ†{
    fâ†âŠ‘âŸœ(â‰¢ğ•©)Â¨â†•ğ•¨
    câ†Ã—Â´sâ†ğ•¨Cellğ•©
    fâ¥ŠâŠ‘âŸœ(â¥Šğ•©)Â¨âˆ˜((sâ¥Šâ†•c)+cÃ—âŠ¢)Â¨â†•Ã—Â´f
  }
  > ((âŠ‘k)Encğ•¨) ğ”½Â¨ ((1-Ëœâ‰ )âŠ¸âŠ‘k)Encğ•©
}
_scanâ†{
  ! IsArray ğ•©
  ! 1â‰¤â‰ â‰¢ğ•©
  Fâ†ğ”½
  (0<â‰ âˆ˜â¥Š)â—¶âŠ¢â€¿{
    râ†â¥Šğ•© â‹„ lâ†â‰ ğ•© â‹„ câ†Ã—Â´1 Cell ğ•©
    {râ†©rğ•©_amendËœğ•¨Fâ—‹(âŠ‘âŸœr)ğ•©}âŸœ(câŠ¸+)Â¨â†•c-Ëœâ‰ r
    (â‰¢ğ•©)â¥Šr
  }ğ•©
}
_iterate_â†{
  nâ†ğ•¨ğ”¾ğ•©
  Fâ†ğ•¨(0âŠ˜1)â—¶âŸ¨ğ”½,ğ•¨âŠ¸ğ”½âŸ©
  lâ†uâ†0
  {!Intğ•©â‹„lâ†©lâŒŠğ•©â‹„uâ†©uâŒˆğ•©}âš‡0 n
  aâ†ğ•©â‹„_pâ†{ğ”½âˆ˜âŠ£`(1+ğ•©)â¥Š<a}
  posâ†F _p u â‹„ negâ†Fâ¼_p-l
  (|âŠ‘<âŸœ0âŠ‘posâ€¿negËœ)âš‡0 n
}


ââŒœ
â LAYER 5: Structural functions

âŠ â† 0âŠ¸Select       âŠ˜ Select
â†‘ â† Prefixes       âŠ˜ Take
â†“ â† Suffixes       âŠ˜ Drop
â†• â†© â†•              âŠ˜ Windows
âŒ½ â† Reverse        âŠ˜ Rotate
/ â† Indices        âŠ˜ Replicate

_onAxes_â†{
  Fâ†ğ”½
  (ğ”¾<â‰¡)âˆ˜âŠ£â—¶{ â One axis
    ! 1â‰¤â‰ â‰¢ğ•©
    ğ•¨Fğ•©
  }â€¿{ â Multiple axes
    ! 1â‰¥â‰ â‰¢ğ•¨
    ! ğ•¨â‰¤â—‹â‰ â‰¢ğ•©
    Râ†{(âŠ‘ğ•¨)F(1â†“ğ•¨)âŠ¸RË˜ğ•©}âŸ{0<â‰ ğ•¨}
    ğ•¨Rğ•©
  }
}

SelSubâ†{
  ! IsArray ğ•¨
  ! NatÂ¨ ğ•¨
  ! ğ•¨ <Â¨ â‰ ğ•©
  câ†Ã—Â´sâ†1 Cell ğ•©
  âŠ‘âŸœ(â¥Šğ•©)Â¨(cÃ—ğ•¨)+âŒœsâ¥Šâ†•c
}
Selectâ†ToArrayâŠ¸(SelSub _onAxes_ (1-0=â‰ ))

JoinToâ†{
  sâ†ğ•¨Pairâ—‹â‰¢ğ•©
  aâ†1âŒˆÂ´kâ†â‰ Â¨s
  ! âˆ§Â´1â‰¥a-k
  câ†(a-k)+âŸœ(â†•a-1)âŠ¸âŠÂ¨s
  ! â‰¡Â´c
  lâ†+Â´(a=k)âŠ£â—¶1â€¿(âŠ‘âŠ¢)Â¨s
  (âŸ¨lâŸ©âˆ¾c)â¥Šğ•¨âˆ¾â—‹â¥Šğ•©
}

Takeâ†{
  Tâ†{
    ! Int ğ•¨
    lâ†â‰ x
    iâ†((ğ•¨<0)Ã—ğ•¨+l)+â†•|ğ•¨
    ((l+1)|Â¯1âŒˆlâŒŠi)âŠğ•©âˆ¾(1 Cell ğ•©)â¥ŠType ğ•©
  }
  T _onAxes_ 0 (âŸ¨1âŸ©â¥ŠËœ0âŒˆğ•¨-â—‹â‰ âŠ¢)âŠ¸âˆ¾âˆ˜â‰¢âŠ¸â¥Šğ•©
}
Dropâ†{
  sâ†(â‰ ğ•¨)(âŠ£â†‘âŠ¢âˆ¾â¥ŠËœ0âŒˆ-âŸœâ‰ )â‰¢ğ•©
  ((sÃ—Â¯1â‹†ğ•¨>0)+(-s)âŒˆsâŒŠğ•¨)â†‘ğ•©
}
Prefixes â† {!1â‰¤â‰ â‰¢ğ•© â‹„ (â†•1+â‰ ğ•©)TakeÂ¨<ğ•©}
Suffixes â† {!1â‰¤â‰ â‰¢ğ•© â‹„ (â†•1+â‰ ğ•©)DropÂ¨<ğ•©}

Windowsâ†{
  ! IsArray ğ•©
  ! 1â‰¥â‰ â‰¢ğ•¨
  ! ğ•¨â‰¤â—‹â‰ â‰¢ğ•©
  ! âˆ§Â´NatÂ¨â¥Šğ•¨
  sâ†(â‰ ğ•¨)â†‘â‰¢ğ•©
  ! âˆ§Â´ğ•¨â‰¤s
  ><Â¨âŠ¸âŠâŸœğ•©Â¨s(Â¬+âŒœâ—‹â†•âŠ¢)â¥Šğ•¨
}

Reverse â† {!1â‰¤â‰ â‰¢ğ•© â‹„ (-â†•âŠ¸Â¬â‰ ğ•©)âŠğ•©}
Rotate â† {!Natğ•¨ â‹„ lâ†â‰ xâ‹„(l|ğ•¨+â†•l)âŠğ•©} _onAxes_ 0

Indicesâ†{
  ! 1=â‰ â‰¢ğ•©
  ! âˆ§Â´NatÂ¨ğ•©
  âŸ¨âŸ©âˆ¾Â´ğ•©â¥ŠÂ¨â†•â‰ ğ•©
}
Replicate â† {0<â‰ â‰¢ğ•¨}â—¶(â¥ŠËœâŸœâ‰ /âŠ¸âŠâŠ¢)â€¿{!ğ•¨=â—‹â‰ ğ•©â‹„ğ•¨/âŠ¸âŠğ•©} _onAxes_ 1


ââŒœ
â LAYER 6: Everything else

âˆ¾ â†© Join           âŠ˜ JoinTo
âŠ” â† âŠ”âŸœ(â†•âˆ˜â‰ âš‡1)      âŠ˜ Group
â‰ â† Transpose      âŠ˜ ReorderAxes
âŠ â† !âˆ˜0            âŠ˜ IndexOf
âˆŠ â† UniqueMask     âŠ˜ (âŠËœ<â‰ âˆ˜âŠ¢)
â· â† âˆŠâŠ¸/            âŠ˜ Find
â‹ â†   Cmp _grade   âŠ˜ (  Cmp _bins)
â’ â† -âˆ˜Cmp _grade   âŠ˜ (-âˆ˜Cmp _bins)
âˆ§ â†© â‹âŠ¸âŠ            âŠ˜ âˆ§
âˆ¨ â†© â’âŠ¸âŠ            âŠ˜ âˆ¨
âŠ’ â† OccurrenceCountâŠ˜ ProgressiveIndexOf

Joinâ†{
  Câ†(<âŸ¨âŸ©)â¥ŠâŠ¸âˆ¾âŒœÂ´âŠ¢  â Cartesian array product
  ! IsArray ğ•©
  sâ†â‰¢Â¨ğ•©
  câ†â‰ âŠ‘s
  ! âˆ§Â´c=â‰ Â¨s
  ! câ‰¥â‰ â‰¢ğ•©
  lâ†(â‰¢ğ•©){(ğ•©âŠ‘aâŠ‘Ëœ(j=ğ•©)âŠ¸Ã—)Â¨â†•ğ•¨}Â¨jâ†â†•â‰ â‰¢aâ†ğ•©
  ! sâ‰¡C l
  iâ†C{pâ†+Â´Â¨â†‘ğ•©â‹„(â†•âŠ‘âŒ½p)-ğ•©/Â¯1â†“p}Â¨l
  >i<Â¨âŠ¸âŠÂ¨l/ğ•©
}âŸ(0<â‰ âˆ˜â¥Š)

Groupâ†{
  ! IsArray ğ•©
  Chkâ†{!1=â‰ â‰¢ğ•©â‹„!NatÂ¨ğ•©â‹„â‰ ğ•©}
  lâ†(1<â‰¡)â—¶Chkâ€¿{!1=â‰ â‰¢ğ•©â‹„ChkÂ¨ğ•©}ğ•¨
  ! lâ‰¤â—‹â‰ â‰¢ğ•©
  ! âˆ§Â´l=lâ‰ âŠ¸â†‘â‰¢ğ•©
  (ğ•¨âŠ¸=/ğ•©Ëœ)Â¨â†•1+0âŒˆÂ´âš‡1ğ•¨
}

ReorderAxesâ†{
  ğ•©â†©<âŸ(0=â‰¡)ğ•©
  ! ğ•¨â‰¤â—‹â‰ â‰¢ğ•©
  râ†(â‰ â‰¢ğ•©)-+Â´Â¬âˆŠğ•¨
  ! âˆ§Â´ğ•¨<r
  ğ•¨â†©ğ•¨âˆ¾ğ•¨(Â¬âˆ˜âˆŠËœ/âŠ¢)â†•r
  (ğ•¨âŠ¸âŠâŠ‘ğ•©Ëœ)Â¨â†•Ã—Â´Â¨ğ•¨âŠ”â‰¢ğ•©
}
Transposeâ†(â‰ âˆ˜â‰¢-1Ëœ)âŠ¸ReorderAxesâŸ(0<â‰ âˆ˜â‰¢)

â Searching
IndexOfâ†{
  câ†1-Ëœâ‰ â‰¢ğ•¨
  ! 0â‰¤c
  ğ•¨ (0<â‰ ğ•¨)â—¶âŸ¨0â‰câˆ˜âŠ¢,(+Â´âˆ§`)â‰¡â‰câ‰âˆâ€¿câŸ© ğ•©
}
UniqueMaskâ†{
  ! 1â‰¤â‰ â‰¢ğ•©
  uâ†0â†‘ğ•©
  {ğ•©âˆŠu}âŠ˜{uâ†©uâˆ¾ğ•©â‹„1}â€¿0Ë˜ğ•©
}
Findâ†{
  râ†â‰ sâ†â‰¢ğ•¨
  ğ•¨â‰¡â‰r sâ†•â‰r ğ•©
}

â Sorting
Cmp â† âˆ¨â—‹IsArrayâ—¶{ â No arrays
  ğ•¨(<->)ğ•© â Assume they're numbers
}â€¿{ â At least one array
  eâ†ğ•¨-Ëœâ—‹(âˆ¨Â´0=â‰¢)ğ•©
  ğ•¨(e=0)â—¶eâ€¿{
    câ†ğ•¨Ã—âˆ˜-â—‹(IsArray+â‰ âˆ˜â‰¢)ğ•©
    sâ†â‰¢ğ•¨ â‹„ tâ†â‰¢ğ•© â‹„ râ†sâŒŠâ—‹â‰ t
    lâ†s{iâ†+Â´âˆ§`ğ•¨=ğ•©â‹„mâ†Ã—Â´iâ†‘ğ•¨â‹„{câ†©Ã—-Â´ğ•©â‹„mâ†©mÃ—âŒŠÂ´ğ•©}âˆ˜(âŠ‘Â¨âŸœğ•¨â€¿ğ•©)âŸ(râŠ¸>)iâ‹„m}â—‹(râ†‘âŒ½)t
    aâ†â¥Šğ•¨â‹„bâ†â¥Šğ•©
    Travâ†(=âŸœl)â—¶câ€¿{Travâˆ˜(1+ğ•©)âŸ(0âŠ¸=)a Cmpâ—‹(ğ•©âŠ¸âŠ‘)b}
    Trav 0
  }ğ•©
}

_gradeâ†{
  ! 1â‰¤â‰ â‰¢ğ•©
  iâŠ+Â´(ğ”½â‰âˆâ€¿Â¯1â‰Â¯1â€¿âˆËœğ•©)(âŒˆâŸœ0+=âŸœ0âŠ¸Ã—)<âŒœËœiâ†â†•â‰ ğ•©
}
_binsâ†{
  râ†1-Ëœâ‰ â‰¢ğ•¨
  ! 0â‰¤r
  LEâ†0â‰¤ğ”½â‰r
  ! âˆ§Â´LEÂ´Ë˜2â†•<Ë˜ğ•©
  +Â´ğ•¨LEâ‰Â¯1â€¿âˆğ•©
}

OccurrenceCount â† âŠËœ(âŠ¢-âŠ)â‹âˆ˜â‹
ProgressiveIndexOf â† {ğ•¨âŠâ—‹(â‰Ë˜âŸœOccurrenceCountğ•¨âŠ¸âŠ)ğ•©}
