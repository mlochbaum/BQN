#!/usr/bin/env dbqn

impl â† "
#âŒœ
# LAYER 3: Remove other limits
# Now all implementations are full but â†• is monadic only

Intâ†IsArrayâ—¶âŸ¨âŒŠâŠ¸=,0âŸ©
Natâ†IsArrayâ—¶âŸ¨0âŠ¸â‰¤âˆ§âŒŠâŠ¸=,0âŸ©


#âŒœ
# LAYER 4: Operators


Cell â† â†“âŸœâ‰¢

_ranks â† {âŸ¨2âŸ©âŠ˜âŸ¨1,0âŸ©((âŠ£-1+|)ËœâŸœâ‰ âŠ‘Â¨<âˆ˜âŠ¢)â¥Šâˆ˜ğ”½}
_depthOp_â†{
  negâ†0>nâ†ğ•¨ğ”¾_ranksğ•© â‹„ Fâ†ğ”½
  _dâ†{
    Râ†(ğ•—+neg)_d
    ğ•¨(2â¥Š(negâˆ§ğ•—â‰¥0)âˆ¨(0âŒˆğ•—)â‰¥â‰â—‹<â—‹â‰¡)â—¶(âŸ¨RÂ¨â‹„RâŸœğ•©Â¨âˆ˜âŠ£âŸ©â‰âŸ¨(ğ•¨RâŠ¢)Â¨âˆ˜âŠ¢â‹„FâŸ©)ğ•©
  }
  ğ•¨ n _d ğ•©
}
âš‡ â† _depthOp_


#âŒœ
# LAYER 5: Structural functions

_onAxes_â†{
  Fâ†ğ”½
  (ğ”¾<â‰¡)âˆ˜âŠ£â—¶{ # One axis
    ! 1â‰¤â‰ â‰¢ğ•©
    ğ•¨Fğ•©
  }â€¿{ # Multiple axes
    ! 1â‰¥â‰ â‰¢ğ•¨
    ! ğ•¨â‰¤â—‹â‰ â‰¢ğ•©
    Râ†{(âŠ‘ğ•¨)F(1â†“ğ•¨)âŠ¸RË˜ğ•©}âŸ{0<â‰ ğ•¨}
    ğ•¨Rğ•©
  }
}

Windowsâ†{
  ! IsArray ğ•©
  ! 1â‰¥â‰ â‰¢ğ•¨
  ! ğ•¨â‰¤â—‹â‰ â‰¢ğ•©
  ! âˆ§Â´NatÂ¨â¥Šğ•¨
  sâ†(â‰ ğ•¨)â†‘â‰¢ğ•©
  ! âˆ§Â´ğ•¨â‰¤1+s
  ğ•¨{(âˆ¾âŸœ(ğ•¨â‰ âŠ¸â†“â‰¢ğ•©)âˆ˜â‰¢â¥Š>)<Â¨âŠ¸âŠâŸœğ•©Â¨s(Â¬+âŒœâ—‹â†•âŠ¢)â¥Šğ•¨}âŸ(0<â‰ ğ•¨)ğ•©
}

Rotate â† âŒ½ _onAxes_ 0

â†• â†© â†•              âŠ˜ Windows
âŒ½ â†© âŒ½              âŠ˜ Rotate


#âŒœ
# LAYER 6: Everything else


Joinâ†{
  Câ†(<âŸ¨âŸ©)â¥ŠâŠ¸âˆ¾âŒœÂ´âŠ¢  # Cartesian array product
  ! IsArray ğ•©
  sâ†â‰¢Â¨ğ•©
  dâ†â‰ âŠ‘s
  ! âˆ§Â´â¥Šd=â‰ Â¨s
  ! dâ‰¥â‰ â‰¢ğ•©
  lâ†(â‰¢ğ•©){(ğ•©âŠ‘âŸœâ‰¢aâŠ‘Ëœ(j=ğ•©)âŠ¸Ã—)Â¨â†•ğ•¨}Â¨jâ†â†•râ†â‰ â‰¢aâ†ğ•©
  ! (râ†‘Â¨s)â‰¡C l
  iâ†C{pâ†+Â´Â¨â†‘ğ•©â‹„(â†•âŠ‘âŒ½p)-ğ•©/Â¯1â†“p}Â¨l
  >i<Â¨âŠ¸âŠÂ¨l/ğ•©
}âŸ(0<â‰ âˆ˜â¥Š)

âˆ¾ â†© Join           âŠ˜ âˆ¾

# Searching
IndexOfâ†(1<âŒˆâ—‹(â‰ â‰¢))â—¶âŠâ€¿{
  câ†1-Ëœâ‰ â‰¢ğ•¨
  ! 0â‰¤c
  ğ•¨ (0<â‰ ğ•¨)â—¶âŸ¨0â‰câˆ˜âŠ¢,((+Â´<Ë˜)âˆ§`)â‰¢â‰câ‰câ€¿âˆâŸ© ğ•©
}
UniqueMaskâ†{
  ! 1â‰¤â‰ â‰¢ğ•©
  uâ†0â†‘ğ•©
  {(â‰ u)>âŠ‘u IndexOf ğ•©}â—¶{uâ†©uâˆ¾ğ•©â‹„1}â€¿0Ë˜ğ•©
}
Findâ†{
  râ†â‰ sâ†â‰¢ğ•¨
  ! râ‰¤â‰ â‰¢ğ•©
  ğ•¨ â‰¡â‰r s â†•â‰r ğ•©
}

âŠ â† !âˆ˜0            âŠ˜ IndexOf
âˆŠ â† UniqueMask     âŠ˜ (âŠËœ<â‰ âˆ˜âŠ¢)
â· â† âˆŠâŠ¸/            âŠ˜ Find

ReorderAxesâ†{
  ğ•©â†©<âŸ(0=â‰¡)ğ•©
  ! 1â‰¥â‰ â‰¢ğ•¨
  ğ•¨â†©â¥Šğ•¨
  ! ğ•¨â‰¤â—‹â‰ â‰¢ğ•©
  ! âˆ§Â´NatÂ¨â¥Šğ•¨
  râ†(â‰ â‰¢ğ•©)-+Â´Â¬âˆŠğ•¨
  ! âˆ§Â´ğ•¨<r
  ğ•¨â†©ğ•¨âˆ¾ğ•¨(Â¬âˆ˜âˆŠËœ/âŠ¢)â†•r
  (ğ•¨âŠ¸âŠâŠ‘ğ•©Ëœ)Â¨â†•âŒŠÂ´Â¨ğ•¨âŠ”â‰¢ğ•©
}
Transposeâ†(â‰ âˆ˜â‰¢-1Ëœ)âŠ¸ReorderAxesâŸ(0<â‰ âˆ˜â‰¢)
â‰ â† Transpose      âŠ˜ ReorderAxes

# Sorting
Cmp â† âˆ¨â—‹IsArrayâ—¶{ # No arrays
  ğ•¨(>-<)ğ•© # Assume they're numbers
}â€¿{ # At least one array
  eâ†ğ•¨-Ëœâ—‹(0âˆ¨Â´0=â‰¢)ğ•©
  ğ•¨(e=0)â—¶eâ€¿{
    câ†ğ•¨Ã—âˆ˜-â—‹(IsArray+â‰ âˆ˜â‰¢)ğ•©
    sâ†â‰¢ğ•¨ â‹„ tâ†â‰¢ğ•© â‹„ râ†sâŒŠâ—‹â‰ t
    lâ†s{iâ†+Â´âˆ§`ğ•¨=ğ•©â‹„mâ†1Ã—Â´iâ†‘ğ•¨â‹„{câ†©Ã—-Â´ğ•©â‹„mâ†©mÃ—âŒŠÂ´ğ•©}âˆ˜(âŠ‘Â¨âŸœğ•¨â€¿ğ•©)âŸ(râŠ¸>)iâ‹„m}â—‹(râ†‘âŒ½)t
    aâ†â¥Šğ•¨â‹„bâ†â¥Šğ•©
    Travâ†(=âŸœl)â—¶{Travâˆ˜(1+ğ•©)âŸ(0âŠ¸=)a Cmpâ—‹(ğ•©âŠ¸âŠ‘)b}â€¿c
    Trav 0
  }ğ•©
}

_binsâ†{
  câ†1-Ëœâ‰ â‰¢ğ•¨
  ! 0â‰¤c
  LEâ†ğ”½â‰câ‰¤0Ëœ
  ! (0<â‰ )â—¶âŸ¨1,âˆ§Â´Â·LEÂ´Ë˜2â†•<Ë˜âŸ©ğ•¨
  ğ•¨ (0<â‰ ğ•¨)â—¶âŸ¨0â‰câˆ˜âŠ¢,(+Â´<Ë˜)LEâ‰Â¯1â€¿âˆâŸ© ğ•©
}

OccurrenceCount â† âŠËœ(âŠ¢-âŠ)â‹âˆ˜â‹
ProgressiveIndexOf â† {ğ•¨âŠâ—‹(â‰Ë˜âŸœOccurrenceCountğ•¨âŠ¸âŠ)ğ•©}

â‹ â†© â‹              âŠ˜ (  Cmp _bins)
â’ â†© â’              âŠ˜ (-âˆ˜Cmp _bins)
âŠ’ â† OccurrenceCountâŠ˜ ProgressiveIndexOf
"

Xâ†Rawâ†{â‰¤4}
{
  chrsâ†âŸ¨
    "!âˆ¾â†•âŒ½â‰â‹â’âŠâŠ’âˆŠâ·"
    ""
    "âš‡"
  âŸ©
  nc â† â‰ Â¨chrs
  chr â† âˆ¾chrs
  itr â† 0â¥ŠËœâ‰ chr

  init â† " "âŠ¸âˆ¾Â¨(/âŸœ"_"Â¨nc/0â€¿1â€¿1)âˆ¾Â¨(nc/"FMD")âˆ¾Â¨(nc+Â´âŠ¸â†‘â¥Š"AB"âˆ¾âŒœâ€¢a)
  post â† âˆ¾âŸœ" "Â¨/âŸœ"_"Â¨nc/0â€¿0â€¿1
  names â† initâˆ¾Â¨(â€¢UCS 48)âˆ¾Â¨post

  Inc  â† {
    iâ†âŠ‘chrâŠğ•©
    nâ†0 â‹„ itrâ†©{nâ†©1+ğ•©}âŒ¾(iâŠ‘âŠ¢)itr
    namesâ†©((iâŠ‘init)âˆ¾(â€¢UCS 48+n)âˆ¾iâŠ‘post)âŒ¾(iâŠ‘âŠ¢)names
  }

  # starting built-ins
  inpsâ†âŸ¨"ğ•¨  ","ğ•¨,ğ•—","ğ•¨,ğ•˜"âŸ©
  âÂ¨namesâˆ¾Â¨(nc/("â†{âŸ¨"âˆ¾âˆ¾âŸœ"âŸ© â‹„ â""Using undefined built-in ")Â¨inps)âˆ¾Â¨âˆ¾âŸœ"""}"Â¨chr

  # built-in assumptions
  Mod â† â{ğ”½ ((âŠ‘chrâŠğ•¨)âŠ‘names) âˆ¾ " â†© " âˆ¾ ğ•©}

  â"IsArray â† 0â‰ â‰¡"
  â"Type    â† âŸ¨âŸ©â¥Š0âŠ¸â¥Š"

  '!' Mod "{ğ•© â‹„ â‰¤1}âŸÂ¬"
  ModâŸœâ¥ŠÂ¨ "â†•âˆ¾âŒ½âŠâ‹â’"


  # checks if line is a builtin redefinition
  E_isdef â† (3â‰¤â‰ )â—¶âŸ¨0,âˆ§Â´âŸ¨chr," ","â†â†©"âŸ©âˆŠËœÂ¨3âŠ¸â†‘âŸ©

  # removes comments and replaces built-ins with names
  E_proc â† {
    lâ†â‰ chr
    qâ†â‰ `ğ•©âˆŠ"""'" â‹„ fâ†Â¬âˆ¨`qÂ¬âŠ¸âˆ§ğ•©='#'
    âˆ¾ (((lÃ—f/q)+chrâŠ¸âŠ) (â‰¥âŸœl)â—¶âŸ¨âŠ‘âŸœnames,â¥Šâˆ˜âŠ¢âŸ©Â¨ âŠ¢) f/ğ•©
  }

  E_redef â† { # handles [fmd] [â†â†©]
    tail â† E_proc 3â†“ğ•© # must use old def
    Inc âŠ‘ğ•©
    (E_proc 1â†‘ğ•©) âˆ¾ "â†" âˆ¾ tail
  }

  lf â† â€¢UCS 10
  pre â† E_isdefâ—¶E_procâ€¿E_redefÂ¨ lf((âŠ¢-ËœÂ¬Ã—+`)âˆ˜=âŠ”âŠ¢)impl
  Rawâ†©â
  ExecFileâ†{Raw âˆ¾ âˆ¾âŸœlfÂ¨ E_procÂ¨ â€¢LNS ğ•©}
  Xâ†©Rawâˆ˜E_proc
  â âˆ¾ âˆ¾âŸœlfÂ¨ pre
  â‰ â—¶Xâ€¿{ExecFile âŠ‘ğ•©}â€¿{ExecFile âŠ‘ğ•© â‹„ X 1âŠ‘ğ•©} â€¢args
}0
