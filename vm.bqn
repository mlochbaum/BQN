# Create a variable slot.
# A slot also functions as a variable reference, one kind of reference.
# References support some of the following fields:
# - Get:  Get value
# - GetC: Get value, and clear the slot (variable only)
# - SetU: Define value
# - SetN: Change value
# - SetQ: Set value and return 0 if possible, and return 1 if not
# - GetF: Get corresponding field from namespace ğ•©
MakeVar â† { program ğ•Š name:
  vâ†@  # Value
  Get  â‡ !âˆ˜"Runtime: Variable referenced before definition"
  SetU â‡ !âˆ˜"â†©: Variable modified before definition"
  SetN â‡ {
    Get â†© {ğ•Š:v}
    (SetU â†© {vâ†©ğ•©}) ğ•©
  }
  SetQ â‡ 0âˆ˜SetN
  GetC â‡ {
    r â† Getğ•©
    Getâ†©SetUâ†©SetNâ†©!âˆ˜"Internal error: Variable used after clear"
    r
  }
  GetF â‡ {program ğ•©.Field name}
}

# Other kinds of references, and reference utilities
ref â† {
  # Constant-matching reference, like ğ•Š2: in a header
  Matcher â‡ {ğ•Š const:
    SetQ â‡ constË™ â‰¢ âŠ¢
  }
  # Array destructuring âŸ¨a,b,câŸ©â†
  Array â‡ {ğ•Š arr:
    Get  â‡ {ğ•©.Get@}Â¨ arrË™
    # Common code for all setter functions
    # ğ•¨Sğ•© sets reference ğ•¨ to ğ•©, and e indicates error handling
    _set_ â† {S _ğ•£_ e:
      Err â† {(eâˆ¾": "âˆ¾ğ•©)!eâ‰¡@ â‹„ âŸ¨1âŸ©} # eâ‰¡@ indicates SetQ, which can't error
      c â† (eâ‰¡@) âŠ‘ {ğ”½}â€¿{ğ”½âŠ1}        # GetF or Get in F can error
      # Get field for reference ğ•¨ from namespace, if possible
      F â† {âŸ¨Gâ‡GetFâŸ©ğ•Šğ•©:(Gğ•©).Get@ ; !Err"Cannot extract non-name from namespace"}
      {
        0=â€¢Typeğ•© ? arr â‰¡â—‹â‰¢â—¶âŸ¨Errâˆ˜"Target and value shapes don't match", SÂ¨âŸ© ğ•© ;
        6=â€¢Typeğ•© ? (âŠ¢ S FâŸœğ•©)_cÂ¨ arr ;
        Err "Multiple targets but atomic value"
      }
    }
    SetN â‡    {ğ•¨.SetNğ•©}_set_"â†"
    SetU â‡    {ğ•¨.SetUğ•©}_set_"â†©"
    SetQ â‡ âˆ¨Â´ {ğ•¨.SetQğ•©}_set_@
  }
  # Alias, like â‡vals in âŸ¨aâ€¿bâ‡valsâŸ©â†
  # It behaves like âŸ¨aâ€¿bâŸ©â† except when destructuring a namespace (GetF)
  Alias â‡ {envâ€¿name ğ•Š r:
    SetNâ€¿SetUâ€¿SetQ â‡ r
    GetF â‡ {env.program ğ•©.Field name}
  }
  # Destructuring placeholder Â·
  not â‡ { SetUâ‡SetNâ‡âŠ¢ â‹„ SetQâ‡0Ë™ }
}

# Create an environment: essentially, a list of variable slots and a
# reference to the parent environment.
MakeEnv â† { ğ•ŠâŸ¨
    p  # Parent environment
    v  # Total number of slots (special names plus named variables)
    n  # ID numbers of named variables
    e  # Which named variables are exported
  âŸ©:
  ns â† v-â‰ n  # Number of special names
  parent â‡ p
  program â‡ p.program  # Determines the meaning of ID numbers
  vars â‡ programâŠ¸MakeVarÂ¨ (nsâ¥ŠÂ¯1) âˆ¾ n  # Variables
  # Return a namespace for this environment.
  # A namespace is represented as a namespace with one field, Field.
  # ğ•¨ ns.Field ğ•© returns the value of the field with ID ğ•© in program ğ•¨.
  MakeNS â‡ {ğ•¤
    v â† @ âŠ£Â´Â¨ n âŠ”â—‹(eâŠ¸/) nsâ†“vars  # Lookup table
    Field â‡ {ğ•¨ğ•Ši:
      cross â† ğ•¨ { ğ•¨1âŠ˜â‰¡ğ•© ? âŠ¢ ; âŠ‘ ğ•©.names âŠ âŠâŸœğ•¨.names } program
      (Cross i) âŠ‘ v
    }
  }
}

# Return a function that reads the variable from slot s at depth d.
# The input is taken from the bytecode stream.
VO â† { dâ†ğ•@, sâ†ğ•@, sâŠ‘Â·{ğ•©.vars}{ğ•©.parent}âŸd }

# Namespace from environment
Namespace â† {ğ•©.MakeNS@}
# Read field ğ•¨ from program ğ•©, where ğ•¨ is the environment and index
GetField â† { eâ€¿i ğ•Š ğ•©:
  "Key lookup in non-namespace" ! 6=â€¢Typeğ•©
  (e.program ğ•©.Field i).Get @
}

# Constants
nothing  â† {â‡}  # Used when ğ•¨ is Â·
skipMark â† {â‡}  # Indicates body aborted instead of returning

# Execution stack: every body evaluation makes one of these
MakeStack â† {
  s â† ğ•©                          # Stack (a list)
  cont â‡ 1                       # Whether to continue execution
  rslt â‡ skipMark                # Result: skipMark to abort current body
  Push â‡ {sâˆ¾â†©<ğ•©}                 # Push a value
  Pop  â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s} # Pop ğ•© values; return as list
  Peek â‡ {ğ•Š:Â¯1âŠ‘s}                # Return but don't pop top value
  Ret  â‡ {rsltâ†©ğ•© â‹„ contâ†©0 â‹„ "Internal compiler error: Wrong stack size"!ğ•¨â‰¥â‰ s}
  Skip â‡ {ğ•Š:       contâ†©0}       # Exit with no return value
}

# All the opcodes
# Each one is a function that takes the next-opcode function so it can
# read values from the bytecode stream. It returns a function to be
# called on the stack s and environment e at evaluation time.
ops â† ((!âˆ˜"Unknown opcode")Ë™âŠ£Â´âŠ¢)Â¨ âŠ”Ë â‰> âŸ¨
  # Constants and drop
   0â€¿{iâ†ğ•@ â‹„ {sğ•Še: s.Push         iâŠ‘e.program.consts } }
   1â€¿{iâ†ğ•@ â‹„ {sğ•Še: s.Push e {ğ•ğ•©}Ëœ iâŠ‘e.program.blocks } }
   6â€¿(       {sğ•Še: s.Pop 1 }Ë™)
  # Returns
   7â€¿(       {sğ•Še: 0 s.Ret âŠ‘s.Pop 1 }Ë™)
   8â€¿(       {sğ•Še: 1 s.Ret Namespace e }Ë™)
  # Arrays
  11â€¿{iâ†ğ•@ â‹„ {sğ•Še: s.Push           âŒ½s.Pop i } }
  12â€¿{iâ†ğ•@ â‹„ {sğ•Še: s.Push ref.Array âŒ½s.Pop i } }
  # Application
  16â€¿(       {sğ•Še: s.Push {   fâ€¿x:   F x }   s.Pop 2 }Ë™)
  17â€¿(       {sğ•Še: s.Push { wâ€¿fâ€¿x: w F x }   s.Pop 3 }Ë™)
  20â€¿(       {sğ•Še: s.Push {   gâ€¿h:   G H }   s.Pop 2 }Ë™)
  21â€¿(       {sğ•Še: s.Push { fâ€¿gâ€¿h: F G H }   s.Pop 3 }Ë™)
  26â€¿(       {sğ•Še: s.Push { fâ€¿m  : F _m    } s.Pop 2 }Ë™)
  27â€¿(       {sğ•Še: s.Push { fâ€¿mâ€¿g: F _m_ g } s.Pop 3 }Ë™)
  # Application with Nothing
  18â€¿(       {sğ•Še: s.Push {   fâ€¿x:                     FâŸ(nothingâŠ¸â‰¢) x } s.Pop 2 }Ë™) # Like 16
  19â€¿(       {sğ•Še: s.Push { wâ€¿fâ€¿x: (nothingâ‰¢wË™)â—¶âŸ¨F,wË™âŠ¸FâŸ©âŸ(nothingâŠ¸â‰¢) x } s.Pop 3 }Ë™) # Like 17
  23â€¿(       {sğ•Še: s.Push { fâ€¿gâ€¿h: {fâ‰¡nothing?G H;F G H}               } s.Pop 3 }Ë™) # Like 21
  22â€¿(       {sğ•Še: "Left argument required" ! nothingâ‰¢s.Peek@ }Ë™)
  # Variables
  32â€¿{vâ†VOğ•©â‹„ {sğ•Še: s.Push (V e).Get @ } }
  34â€¿{vâ†VOğ•©â‹„ {sğ•Še: s.Push (V e).GetC@ } }
  33â€¿{vâ†VOğ•©â‹„ {sğ•Še: s.Push  V e        } }
  # Headers
  42â€¿(       {sğ•Še: {0:s.Skip@; 1:@; ğ•Š:!"Predicate value must be 0 or 1"} âŠ‘s.Pop 1 }Ë™)
  43â€¿(       {sğ•Še: s.Push ref.Matcher âŠ‘s.Pop 1 }Ë™)
  44â€¿(       {sğ•Še: s.Push ref.not }Ë™)
  # Assignment
  47â€¿(       {sğ•Še: s.SkipâŸâŠ¢{râ€¿  v: r.SetQ   v           } s.Pop 2 }Ë™)  # r:
  48â€¿(       {sğ•Še: s.Push { râ€¿  v: r.SetNâŠ¸âŠ¢ v           } s.Pop 2 }Ë™)  # r  â†v
  49â€¿(       {sğ•Še: s.Push { râ€¿  v: r.SetUâŠ¸âŠ¢ v           } s.Pop 2 }Ë™)  # r  â†©v
  50â€¿(       {sğ•Še: s.Push { râ€¿fâ€¿x: r.SetUâŠ¸âŠ¢ (r.Get@)F x } s.Pop 3 }Ë™)  # r Fâ†©x
  51â€¿(       {sğ•Še: s.Push { râ€¿f  : r.SetUâŠ¸âŠ¢ F r.Get@    } s.Pop 2 }Ë™)  # r Fâ†©
  # Namespaces
  64â€¿{iâ†ğ•@ â‹„ {sğ•Še: s.Push eâ€¿i GetField  âŠ‘s.Pop 1 } }
  66â€¿{iâ†ğ•@ â‹„ {sğ•Še: s.Push eâ€¿i ref.Alias âŠ‘s.Pop 1 } }
âŸ©

# Evaluate a body
RunBC â† { bcâ€¿posâ€¿env:  # bytecode, starting position, environment
  Next â† {ğ•Š: (pos+â†©1) âŠ¢ posâŠ‘bc }
  stack â† MakeStack âŸ¨âŸ©
  Step â† {ğ•Š:
    op â† (Next@) âŠ‘ ops
    op â†© Op next
    stack Op env
    stack.cont  # Changes to 0 on return or abort
  }
  _while_ â† {ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}
  Step _while_ âŠ¢ 1
  stack.rslt
}

# Evaluate a program, given the compiler output
{ VM bcâ€¿constsâ€¿blockInfoâ€¿bodyInfoâ€¿locâ€¿token:

  bodies â† {startâ€¿varsâ€¿namesâ€¿export:
    # Called when the body is evaluated
    {parent ğ•Š args:
      env â† MakeEnv parentâ€¿varsâ€¿namesâ€¿export
      (âŠ¢ {ğ•©.SetN ğ•¨}Â¨ â‰ â†‘env.varsË™) args  # Initialize arguments
      RunBC bcâ€¿startâ€¿env
    }
  }Â¨ bodyInfo

  blocks â† {typeâ€¿immâ€¿body:
    # Handle operands
    inner â† imm âŠ‘ type âŠ‘ âŸ¨
      2â¥ŠâŸ¨{ğ•Šn: N âŸ¨âŸ©}âŸ©
      {ğ•Šn: {dâ†N ğ•£â€¿ğ•—  â‹„ğ•¨Dğ•©}}â€¿{ğ•Šn: {N ğ•£â€¿ğ•—  }}
      {ğ•Šn: {dâ†N ğ•£â€¿ğ•—â€¿ğ•˜â‹„ğ•¨Dğ•©}}â€¿{ğ•Šn: {N ğ•£â€¿ğ•—â€¿ğ•˜}}
    âŸ©
    # Handle arguments
    outer â† imm âŠ‘ âŸ¨
      {
        mâ€¿d: {ğ•Šv: {M ğ•¤â€¿ğ•©â€¿nothingâˆ¾v;D ğ•¤â€¿ğ•©â€¿ğ•¨âˆ¾v}} ;
        âŸ¨bâŸ©: {ğ•Šv: {B ğ•¤â€¿ğ•©â€¿(ğ•¨âŠ£nothing)âˆ¾v}}
      }
      âŠ‘
    âŸ©

    # Assemble bodies
    nmc â† "No matching case"
    Then â† {first ğ•Š next: {skipMarkâ‰¢râ†ğ•¨Firstğ•© ? r ; ğ•¨Nextğ•©}}
    run â† {
      1=â€¢Type ğ•© ?
      âŸ¨(ğ•©âŠ‘bodies) Then {!âˆ˜nmc}âŸ©
    ;
      "Internal compiler error: Invalid body indices" ! 1==ğ•©
      ! (â‰ ğ•©) â‰¡ 2-imm
      e â† {imm ? âŸ¨nmcâŸ© ;
        (0=â‰ Â¨ğ•©) nmcâŸâŠ£Â¨ "Left argument "âŠ¸âˆ¾Â¨âŸ¨"not allowed","required"âŸ©
      }ğ•©
      ğ•© ThenÂ´âŸœ(âŠâŸœbodies)ËœâŸœ{!âˆ˜ğ•©}Â¨ e
    } body

    {ğ•Š parent:
      Inner Outer {parentË™ ğ• âŠ¢}Â¨ run
    }
  }Â¨ blockInfo

  program â† {
    constsâ‡consts
    blocksâ‡blocks
    namesâ‡0âŠ‘2âŠ‘token
  }
  
  (âŠ‘blocks){ğ”½} {programâ‡program}
}
