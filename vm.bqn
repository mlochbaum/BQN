MakeVar â† { program ğ•Š name:
  vâ†@
  Get  â‡ !âˆ˜"Runtime: Variable referenced before definition"
  SetU â‡ !âˆ˜"â†©: Variable modified before definition"
  SetN â‡ {
    Get â†© {ğ•¤â‹„v}
    (SetU â†© {vâ†©ğ•©}) ğ•©
  }
  SetQ â‡ 0âˆ˜SetN
  GetC â‡ {
    r â† Getğ•©
    Getâ†©SetUâ†©SetNâ†©!âˆ˜"Internal error: Variable used after clear"
    r
  }
  GetF â‡ {program ğ•©.Field name}
}
vnot â† { SetUâ‡SetNâ‡âŠ¢ â‹„ SetQâ‡0Ë™ }
MakeEnv â† { ğ•Špâ€¿vâ€¿nâ€¿e:
  ns â† v-â‰ n  # Number of special names
  parent â‡ p
  program â‡ p.program
  vars â‡ programâŠ¸MakeVarÂ¨ (nsâ¥ŠÂ¯1) âˆ¾ n
  MakeNS â‡ {ğ•¤
    v â† @ âŠ£Â´Â¨ n âŠ” nsâ†“vars  # Lookup table
    Field â‡ {ğ•¨ğ•Ši:
      cross â† ğ•¨ { ğ•¨1âŠ˜â‰¡ğ•© ? âŠ¢ ; âŠ‘ ğ•©.names âŠ âŠâŸœğ•¨.names } program
      (Cross i) âŠ‘ v
    }
  }
}

VO â† { dâ†ğ•@, sâ†ğ•@, sâŠ‘Â·{ğ•©.vars}{ğ•©.parent}âŸd }

nothing  â† {â‡}
skipMark â† {â‡}

Namespace â† {ğ•©.MakeNS@}
ReadNS â† { eâ€¿i ğ•Š ğ•©:
  "Key lookup in non-namespace" ! 6=â€¢Typeğ•©
  (e.program ğ•©.Field i).Get @
}

ref â† {
  Matcher â‡ {ğ•Š const:
    SetQ â‡ constË™ â‰¢ âŠ¢
  }
  Array â‡ {ğ•Š arr:
    Get  â‡ {ğ•©.Get@}Â¨ arrË™
    _set_ â† {S _ğ•£_ e:
      Err â† {(eâˆ¾": "âˆ¾ğ•©)!eâ‰¡@ â‹„ âŸ¨1âŸ©}
      {
        0=â€¢Typeğ•© ? arr â‰¡â—‹â‰¢â—¶âŸ¨Errâˆ˜"Target and value shapes don't match", SÂ¨âŸ© ğ•© ;
        # TODO "Cannot extract non-name from namespace" if ğ•¨.GetF doesn't exist
        6=â€¢Typeğ•© ? SâŸœ({(ğ•¨.GetF ğ•©).Get@}âŸœğ•©)Â¨ arr ;
        Err "Multiple targets but atomic value"
      }
    }
    SetN â‡    {ğ•¨.SetNğ•©}_set_"â†"
    SetU â‡    {ğ•¨.SetUğ•©}_set_"â†"
    SetQ â‡ âˆ¨Â´ {ğ•¨.SetQğ•©}_set_@âŠâŸ¨1âŸ© # TODO fix GetF errors and avoid âŠ
  }
  Alias â‡ {envâ€¿name ğ•Š r:
    SetNâ€¿SetUâ€¿SetQ â‡ r
    GetF â‡ {env.program ğ•©.Field name}
  }
}

Get â† {ğ•©.Get @}âš‡0

MakeStack â† {
  s â† ğ•©                          # Stack (a list)
  cont â‡ 1                       # Whether to continue execution
  rslt â‡ skipMark                # Result: skipMark to abort current body
  Push â‡ {sâˆ¾â†©<ğ•©}                 # Push a value
  Pop  â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s} # Pop ğ•© values; return as list
  Peek â‡ {ğ•¤â‹„Â¯1âŠ‘s}                # Return but don't pop top value
  Ret  â‡ {rsltâ†©ğ•© â‹„ contâ†©0 â‹„ "Internal compiler error: Wrong stack size"!ğ•¨â‰¥â‰ s}
  Skip â‡ {ğ•¤â‹„       contâ†©0}
}

ops â† ((!âˆ˜"Unknown opcode")Ë™âŠ£Â´âŠ¢)Â¨ âŠ”Ë â‰> âŸ¨
  # Constants and drop
   0â€¿{iâ†ğ•@ â‹„ {sğ•Še: s.Push         iâŠ‘e.program.consts } }
   1â€¿{iâ†ğ•@ â‹„ {sğ•Še: s.Push e {ğ•ğ•©}Ëœ iâŠ‘e.program.blocks } }
   6â€¿(       {sğ•Še: s.Pop 1 }Ë™)
  # Returns
   7â€¿(       {sğ•Še: 0 s.Ret âŠ‘s.Pop 1 }Ë™)
   8â€¿(       {sğ•Še: 1 s.Ret Namespace e }Ë™)
  # Arrays
  11â€¿{iâ†ğ•@ â‹„ {sğ•Še: s.Push           âŒ½s.Pop i } }
  12â€¿{iâ†ğ•@ â‹„ {sğ•Še: s.Push ref.Array âŒ½s.Pop i } }
  # Application
  16â€¿(       {sğ•Še: s.Push {   fâ€¿x:   F x }   s.Pop 2 }Ë™)
  17â€¿(       {sğ•Še: s.Push { wâ€¿fâ€¿x: w F x }   s.Pop 3 }Ë™)
  20â€¿(       {sğ•Še: s.Push {   gâ€¿h:   G H }   s.Pop 2 }Ë™)
  21â€¿(       {sğ•Še: s.Push { fâ€¿gâ€¿h: F G H }   s.Pop 3 }Ë™)
  26â€¿(       {sğ•Še: s.Push { fâ€¿m  : F _m    } s.Pop 2 }Ë™)
  27â€¿(       {sğ•Še: s.Push { fâ€¿mâ€¿g: F _m_ g } s.Pop 3 }Ë™)
  # Application with Nothing
  18â€¿(       {sğ•Še: s.Push {   fâ€¿x:                     FâŸ(nothingâŠ¸â‰¢) x } s.Pop 2 }Ë™) # Like 16
  19â€¿(       {sğ•Še: s.Push { wâ€¿fâ€¿x: (nothingâ‰¢wË™)â—¶âŸ¨F,wË™âŠ¸FâŸ©âŸ(nothingâŠ¸â‰¢) x } s.Pop 3 }Ë™) # Like 17
  23â€¿(       {sğ•Še: s.Push { fâ€¿gâ€¿h: {fâ‰¡nothing?G H;F G H}               } s.Pop 3 }Ë™) # Like 21
  22â€¿(       {sğ•Še: "Left argument required" ! nothingâ‰¢s.Peek@ }Ë™)
  # Variables
  32â€¿{vâ†VOğ•©â‹„ {sğ•Še: s.Push (V e).Get @ } }
  34â€¿{vâ†VOğ•©â‹„ {sğ•Še: s.Push (V e).GetC@ } }
  33â€¿{vâ†VOğ•©â‹„ {sğ•Še: s.Push  V e        } }
  # Headers
  42â€¿(       {sğ•Še: {0:s.Skip@; 1:@; ğ•Š:!"Predicate value must be 0 or 1"} âŠ‘s.Pop 1 }Ë™)
  43â€¿(       {sğ•Še: s.Push ref.Matcher âŠ‘s.Pop 1 }Ë™)
  44â€¿(       {sğ•Še: s.Push vnot }Ë™)
  # Assignment
  47â€¿(       {sğ•Še: s.SkipâŸâŠ¢{râ€¿  v: r.SetQ   v           } s.Pop 2 }Ë™)  # r:
  48â€¿(       {sğ•Še: s.Push { râ€¿  v: r.SetNâŠ¸âŠ¢ v           } s.Pop 2 }Ë™)  # r  â†v
  49â€¿(       {sğ•Še: s.Push { râ€¿  v: r.SetUâŠ¸âŠ¢ v           } s.Pop 2 }Ë™)  # r  â†©v
  50â€¿(       {sğ•Še: s.Push { râ€¿fâ€¿x: r.SetUâŠ¸âŠ¢ (r.Get@)F x } s.Pop 3 }Ë™)  # r Fâ†©x
  51â€¿(       {sğ•Še: s.Push { râ€¿f  : r.SetUâŠ¸âŠ¢ F r.Get@    } s.Pop 2 }Ë™)  # r Fâ†©
  # Namespaces
  64â€¿{iâ†ğ•@ â‹„ {sğ•Še: s.Push eâ€¿i ReadNS    âŠ‘s.Pop 1 } }
  66â€¿{iâ†ğ•@ â‹„ {sğ•Še: s.Push eâ€¿i ref.Alias âŠ‘s.Pop 1 } }
âŸ©

RunBC â† { bcâ€¿posâ€¿env:
  Next â† {ğ•¤â‹„ (pos+â†©1) âŠ¢ posâŠ‘bc }
  stack â† MakeStack âŸ¨âŸ©
  Step â† {ğ•Š:
    op â† (Next@) âŠ‘ ops
    op â†© Op next
    stack Op env
    stack.cont
  }
  _while_ â† {ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}
  Step _while_ âŠ¢ 1
  stack.rslt
}

{ VM bcâ€¿constsâ€¿blockInfoâ€¿bodyInfoâ€¿locâ€¿token:

  bodies â† {startâ€¿varsâ€¿namesâ€¿export:
    {parent ğ•Š args:
      env â† MakeEnv parentâ€¿varsâ€¿namesâ€¿export
      (âŠ¢ {ğ•©.SetN ğ•¨}Â¨ â‰ â†‘env.varsË™) args
      RunBC bcâ€¿startâ€¿env
    }
  }Â¨ bodyInfo

  blocks â† {typeâ€¿immâ€¿body:
    inner â† imm âŠ‘ type âŠ‘ âŸ¨
      2â¥ŠâŸ¨{ğ•Šn: N âŸ¨âŸ©}âŸ©
      {ğ•Šn: {dâ†N ğ•£â€¿ğ•—  â‹„ğ•¨Dğ•©}}â€¿{ğ•Šn: {N ğ•£â€¿ğ•—  }}
      {ğ•Šn: {dâ†N ğ•£â€¿ğ•—â€¿ğ•˜â‹„ğ•¨Dğ•©}}â€¿{ğ•Šn: {N ğ•£â€¿ğ•—â€¿ğ•˜}}
    âŸ©
    outer â† imm âŠ‘ âŸ¨
      {
        mâ€¿d: {ğ•Šv: {M ğ•¤â€¿ğ•©â€¿nothingâˆ¾v;D ğ•¤â€¿ğ•©â€¿ğ•¨âˆ¾v}} ;
        âŸ¨bâŸ©: {ğ•Šv: {B ğ•¤â€¿ğ•©â€¿(ğ•¨âŠ£nothing)âˆ¾v}}
      }
      âŠ‘
    âŸ©

    nmc â† "No matching case"
    Then â† {first ğ•Š next: {skipMarkâ‰¢râ†ğ•¨Firstğ•© ? r ; ğ•¨Nextğ•©}}
    run â† {
      1=â€¢Type ğ•© ?
      âŸ¨(ğ•©âŠ‘bodies) Then {!âˆ˜nmc}âŸ©
    ;
      "Internal compiler error: Invalid body indices" ! 1==ğ•©
      ! (â‰ ğ•©) â‰¡ 2-imm
      e â† {imm ? âŸ¨nmcâŸ© ;
        (0=â‰ Â¨ğ•©) nmcâŸâŠ£Â¨ "Left argument "âŠ¸âˆ¾Â¨âŸ¨"not allowed","required"âŸ©
      }ğ•©
      ğ•© ThenÂ´âŸœ(âŠâŸœbodies)ËœâŸœ{!âˆ˜ğ•©}Â¨ e
    } body

    {ğ•Š parent:
      Inner Outer {parentË™ ğ• âŠ¢}Â¨ run
    }
  }Â¨ blockInfo

  program â† {
    constsâ‡consts
    blocksâ‡blocks
    namesâ‡0âŠ‘2âŠ‘token
  }
  
  (âŠ‘blocks){ğ”½} {programâ‡program}
}
