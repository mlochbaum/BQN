# The Markdown function is a markdown to html converter for a "good
# enough" subset of Github-flavored markdown, as specified at
# https://github.github.com/gfm/ .
#
# Additionally, it highlights code sections as BQN, and executes
# sections that are doubly indented (eight spaces), placing their
# results below them.

# Not supported:
# - Thematic breaks like *** or ---
# - Setext headings (underlined with ==== or ----)
# - Fenced code blocks (marked off with ``` or ~~~)
# - HTML blocks
# - Link reference definitions (who uses these?)
# - Block quotes (start with >)
# - Task lists

# Here, a markdown file is represented as a list of its lines, which are
# strings (they don't include any line ending character).
# The html file is constructed directly as a string, using Html.

################################
# Utilities

# ğ•¨ is a list of lists. Find the first of these lists each cell of ğ•©
# belongs to.
FindGroup â† {
  i â† (âˆ¾ğ•¨) âŠ ğ•©  # Index in all cells of ğ•¨
  e â† +`â‰ Â¨ğ•¨     # Index past the end of each group of ğ•¨
  e â‹ i         # How many end-indices does each element pass?
}

# Join lines with newline characters. Include the trailing newline.
JoinLines â† âˆ¾ âˆ¾âŸœlfÂ¨

# Create an html node from a tag name and interior text
Html â† {
  ğ•¨ âˆ¾â†© ">"
  âˆ¾ âŸ¨"<",ğ•¨ , ğ•© , "</",ğ•¨âŸ©
}

################################
Markdown â† {
  ######
  # Utilities

  # Index of first zero, or number of leading 1s
  Lead â† âŠ‘ âŠâŸœ0

  # Shift cells ğ•¨ into array ğ•©, maintaining its total length
  Shl â†   â‰ âˆ˜âŠ¢ â†‘ âˆ¾   # From the left
  Shr â† -âˆ˜â‰ âˆ˜âŠ¢ â†‘ âˆ¾Ëœ  # From the right

  # Find whether ğ•¨ was true at the last index where ğ•© was true, in each
  # position.
  PrecedesGroup â† {
    # We prepend a 0 to ğ•¨, so that 0 is the "before start" index, with a
    # false value, and normal indices are increased by 1.
    ğ•¨ âˆ¾Ëœâ†© 0
    inds â† 1 + â†•â‰ ğ•©
    # Zero out indices where x was false, and find the greatest index so
    # far at each position.
    last â† âŒˆ` inds Ã— Â¬ğ•©
    last âŠ ğ•¨
  }

  ######
  # First we classify each line based on the type of block it can start.
  ClassifyLine â† (0<â‰ )â—¶(0â€¿0)â€¿{
    ind â† âŠ‘ lineChars FindGroup âŠğ•©
    getLen â† ind âŠ‘ lineClasâˆ¾âŸ¨0ËœâŸ©
    l â† GetLen ğ•©
    âŸ¨ind âˆ§ l>0 â‹„ lâŸ©
  }

  # Non-empty lines in code blocks have 4 leading spaces
  IsCode â† 4 (â‰¤âŸœâ‰ )â—¶âŸ¨0,âˆ§Â´' '=â†‘âŸ© âŠ¢
  ProcCode â† {
    lines â† JoinLines 4 â†“Â¨ ğ•©
    Esc â† (âˆ¾â¥ŠÂ¨) ("<>"âŠ¸âŠ âŠ‘âŸœâŸ¨"&lt;","&gt;"âŸ©âŸ(2>âŠ£)Â¨ âŠ¢)
    "pre" Html doHighlightâ—¶âŸ¨"code"Html Esc,HighlightâŸ© lines
  }

  # Headings start with #, and require 1-6 #s followed by a space.
  # Any trailing #s are ignored.
  LenHeading â† {
    n â† Lead ğ•©='#'
    l â† (0<n) âˆ§ (6â‰¥n)
    s â† n (<âŸœâ‰ )â—¶âŸ¨1,' '=âŠ‘âŸ© ğ•© # Character after hashes must be a space, if any
    n Ã— l âˆ§ s
  }
  ProcHeading â† {
    tag â† "h" âˆ¾ ğ•¨âŠâ€¢d        # h3 for 3 hashes, etc.
    ğ•© â†“Ëœâ†© ğ•¨+1
    trsp â† âˆ§`âŒ¾âŒ½ ğ•©=' '
    tail â† âˆ§`âŒ¾âŒ½ trspâˆ¨ğ•©='#'  # Mask of trailing hashes
    f â† tail < 0 Shr tail   # Character before trailing hashes
    ğ•© /Ëœâ†© Â¬ f (âŠ‘âŸ¨"\"," ",""âŸ©âŠ<f/ğ•©)â—¶âŸ¨âŠ£,âŠ¢,âŠ¢,0Â¨âŠ¢âŸ© tail
    ğ•© /Ëœâ†© Â¬ (âˆ§` âˆ¨ âˆ§`âŒ¾âŒ½) ' '=ğ•©
    tag Html ProcInline ğ•©
  }âŸœâŠ‘

  # List items start with a bullet (unordered) or number (ordered).
  LenBullet â† 2 Ã— 1 (<âŸœâ‰ )â—¶âŸ¨0,' '=âŠ‘âŸ© âŠ¢
  LenListNum â† {
    n â† Lead ğ•©âˆŠâ€¢d
    l â† (1â‰¤n) âˆ§ (9â‰¥n)
    ' ' = n â†“ ğ•©
    t â† nâ†“(n+2)â†‘ğ•©
    l âˆ§ (" " â‰¡ 1â†“t) âˆ§ âŠ‘(")." âˆŠËœ 1â†‘t)
  }

  # Tables are not yet supported
  IsTable â† 0Ëœ

  # Paragraphs
  ProcParagraph â† {
    Trsp â† { mâ†âˆ§`âŒ¾âŒ½ğ•©=' ' â‹„ (mÂ¬âŠ¸/ğ•©)âˆ¾(ğ•¨<âˆ¨Â´m)/"<br />" }
    ğ•© â†© (/(â‰ ğ•©)(-âˆ¾âŠ¢)1) TrspÂ¨ ğ•©
    "p" Html ProcInline Â¯1 â†“ JoinLines ((Lead ' 'âŠ¸=)+"\#"â‰¡2âŠ¸â†‘)âŠ¸â†“Â¨ ğ•©
  }

  lineCharsâ€¿lineClasâ€¿procFns â† <Ë˜â‰>âŸ¨
    ""    â€¿ (!âˆ˜0)       â€¿ ProcParagraph
    "#"   â€¿ LenHeading  â€¿ ProcHeading
    " "   â€¿ IsCode      â€¿ ProcCode
  # "-+*" â€¿ LenBullet   â€¿ ProcBullet
  # â€¢d    â€¿ LenListNum  â€¿ ProcListNum
  # "|"   â€¿ IsTable     â€¿ ProcTable
  âŸ©

  ######
  # Inline elements
  ProcInline â† {
    puncChars â† "!""#$%&'()*+,-./:;<=>?@[\]^_`{|}~"
    # Characters that start or end inline elements
    # (we don't do fancy processing for these yet)
    delimiters â† "`*_"
    # The corresponding tags
    dTags â† {("<"âˆ¾âŠ¢âˆ¾ğ•©âˆ¾">"Ëœ)Â¨""â€¿"/"}Â¨ 1â€¿2/"code"â€¿"em"

    ProcCodeSpan â† {
      ğ•© â†© ' 'Â¨âŒ¾((ğ•©=lf)âŠ¸/) ğ•©
      ğ•© â†© (1â†“Â¯1â†“âŠ¢)âŸ((âŠ¢<â—‹(âˆ§Â´)âŠ‘âˆ¾âŠ‘âˆ˜âŒ½) ' 'âŠ¸=) ğ•©
      HighlightâŸdoHighlight ğ•©
    }

    dMasks â† ğ•©âŠ¸=Â¨ delimiters
    dInds â† (âŠ¢-2|âŠ¢)âˆ˜â‰ âŠ¸â†‘âˆ˜/Â¨ dMasks
    câ†âŠ‘dMasksâ‹„râ†Â¯1âŒ½lâ†â‰ `câ‹„csâ†lâˆ§c
    codeâ†ProcCodeSpanÂ¨(1-Ëœ(lâˆ§r)Ã—+`cs)âŠ”ğ•©
    incâ†Â¬lâˆ¨âˆ¨Â´dMasks
    tags â† âˆ¾ dInds â‰ âŠ¸â¥ŠÂ¨ dTags
    ((/inc)âˆ¾(â‰ Â¨tagsâˆ¾code)/(âˆ¾dInds)âˆ¾/cs) â‹âŠ¸âŠ (inc/ğ•©)âˆ¾âˆ¾tagsâˆ¾code
  }

  ######
  # Create the block structure using line classifications.
  lengths â† â‰ Â¨ ğ•©                   # Length of each line
  blanks â† (Lead ' 'âŠ¸=)Â¨ ğ•©         # Number of leading blanks
  nonEmptyMask â† blanks < lengths  # Empty â†â†’ all leading blanks

  # Get line classifications: type of line, and data to be passed into
  # the line processor. Note that leading blanks aren't passed in.
  lineTypeâ€¿lineDat â† <Ë˜â‰ > ClassifyLineÂ¨ blanks â†“Â¨ ğ•©
  # Empty lines have type Â¯1.
  lineType â†© Â¯1Â¨âŒ¾((Â¬nonEmptyMask)âŠ¸/) lineType

  # Lines that could be included in code blocks (will be refined)
  codeMask â† nonEmptyMask âˆ§ blanks â‰¥ 4
  paragraphMask â† 0 = lineType
  # A header can't have 4 spaces of indentation. If it doesn't become
  # part of a code block, it will be included in a paragraph.
  lineType -â†© codeMask âˆ§ 1 = lineType

  # Code blocks consist of indented lines, possibly with blank lines
  # in between. They must be separated from paragraphs by blank lines.
  codeMask âˆ§â†© Â¬ paragraphMask PrecedesGroup codeMask
  codeMask âˆ¨â†© codeMask (âŠ¢ âˆ§ PrecedesGroup âˆ§ PrecedesGroupâŒ¾âŒ½) lineType < 0
  lineType â†© 2Â¨âŒ¾(codeMaskâŠ¸/) lineType

  # Lines continue blocks if they are part of the same multi-line
  # type as the previous line, and otherwise start new ones.
  # Headers (type 1) always start new blocks.
  blockStart â† nonEmptyMask âˆ§ (1 = lineType) âˆ¨ Â¯1âŠ¸ShlâŠ¸â‰  lineType
  # Headers and paragraphs ignore leading blanks.
  drop â† blanks Ã— lineType < 2
  # Group blocks based on blockStart, with type Â¯1 lines excluded.
  blocks â† (1 -Ëœ (lineType â‰¥ 0) Ã— +`blockStart) âŠ” drop â†“Â¨ ğ•©

  # To process a block, pick the appropriate function from procFns.
  ProcBlock â† {tâ€¿l G b: fâ†tâŠ‘procFns â‹„ l F âŠ‘b }
  JoinLines (blockStart / lineTypeâ‰Ë˜lineDat) <âˆ˜ProcBlockË˜ blocks
}

################################
# Testing
# Uses the test cases at https://spec.commonmark.org/0.29/spec.json
# since Github doesn't seem to have published theirs
TestSections â† {
  doHighlight â†© 0
  tests â† Â¯2 â†“Ë˜ 8âŠ¸(Ã·ËœâŸœâ‰ âˆ¾âŠ£)âŠ¸â¥Š2â†“â€¢LNS â€¢pathâˆ¾"../spec.json"
  tests â†© ((âŠ‘2+âŠâŸœ':')Â¨âˆ˜âŠ ((-','=Â¯1âŠ‘âŠ¢)â†“â†“)Â¨â‰1 âŠ¢) tests
  testSection â† (1â†“Â¯1â†“âŠ¢)Â¨ 5âŠË˜tests
  UnEsc â† {
    esc â† (2 | (1+â†•âˆ˜â‰ ) (âŠ£-âŒˆ`âˆ˜Ã—) '\'â‰ âŠ¢) ğ•©
    esc Â¬âŠ¸/ (("\"""âˆ¾â€¢UCS 9â€¿10)âŠËœ"\""tn"âŠâŠ¢)âŒ¾((Â¯1âŒ½esc)âŠ¸/) ğ•©
  }
  RunTest â† {
    inâ€¿exp â† UnEscâˆ˜(1â†“Â¯1â†“âŠ¢)Â¨2â†‘ğ•©
    out â† Markdown (â€¢UCS 10) ((âŠ¢-ËœÂ¬Ã—+`)âˆ˜=âŠ”âŠ¢) in
    âŸ¨expâ‰¡out,in,exp,out,2âŠ‘ğ•©âŸ©
  }

  ignore â† (2 âŠË˜ tests) âˆŠ âŸ¨"47","85"âŸ©
  res â† 1 â†“Ë˜ (Â¬âŠË˜)âŠ¸/ RunTestË˜ tests /Ëœ ignore < testSection âˆŠ ğ•©
  doHighlight â†© 1
  res
}

################################
# Syntax highlighting
doHighlight â† 1
Highlight â† {
  idChars â† âŸ¨
    â€¢dâˆ¾"Â¯.Ï€âˆ"
    ' '+âŒ¾â€¢UCSâ€¢a
    â€¢a
    "_"
  âŸ©
  classesâ€¿chars â† <Ë˜ â‰ 2âŠ¸(Ã·ËœâŸœâ‰ âˆ¾âŠ£)âŠ¸â¥ŠâŸ¨
    0             , " "âˆ¾â€¢UCS 9â€¿10
    "Value"       , Â¯1âŠË˜5â€¿2â¥Š"ğ•¨ğ•©ğ•—ğ•˜ğ•¤"
    "Function"    , "+-Ã—Ã·â‹†âˆšâŒŠâŒˆ|Â¬âˆ§âˆ¨<>â‰ =â‰¤â‰¥â‰¡â‰¢âŠ£âŠ¢â¥Šâˆ¾â‰â†‘â†“â†•âŒ½â‰/â‹â’âŠâŠ‘âŠâŠ’âˆŠâ·âŠ”!"âˆ¾Â¯1âŠË˜5â€¿2â¥Š"ğ•ğ•ğ”½ğ”¾ğ•Š"
    "Modifier"    , "ËœË˜Â¨âŒœâ¼Â´`"
    "Composition" , "âˆ˜â—‹âŠ¸âŸœâŒ¾âŠ˜â—¶â‰âš‡âŸ"
    "Number"      , âˆ¾idChars
    "Gets"        , "â†â†©â†’"
    "Paren"       , "()"
    "Bracket"     , "âŸ¨âŸ©"
    "Brace"       , "{}"
    "Ligature"    , "â€¿"
    "Nothing"     , "Â·"
    "Separator"   , "â‹„,"
    "Comment"     , "#"
    "String"      , "'"""
  âŸ©
  classTag â† ""â€¿""âˆ¾>{âŸ¨"<span class='"âˆ¾ğ•©âˆ¾"'>","</span>"âŸ©}Â¨1â†“classes

  râ†ğ•©='#'â‹„sâ†/(â‰ â†‘2âŠ¸â†“)âŠ¸âˆ§ğ•©='''â‹„dâ†/ğ•©='"'
  gâ†â‹qâ†âˆ¾âŸ¨  sâ‹„Â¯1â†“dâ‹„/râŸ© â‹„qâ†©gâŠq
  eâ† gâŠâˆ¾âŸ¨2+sâ‹„ 1â†“dâ‹„(âŠ¢-Â¯1â†“0âˆ¾âŠ¢)âˆ˜âŠâŸœ(0âˆ¾+`r)âŠ¸//(ğ•©=lf)âˆ¾1âŸ©
  Seâ†{(âŠËœğ•¨)Se 1Â¨âŒ¾((ğ•©/ğ•¨)âŠ¸âŠ)ğ•©}âŸ{0=âŠ‘âŒ½ğ•©}
  stâ†Â¯1â†“SeâŸœ(1â†‘Ëœâ‰ )âˆ¾âŸœâ‰ qâ‹eâ‹„bâ†st/qâˆ¾Ë˜e
  ToIâ†Â¯1â†“Â·/â¼(â‰ ğ•©)âˆ¾Ëœâ¥Š
  scâ†+Â´(1â€¿2-Ëœâ‰ classes)Ã—(â‰ `âˆ¨âŠ¢)âˆ˜ToIâˆ˜>Â¨Â¯1â†“((st/q)âŠr)âŠ”â—‹(âˆ¾âŸœ2)<Ë˜b
  colâ†scâŒˆ14|chars FindGroup ğ•©

  wâ†(â‰ â†‘0âˆ¾âŠ¢)âŠ¸<idâ†col=5
  idcâ†1+5|1-Ëœ(idChars FindGroup w/ğ•©)+'_'=((1â†“âˆ¾âŸœ0)âŠ¸<id)/ğ•©
  colâ†©((id/+`w)âŠ0âˆ¾idc)âŒ¾(idâŠ¸/)col

  colâ†©(1âŒ½col)âŠ£âŒ¾((ğ•©=âŠ‘"ğ•©")âŠ¸/)col

  bdâ†(â‰ â†‘Â¯1âˆ¾âŠ¢)âŠ¸â‰ col
  fâ†0<bd/col
  tagsâ†â¥Šf/(bd/col)âŠclassTag
  posâ†â¥Šf/2â†•/bdâˆ¾1
  ((â†•â‰ ğ•©)âˆ¾Ëœ(â‰ Â¨tags)/pos) â‹âŠ¸âŠ ğ•©âˆ¾Ëœâˆ¾tags
}

head â† "<head><link href=""style.css"" rel=""stylesheet""/></head>"âˆ¾lf
ConvertFile â† head âˆ¾ Markdownâˆ˜â€¢LNS
