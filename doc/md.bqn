# The Markdown function is a markdown to html converter for a "good
# enough" subset of Github-flavored markdown, as specified at
# https://github.github.com/gfm/ .
#
# Additionally, it highlights code sections as BQN, and executes
# sections that are doubly indented (eight spaces), placing their
# results below them.

# Not supported:
# - Thematic breaks like *** or ---
# - Setext headings (underlined with ==== or ----)
# - Fenced code blocks (marked off with ``` or ~~~)
# - HTML blocks
# - Link reference definitions (who uses these?)
# - Block quotes (start with >)
# - Task lists

# Here, a markdown file is represented as a list of its lines, which are
# strings (they don't include any line ending character).
# The html file is constructed directly as a string, using Html.

################################
# Utilities

# Shift cells ğ•¨ into array ğ•©, maintaining its total length
Shl â†   â‰ âˆ˜âŠ¢ â†‘ âˆ¾   # From the left
Shr â† -âˆ˜â‰ âˆ˜âŠ¢ â†‘ âˆ¾Ëœ  # From the right

# ğ•¨ is a list of lists. Find the first of these lists each cell of ğ•©
# belongs to.
FindGroup â† {
  i â† (âˆ¾ğ•¨) âŠ ğ•©  # Index in all cells of ğ•¨
  e â† +`â‰ Â¨ğ•¨     # Index past the end of each group of ğ•¨
  e â‹ i         # How many end-indices does each element pass?
}

# ğ•¨ is a list of possible expression start indices in any order and ğ•© is
# the corresponding endpoints. The expressions are mutually exclusive
# and do not nest, and are enabled in index order. Return a shape Â·â€¿2
# array where the rows give the start and end of each enabled expression
# in index order.
Trace â† {
  Seâ†{(âŠËœğ•¨)Se 1Â¨âŒ¾((ğ•©/ğ•¨)âŠ¸âŠ)ğ•©}âŸ{0=âŠ‘âŒ½ğ•©}
  gâ†â‹ğ•¨ â‹„ sâ†gâŠğ•¨ â‹„ eâ†gâŠğ•©
  stâ†Â¯1â†“SeâŸœ(1â†‘Ëœâ‰ )âˆ¾âŸœâ‰ sâ‹e
  st/sâ‰Ë˜e
}

# Count the number of consecutive true values up to the current element.
# To do this, subtract the index of the last false character from the
# current index.
CountRuns â† { (1+â†•â‰ ğ•©) (âŠ£ - âŒˆ`âˆ˜Ã—) Â¬ğ•© }

# ğ•© is a string; return a mask of the characters that are escaped, that
# is, preceded by an odd number of backslashes (since a backslash can
# escape another backslash).
IsEscaped â† {
  0 Shl 2 | CountRuns ğ•© = '\'
}

# Join lines with newline characters. Include the trailing newline.
JoinLines â† âˆ¾ âˆ¾âŸœlfÂ¨

# Create an html node from a tag name and interior text
Html â† {
  âˆ¾ âŸ¨"<",ğ•¨,">" , ğ•© , "</",(âŠ‘âŠâŸœ" ")âŠ¸â†‘ğ•¨,">"âŸ©
}

# Character entity escaping
# In order to use this with other modifications such as highlighting,
# CharEntities returns a mask of characters to be escaped, and their
# corresponding escapes.
CharEntities â† {1Â¨âŠ¸ğ•Šğ•©;  # ğ•¨ gives characters to potentially escape
  ce â† (1-ËœÂ¬Ã—+`)âˆ˜=âŸœâŠ‘âŠ¸âŠ” " ""quot &amp <lt >gt"
  chars â† âŠ‘Â¨ce â‹„ entities â† ("&"âˆ¾âˆ¾âŸœ";")Â¨ 1â†“Â¨ce
  ind â† chars âŠ ğ•©
  useEntity â† ğ•¨ âˆ§ ind < â‰ chars
  âŸ¨useEntity , entities âŠËœ useEntity / indâŸ©
}
HtmlEsc â† {
  uâ€¿e â† CharEntities ğ•©
  i â† / Â¬u
  (â‹iâˆ¾(â‰ Â¨e)//u) âŠ (iâŠğ•©)âˆ¾âˆ¾e
}

################################
Markdown â† {ğ•Šğ•©:1ğ•Šğ•©; extensionsğ•Šğ•©:
  ######
  # Utilities

  # Index of first zero, or number of leading 1s
  Lead â† âŠ‘ âŠâŸœ0

  # Find whether ğ•¨ was true at the last index where ğ•© was true, in each
  # position.
  PrecedesGroup â† {
    # We prepend a 0 to ğ•¨, so that 0 is the "before start" index, with a
    # false value, and normal indices are increased by 1.
    ğ•¨ âˆ¾Ëœâ†© 0
    inds â† 1 + â†•â‰ ğ•©
    # Zero out indices where x was false, and find the greatest index so
    # far at each position.
    last â† âŒˆ` inds Ã— Â¬ğ•©
    last âŠ ğ•¨
  }

  # Remove leading and trailing spaces
  Trim â† { ğ•© /Ëœ Â¬ (âˆ§` âˆ¨ âˆ§`âŒ¾âŒ½) ' '=ğ•© }

  ######
  # First we classify each line based on the type of block it can start.
  ClassifyLine â† (0<â‰ )â—¶(0â€¿0)â€¿{
    ind â† âŠ‘ lineChars FindGroup âŠğ•©
    getLen â† ind âŠ‘ lineClasâˆ¾âŸ¨0ËœâŸ©
    l â† GetLen ğ•©
    âŸ¨ind âˆ§ l>0 â‹„ lâŸ©
  }

  # Non-empty lines in code blocks have 4 leading spaces
  IsCode â† 4 (â‰¤âŸœâ‰ )â—¶âŸ¨0,âˆ§Â´' '=â†‘âŸ© âŠ¢
  ProcCode â† {
    lines â† JoinLines 4 â†“Â¨ ğ•©
    "pre" Html extensionsâ—¶âŸ¨"code"Html HtmlEsc,HighlightâŸ© lines
  }

  # Headings start with #, and require 1-6 #s followed by a space.
  # Any trailing #s are ignored.
  LenHeading â† {
    n â† Lead ğ•©='#'
    l â† (0<n) âˆ§ (6â‰¥n)
    s â† n (<âŸœâ‰ )â—¶âŸ¨1,' '=âŠ‘âŸ© ğ•© # Character after hashes must be a space, if any
    n Ã— l âˆ§ s
  }
  ProcHeading â† {
    tag â† "h" âˆ¾ ğ•¨âŠâ€¢d        # h3 for 3 hashes, etc.
    ğ•© â†“Ëœâ†© ğ•¨+1
    trsp â† âˆ§`âŒ¾âŒ½ ğ•©=' '
    tail â† âˆ§`âŒ¾âŒ½ trspâˆ¨ğ•©='#'  # Mask of trailing hashes
    f â† tail < 0 Shr tail   # Character before trailing hashes
    ğ•© /Ëœâ†© Â¬ f (âŠ‘âŸ¨"\"," ",""âŸ©âŠ<f/ğ•©)â—¶âŸ¨âŠ£,âŠ¢,âŠ¢,0Â¨âŠ¢âŸ© tail
    # Add an id: lowercase the header, replacing non-â€¢a with hyphens
    Slugify â† {
      ch â† â€¢UCS "-Aa"
      bounds â† â¥Š (1â†“ch) +âŒœ 0â€¿26  # Of the upper and lowercase alphabet
      (boundsâŠ¸â‹ {(âŠ‘ch)Â¨âŒ¾((Â¬2|ğ•¨)âŠ¸/)ğ•©+32Ã—1=ğ•¨} âŠ¢)âŒ¾â€¢UCS ğ•©
    }
    extensions { tag âˆ¾â†© " id="âˆ¾""""(âˆ¾âˆ¾âŠ£) Slugify ğ•© }âŸâŠ£ ğ•©
    tag Html ProcInline Trim ğ•©
  }âŸœâŠ‘

  # List items start with a bullet (unordered) or number (ordered).
  LenBullet â† 2 Ã— 1 (<âŸœâ‰ )â—¶âŸ¨0,' '=âŠ‘âŸ© âŠ¢
  LenListNum â† {
    n â† Lead ğ•©âˆŠâ€¢d
    l â† (1â‰¤n) âˆ§ (9â‰¥n)
    ' ' = n â†“ ğ•©
    t â† nâ†“(n+2)â†‘ğ•©
    l âˆ§ (" " â‰¡ 1â†“t) âˆ§ âŠ‘(")." âˆŠËœ 1â†‘t)
  }

  # Any line that starts with a | is a table, at least in my lazy version
  IsTable â† 1Ëœ
  ProcTable â† {
    rows â† (TrimÂ¨ ((1-ËœÂ¬Ã—+`)'|'âŠ¸=)âŠ¸âŠ”)Â¨ ğ•©
    inc â† Â¬ rule â† âˆ§Â´âˆ˜âˆ¾Â¨'-'=rows
    rows â†© ProcInlineÂ¨Â¨âŒ¾(incâŠ¸/) rows
    rowType â† inc / +` rule  # Head or body
    DoRow â† { lf âˆ¾ JoinLines ğ•¨âŠ¸HtmlÂ¨ ğ•© }
    rows â†© (rowType âŠ "th"â€¿"td") DoRowÂ¨ inc/rows
    rowGroups â† Â¯1 â†“ rowType âŠ”â—‹(âˆ¾âŸœ2) "tr"âŠ¸HtmlÂ¨ rows
    sections â† "thead"â€¿"tbody" HtmlâŸœ(lf âˆ¾ JoinLines)Â¨ rowGroups
    "table" Html lf âˆ¾ JoinLines (0 < â‰ Â¨rowGroups) / sections
  }

  # Paragraphs
  ProcParagraph â† {
    "p" Html ProcInline Â¯1 â†“ JoinLines TrimâŒ¾(Â¯1âŠ¸âŠ‘) (Lead ' 'âŠ¸=)âŠ¸â†“Â¨ ğ•©
  }

  # HTML blocks
  # Lazy rule: if it starts with < and contains >, it's probably HTML
  IsHtmlBlock â† âŠ‘ ">"âŠ¸âˆŠ
  ProcHtmlBlock â† JoinLinesâˆ˜âŠ¢

  lineCharsâ€¿lineClasâ€¿procFns â† <Ë˜â‰>âŸ¨
    ""    â€¿ (!âˆ˜0)       â€¿ ProcParagraph
    "#"   â€¿ LenHeading  â€¿ ProcHeading
    " "   â€¿ IsCode      â€¿ ProcCode
  # "-+*" â€¿ LenBullet   â€¿ ProcBullet
  # â€¢d    â€¿ LenListNum  â€¿ ProcListNum
    "|"   â€¿ IsTable     â€¿ ProcTable
    "<"   â€¿ IsHtmlBlock â€¿ ProcHtmlBlock
  âŸ©

  ######
  # Inline elements
  ProcInline â† {
    I2M â† (â‰ ğ•©) â†‘ /â¼  # Index to mask
    punc â† ğ•© âˆŠ "!""#$%&'()*+,-./:;<=>?@[\]^_`{|}~"
    actual â† Â¬ punc âˆ§ IsEscaped ğ•©  # backtick or *actual* backtick?

    # Code spans
    ProcCodeSpan â† {
      ğ•© â†© ' 'Â¨âŒ¾((ğ•©=lf)âŠ¸/) ğ•©
      ğ•© â†© (1â†“Â¯1â†“âŠ¢)âŸ((âŠ¢<â—‹(âˆ§Â´)âŠ‘âˆ¾âŠ‘âˆ˜âŒ½) ' 'âŠ¸=) ğ•©
      "code" Html extensionsâ—¶HtmlEscâ€¿Highlight ğ•©
    }
    tick â† ğ•© = '`'
    tend â† / (âŠ¢ > 0âŠ¸Shr) tick
    tcount â† CountRuns tick
    # ğ•¨ are tick lengths and ğ•© are positions, both sorted by length
    MatchTicks â† {
      # Tick runs other than the last of each length
      notLast â† (âŠ¢=0âŠ¸Shr) ğ•¨
      # Ticks preceded by backslashes can't start code blocks, but can
      # end them. This approach is wrong for multiple ticks with a
      # leading backslash in front, which are excluded but should just
      # be treated as one shorter when leading.
      filter â† notLast / (ğ•©Â¬ğ•¨) âŠ actual
      # For leading ticks, filter by not-last; for trailing ones, rotate
      # by Â¯1 to filter by not-first.
      (filter / âŒ½âŸœnotLast / ğ•©Ëœ)Â¨ 0â€¿Â¯1
    }
    tlen â† tend âŠ tcount
    c â† TraceÂ´ tlen MatchTicksâ—‹((â‹tlen)âŠ¸âŠ) tend
    cl â† (âŠË˜c) âŠ tcount
    ctInds â† â¥ŠË˜ 1 + c -âŒœË˜ clÃ—âŒœ1â€¿0
    include â† Â¬ â‰ ` I2M â¥Š 0â€¿3âŠ¸âŠË˜ ctInds
    codeStart â† I2M 1 âŠË˜ ctInds
    codeGroup â† 1 -Ëœ codeStart (âŠ£Ã—>)â—‹(+`) I2M 2 âŠË˜ ctInds
    code â† ProcCodeSpanÂ¨ codeGroup âŠ” ğ•©

    # Links
    ReplaceMDSub â† { Â¯2 (â†“âˆ¾"html"Ëœ)âŸ(("md"â‰¡â†‘)âˆ§'/'âˆ§Â´âˆ˜â‰ âŠ¢) ğ•© }
    ReplaceMD â† { ReplaceMDSubâŒ¾((âŠ‘ğ•©âŠ"#")âŠ¸â†‘) ğ•© }
    ProcLink â† { âˆ¾âŸ¨"<a href=""",(ReplaceMD ğ•©),""">",ğ•¨,"</a>"âŸ© }
    brak â† /âˆ˜(actual âˆ§ include âˆ§ ğ•©âŠ¸=)Â¨ "]()["
    link â† (âˆŠ/âŠ£)Â´ 0â€¿Â¯1 + 2 â†‘ brak
    chains â† (â‹Ëœ âŠ âŠ¢âˆ¾(â‰ ğ•©)Ëœ)` Â¯1 âŒ½ (<link) âˆ¾ 2 â†“ brak
    chains â†© > (âˆ§Â´ (âˆŠ âˆ§ <âŸœ(â‰ ğ•©))Â¨ 1 â†“ chains)âŠ¸/Â¨ chains
    linkStart â† I2M 0 âŠ chains
    lInds â† 1â€¿0â€¿2â€¿0âŠ¸+Ë˜ (â¥Š2âŠ¸â†•)Ë˜ â‰ chains
    include âˆ§â†© Â¬ â‰ ` I2M â¥Š (Â¯1â€¿1+0â€¿3âŠ¸âŠ)Ë˜ lInds
    linkGroup â† 1 -Ëœ (1â€¿0â¥ŠËœâ‰¢)âŠ¸(/ (âŠ£Ã—>)â—‹(+`I2M) Â¬âŠ¸/) â¥ŠlInds
    links â† <âˆ˜ProcLinkÂ´Ë˜ 2âŠ¸(Ã·ËœâŸœâ‰ âˆ¾âŠ£)âŠ¸â¥Š linkGroup âŠ” ğ•©

    # Emphasis (still rudimentary)
    eMasks â† (actual âˆ§ include âˆ§ ğ•©âŠ¸=)Â¨ "*_"
    eInds â† (âŠ¢-2|âŠ¢)âˆ˜â‰ âŠ¸â†‘âˆ˜/Â¨ eMasks
    include âˆ§â†© Â¬âˆ¨Â´eMasks
    eTags â† âˆ¾ eInds â‰ âŠ¸â¥ŠÂ¨ <"<em>"â€¿"</em>"

    # Remove backslashes used for escaping
    include âˆ§â†© 1 âŒ½ actual

    emâ€¿ent â† include CharEntities ğ•©
    include âˆ§â†© Â¬ em

    new â† âˆ¾âŸ¨eTags,code,links,entâŸ©           # Text to be added
    indsâ† âˆ¾eIndsâˆ¾/Â¨codeStartâ€¿linkStartâ€¿em   # Where to add it
    ((/include)âˆ¾(â‰ Â¨new)/inds) â‹âŠ¸âŠ (include/ğ•©)âˆ¾âˆ¾new
  }

  ######
  # Create the block structure using line classifications.
  lengths â† â‰ Â¨ ğ•©                   # Length of each line
  blanks â† (Lead ' 'âŠ¸=)Â¨ ğ•©         # Number of leading blanks
  nonEmptyMask â† blanks < lengths  # Empty â†â†’ all leading blanks

  # Get line classifications: type of line, and data to be passed into
  # the line processor. Note that leading blanks aren't passed in.
  lineTypeâ€¿lineDat â† <Ë˜â‰ > ClassifyLineÂ¨ blanks â†“Â¨ ğ•©
  # Empty lines have type Â¯1.
  lineType â†© Â¯1Â¨âŒ¾((Â¬nonEmptyMask)âŠ¸/) lineType

  # Lines that could be included in code blocks (will be refined)
  codeMask â† nonEmptyMask âˆ§ blanks â‰¥ 4
  paragraphMask â† 0 = lineType
  # A header can't have 4 spaces of indentation. If it doesn't become
  # part of a code block, it will be included in a paragraph.
  lineType -â†© codeMask âˆ§ 1 = lineType

  # Code blocks consist of indented lines, possibly with blank lines
  # in between. They must be separated from paragraphs by blank lines.
  codeMask âˆ§â†© Â¬ paragraphMask PrecedesGroup codeMask
  codeMask âˆ¨â†© codeMask (âŠ¢ âˆ§ PrecedesGroup âˆ§ PrecedesGroupâŒ¾âŒ½) lineType < 0
  lineType â†© 2Â¨âŒ¾(codeMaskâŠ¸/) lineType

  # Lines continue blocks if they are part of the same multi-line
  # type as the previous line, and otherwise start new ones.
  # Headers (type 1) always start new blocks.
  blockStart â† nonEmptyMask âˆ§ (1 = lineType) âˆ¨ Â¯1âŠ¸ShlâŠ¸â‰  lineType
  # Headers and paragraphs ignore leading blanks.
  drop â† blanks Ã— lineType < 2
  # Group blocks based on blockStart, with type Â¯1 lines excluded.
  blocks â† (1 -Ëœ (lineType â‰¥ 0) Ã— +`blockStart) âŠ” drop â†“Â¨ ğ•©

  # To process a block, pick the appropriate function from procFns.
  ProcBlock â† {tâ€¿l G b: fâ†tâŠ‘procFns â‹„ l F âŠ‘b }
  JoinLines (blockStart / lineTypeâ‰Ë˜lineDat) <âˆ˜ProcBlockË˜ blocks
}

################################
# Testing
# Uses the test cases at https://spec.commonmark.org/0.29/spec.json
# since Github doesn't seem to have published theirs
TestSections â† {
  tests â† Â¯2 â†“Ë˜ 8âŠ¸(Ã·ËœâŸœâ‰ âˆ¾âŠ£)âŠ¸â¥Š2â†“â€¢LNS â€¢pathâˆ¾"spec.json"
  tests â†© ((âŠ‘2+âŠâŸœ':')Â¨âˆ˜âŠ ((-','=Â¯1âŠ‘âŠ¢)â†“â†“)Â¨â‰1 âŠ¢) tests
  testSection â† (1â†“Â¯1â†“âŠ¢)Â¨ 5âŠË˜tests
  UnEscape â† {
    EscapeChar â† { ("\""tn"âŠğ•©) âŠ "\"""âˆ¾â€¢UCS 9â€¿10 }
    esc â† IsEscaped ğ•©
    (Â¬1âŒ½esc) / EscapeCharâŒ¾(escâŠ¸/) ğ•©
  }
  RunTest â† {
    inâ€¿exp â† UnEscapeâˆ˜(1â†“Â¯1â†“âŠ¢)Â¨2â†‘ğ•©
    out â† 0 Markdown (â€¢UCS 10) ((âŠ¢-ËœÂ¬Ã—+`)âˆ˜=âŠ”âŠ¢) in
    âŸ¨expâ‰¡out,in,exp,out,2âŠ‘ğ•©âŸ©
  }

  ignore â† (2 âŠË˜ tests) âˆŠ âŸ¨"47","85"âŸ©
  res â† 1 â†“Ë˜ (Â¬âŠË˜)âŠ¸/ RunTestË˜ tests /Ëœ ignore < testSection âˆŠ ğ•©
  res
}

################################
# Syntax highlighting
Highlight â† {
  idChars â† âŸ¨
    â€¢dâˆ¾"Â¯.Ï€âˆ"
    ' '+âŒ¾â€¢UCSâ€¢a
    â€¢a
    "_"
  âŸ©
  classesâ€¿chars â† <Ë˜ â‰ 2âŠ¸(Ã·ËœâŸœâ‰ âˆ¾âŠ£)âŠ¸â¥ŠâŸ¨
    0             , " "âˆ¾â€¢UCS 9â€¿10
    "Value"       , Â¯1âŠË˜5â€¿2â¥Š"ğ•¨ğ•©ğ•—ğ•˜ğ•¤"
    "Function"    , "+-Ã—Ã·â‹†âˆšâŒŠâŒˆ|Â¬âˆ§âˆ¨<>â‰ =â‰¤â‰¥â‰¡â‰¢âŠ£âŠ¢â¥Šâˆ¾â‰â†‘â†“â†•âŒ½â‰/â‹â’âŠâŠ‘âŠâŠ’âˆŠâ·âŠ”!"âˆ¾Â¯1âŠË˜5â€¿2â¥Š"ğ•ğ•ğ”½ğ”¾ğ•Š"
    "Modifier"    , "ËœË˜Â¨âŒœâ¼Â´`"
    "Composition" , "âˆ˜â—‹âŠ¸âŸœâŒ¾âŠ˜â—¶â‰âš‡âŸ"
    "Number"      , âˆ¾idChars
    "Gets"        , "â†â†©â†’"
    "Paren"       , "()"
    "Bracket"     , "âŸ¨âŸ©"
    "Brace"       , "{}"
    "Ligature"    , "â€¿"
    "Nothing"     , "Â·"
    "Separator"   , "â‹„,"
    "Comment"     , "#"
    "String"      , "'"""
  âŸ©
  classTag â† ""â€¿""âˆ¾>{âŸ¨"<span class='"âˆ¾ğ•©âˆ¾"'>","</span>"âŸ©}Â¨1â†“classes

  râ†ğ•©='#'â‹„sâ†/(â‰ â†‘2âŠ¸â†“)âŠ¸âˆ§ğ•©='''â‹„dâ†/ğ•©='"'
  bâ†âŸ¨sâ‹„Â¯1â†“dâ‹„/râŸ© Traceâ—‹âˆ¾ âŸ¨2+sâ‹„1â†“dâ‹„(âŠ¢-Â¯1â†“0âˆ¾âŠ¢)âˆ˜âŠâŸœ(0âˆ¾+`r)âŠ¸//(ğ•©=lf)âˆ¾1âŸ©
  scâ†+Â´(1â€¿2-Ëœâ‰ classes)Ã—(â‰ `âˆ¨âŠ¢)âˆ˜((â‰ ğ•©)â†‘/â¼âˆ˜âˆ¾)Â¨2â†‘((âŠË˜b)âŠr)âŠ”â—‹(âˆ¾âŸœ2)<Ë˜b
  colâ†scâŒˆ14|chars FindGroup ğ•©

  wâ†(â‰ â†‘0âˆ¾âŠ¢)âŠ¸<idâ†col=5
  idcâ†1+5|1-Ëœ(idChars FindGroup w/ğ•©)+'_'=((1â†“âˆ¾âŸœ0)âŠ¸<id)/ğ•©
  colâ†©((id/+`w)âŠ0âˆ¾idc)âŒ¾(idâŠ¸/)col

  colâ†©(1âŒ½col)âŠ£âŒ¾((ğ•©=âŠ‘"ğ•©")âŠ¸/)col

  emâ€¿ent â† CharEntities ğ•©
  inc â† Â¬ em
  bdâ†(â‰ â†‘Â¯1âˆ¾âŠ¢)âŠ¸â‰ col
  fâ†0<bd/col
  addâ†ent  âˆ¾Ëœâ¥Šf/(bd/col)âŠclassTag
  posâ†(/em)âˆ¾Ëœâ¥Šf/2â†•/bdâˆ¾1
  ((/inc)âˆ¾Ëœ(â‰ Â¨add)/pos) â‹âŠ¸âŠ (inc/ğ•©)âˆ¾Ëœâˆ¾add
}

head â† "<head><link href=""style.css"" rel=""stylesheet""/></head>"âˆ¾lf
ConvertFile â† head âˆ¾ Markdownâˆ˜â€¢LNS
