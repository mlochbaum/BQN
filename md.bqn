# The Markdown function is a markdown to html converter for a "good
# enough" subset of Github-flavored markdown, as specified at
# https://github.github.com/gfm/ .
#
# Additionally, it highlights code sections as BQN, and executes
# sections that are doubly indented (eight spaces), placing their
# results below them.

# Not supported:
# - Thematic breaks like *** or ---
# - Setext headings (underlined with ==== or ----)
# - Fenced code blocks (marked off with ``` or ~~~)
# - HTML blocks
# - Link reference definitions (who uses these?)
# - Block quotes (start with >)
# - Task lists

# Here, a markdown file is represented as a list of its lines, which are
# strings (they don't include any line ending character).
# The html file is constructed directly as a string, using Html.

################################
# Utilities

# Shift cells ğ•¨ into array ğ•©, maintaining its total length
Shl â†   â‰ âˆ˜âŠ¢ â†‘ âˆ¾   # From the left
Shr â† -âˆ˜â‰ âˆ˜âŠ¢ â†‘ âˆ¾Ëœ  # From the right

# Index of first zero, or number of leading 1s in a boolean list
Lead â† âŠ‘ âŠâŸœ0

# ğ•¨ is a list of lists. Find the first of these lists each cell of ğ•©
# belongs to.
FindGroup â† {
  i â† (âˆ¾ğ•¨) âŠ ğ•©  # Index in all cells of ğ•¨
  e â† +`â‰ Â¨ğ•¨     # Index past the end of each group of ğ•¨
  e â‹ i         # How many end-indices does each element pass?
}

# Count the number of consecutive true values up to the current element.
# To do this, subtract the index of the last false character from the
# current index.
CountRuns â† { (1+â†•â‰ ğ•©) (âŠ£ - âŒˆ`âˆ˜Ã—) Â¬ğ•© }

# ğ•© is a string; return a mask of the characters that are escaped, that
# is, preceded by an odd number of backslashes (since a backslash can
# escape another backslash).
IsEscaped â† {
  0 Shl 2 | CountRuns ğ•© = '\'
}

# Remove leading (âˆ§`) and trailing (âˆ§`âŒ¾âŒ½) spaces
Trim â† { ğ•© /Ëœ Â¬ (âˆ§` âˆ¨ âˆ§`âŒ¾âŒ½) ' '=ğ•© }

# Find whether ğ•¨ was true at the last index where ğ•© was false, in each
# position.
PrecedesGroup â† {
  # We prepend a 0 to ğ•¨, so that 0 is the "before start" index, with a
  # false value, and normal indices are increased by 1.
  ğ•¨ âˆ¾Ëœâ†© 0
  inds â† 1 + â†•â‰ ğ•©
  # Zero out indices where x was true, and find the greatest index so
  # far at each position.
  last â† âŒˆ` inds Ã— Â¬ğ•©
  last âŠ ğ•¨
}

# ğ•¨ is a list of possible expression start indices in any order and ğ•© is
# the corresponding endpoints. The expressions are mutually exclusive
# and do not nest, and are enabled in index order. Return a shape Â·â€¿2
# array where the rows give the start and end of each enabled expression
# in index order.
Trace â† {
  # ğ•¨ is a list with one index for each possible start, giving a later
  # start that is known to be enabled if that one is.
  # ğ•© is a mask of all starts known to be enabled.
  # A "stop" position that follows all expressions tells when to stop.
  # At each step the distance from a start to its successor in ğ•¨ is
  # doubled, so the maximum number of steps is about 2â‹†â¼â‰ ğ•©.
  En â† {
    ğ•© â†© 1Â¨âŒ¾((ğ•©/ğ•¨)âŠ¸âŠ)ğ•©  # Starts following from an enabled one are enabled
    ğ•¨ â†© âŠËœ ğ•¨           # Double the number of steps in ğ•¨
    ğ•¨ En ğ•©             # Repeat
  }âŸ{0=Â¯1âŠ‘ğ•©}           #        until the stop is enabled

  g â† â‹ğ•¨               # Order expressions by starting index
  start â† gâŠğ•¨
  end   â† gâŠğ•©
  next â† start â‹ end   # An expression's successor starts after it ends
  next âˆ¾â†© â‰ next        # The stop node is its own successor
  enabled â† Â¯1 â†“ next En (â‰ next)â†‘1  # Search and remove the stop
  enabled / startâ‰Ë˜end # List of enabled starts and ends
}

# Join lines with newline characters. Include a trailing newline.
JoinLines â† âˆ¾ âˆ¾âŸœlfÂ¨

# Create an html node from a tag name and interior text.
Html â† {open ğ•Š contents:
  close â† (âŠ‘openâŠ" ") â†‘ open
  âˆ¾ âŸ¨"<",open,">" , contents , "</",close,">"âŸ©
}

# Insert and remove things from the list ğ•©:
# - include is the mask of elements to keep in ğ•©
# - add is a list of lists to be inserted
# - pos is the list of positions where they should start
# Elements are added just after the given position in ğ•©, in the order
# they appear in âˆ¾add.
Modify â† { âŸ¨include,add,posâŸ©ğ•Šğ•©:
  ((/include)âˆ¾(â‰ Â¨add)/pos) â‹âŠ¸âŠ (include/ğ•©)âˆ¾âˆ¾add
}


################################
Markdown â† {filenameğ•Šğ•©:
  extensions â† filename â‰¢ 0
  path â† extensionsâ—¶""â€¿(âŠ¢/ËœÂ·âˆ¨`âŒ¾âŒ½'/'âŠ¸=) filename

  ######
  # First we classify each line based on the type of block it can start.
  ClassifyLine â† (0<â‰ )â—¶(0â€¿0)â€¿{
    ind â† âŠ‘ lineChars FindGroup âŠğ•©
    getLen â† ind âŠ‘ lineClasâˆ¾âŸ¨0ËœâŸ©
    l â† GetLen ğ•©
    âŸ¨ind âˆ§ l>0 â‹„ lâŸ©
  }

  # Character entity escaping
  # In order to use this with other modifications such as highlighting,
  # CharEntities returns a mask of characters to be escaped, and their
  # corresponding escapes.
  CharEntities â† {1Â¨âŠ¸ğ•Šğ•©;  # ğ•¨ gives characters to potentially escape
    # The string gives escapes and their names, separated by spaces.
    # First split it on the first character.
    ce â† (1-ËœÂ¬Ã—+`)âˆ˜=âŸœâŠ‘âŠ¸âŠ” " ""quot &amp <lt >gt"
    # Characters to escape are given first
    chars â† âŠ‘Â¨ce
    # HTML character entities start with & and end with ;
    entities â† ("&"âˆ¾âˆ¾âŸœ";")Â¨ 1â†“Â¨ce

    # Replace a character if ğ•¨ is not set and it's on our list.
    ind â† chars âŠ ğ•©
    useEntity â† ğ•¨ âˆ§ ind < â‰ chars
    âŸ¨Â¬ useEntity , entities âŠËœ useEntity/ind , /useEntityâŸ©
  }

  # Non-empty lines in code blocks have 4 leading spaces
  ProcCode â† {
    # Strip the leading spaces
    ğ•© â†© 4 â†“Â¨ ğ•©
    code â† JoinLines ğ•©

    # Highlight and unescape html-unsafe characters
    câ€¿ci â† extensionsâ—¶(2â¥Š<âŸ¨âŸ©)â€¿GetHighlights code
    emâ€¿eâ€¿ei â† CharEntities code

    # If every line is indented by at least 4 additional spaces, we will
    # execute each one and insert the results.
    addRslt â† âˆ§Â´ ' ' = âˆ¾ 4 (âŒŠâŸœâ‰  â†‘ âŠ¢)Â¨ ğ•©
    # Don't show assignment results by default
    ShowRslt â† {
      depth â† +` "(){}âŸ¨âŸ©" (âŠ£(â‰ âŠ¸>Ã—Â¯1â‹†2|âŠ¢)âŠ) ğ•©
      ğ•© /Ëœâ†© Â¬ âˆ¨`âŒ¾âŒ½ (0=depth) âˆ§ ğ•©âˆŠ"â‹„,"  # Just the last statement
      g â† ğ•©âˆŠ"â†â†©"
      (âŠ‘gâŠ1) (<âŸœ(â‰ g))â—¶âŸ¨1,Â¬(" "âˆ¾âˆ¾idChars)âˆ§Â´âˆ˜âˆŠËœâ†‘âŸ© ğ•©
    }
    râ€¿ri â† addRsltâ—¶(2â¥Š<âŸ¨âŸ©)â€¿{
      âŸ¨ (ShowRslt âŠ£â—¶âŸ¨"",(â¥Šâˆ¾âŸœlfâ‰1)âˆ˜Fmtâˆ˜âŠ¢âŸ© CodeExec)âŸ(0<â‰ )Â¨ ğ•©
        1 -Ëœ +` 1 + â‰ Â¨ ğ•©   âŸ© # Don't forget the trailing newline
    } ğ•©

    mod â† âŸ¨em,eâˆ¾câˆ¾r,eiâˆ¾ciâˆ¾riâŸ© Modify code
    "pre" Html "code" HtmlâŸ(Â¬extensions) mod
  }
  CodeExec â† X  # dzaima+reference exec. Should be {â}

  # Headings start with #, and require 1-6 #s followed by a space.
  # Any trailing #s are ignored.
  LenHeading â† {
    n â† Lead ğ•©='#'
    l â† (0<n) âˆ§ (6â‰¥n)
    s â† n (<âŸœâ‰ )â—¶âŸ¨1,' '=âŠ‘âŸ© ğ•© # Character after hashes must be a space, if any
    n Ã— l âˆ§ s
  }
  ProcHeading â† {
    tag â† "h" âˆ¾ ğ•¨âŠâ€¢d        # h3 for 3 hashes, etc.
    ğ•© â†“Ëœâ†© ğ•¨+1
    trsp â† âˆ§`âŒ¾âŒ½ ğ•©=' '
    tail â† âˆ§`âŒ¾âŒ½ trspâˆ¨ğ•©='#'  # Mask of trailing hashes
    f â† tail < 0 Shr tail   # Character before trailing hashes
    ğ•© /Ëœâ†© Â¬ f (âŠ‘âŸ¨"\"," ",""âŸ©âŠ<f/ğ•©)â—¶âŸ¨âŠ£,âŠ¢,âŠ¢,0Â¨âŠ¢âŸ© tail
    # Add an id, containing only a-z, digits, and hyphens
    Slugify â† {
      ğ•© â†© '-'Â¨âŒ¾((ğ•©=' ')âŠ¸/) ğ•©  # Replace spaces with dashes
      bounds â† â¥Š +âŒœâŸœ0â€¿26âŒ¾â€¢UCS "Aa"  # Of the upper and lowercase alphabet
      # Lowercase alphabetic characters and remove special characters
      b â† bounds â‹ ğ•©
      ((2|b)âˆ¨âˆŠâŸœ("-"âˆ¾â€¢d))âŠ¸/ +âŸœ(32Ã—1=b)âŒ¾â€¢UCS ğ•©
    }
    extensions { tag âˆ¾â†© " id="âˆ¾""""(âˆ¾âˆ¾âŠ£) Slugify ğ•© }âŸâŠ£ ğ•©
    tag Html ProcInline Trim ğ•©
  }âŸœâŠ‘

  # List items start with a bullet (unordered) or number (ordered).
  LenBullet â† +âŸœÃ— Â·â‰¤âŸœ4âŠ¸Ã— Â·Lead ' '=1âŠ¸â†“
  ProcBullet â† {
    "ul" Html lf âˆ¾ JoinLines ("li" Html ProcInline)Â¨ ğ•¨ â†“Â¨ ğ•©
  }
  LenListNum â† { # Not used yet
    n â† Lead ğ•©âˆŠâ€¢d
    l â† (1â‰¤n) âˆ§ (9â‰¥n)
    ' ' = n â†“ ğ•©
    t â† nâ†“(n+2)â†‘ğ•©
    l âˆ§ (" " â‰¡ 1â†“t) âˆ§ âŠ‘(")." âˆŠËœ 1â†‘t)
  }

  # Table detection handled specially because the spec is... special
  CutTableRow â† {
    b â† '|' = ğ•©            # Mask of bars
    o â† (Â¬b) â‰ â—‹Lead ' '=ğ•©  # Leading | omitted
    r â† b > 0 Shl '\' = ğ•©  # Non-escaped bars
    1 -Ëœ (Â¬râˆ¨1âŒ½b>r) Ã— o + +` r
  }
  ProcTable â† {
    rows â† (TrimÂ¨ CutTableRowâŠ¸âŠ”)Â¨ ğ•©
    inc â† Â¬ rule â† âˆ§Â´âˆ˜âˆ¾Â¨'-'=rows
    rows â†© ProcInlineÂ¨Â¨âŒ¾(incâŠ¸/) rows
    rows â†© (âŠrows) (âŠ¢ âˆ¾ âŸ¨""âŸ© /Ëœ 0âŒˆ-â—‹â‰ )Â¨ rows
    rowType â† inc / +` rule  # Head or body
    DoRow â† { lf âˆ¾ JoinLines ğ•¨âŠ¸HtmlÂ¨ ğ•© }
    rows â†© (rowType âŠ "th"â€¿"td") DoRowÂ¨ inc/rows
    rowGroups â† Â¯1 â†“ rowType âŠ”â—‹(âˆ¾âŸœ2) "tr"âŠ¸HtmlÂ¨ rows
    sections â† "thead"â€¿"tbody" HtmlâŸœ(lf âˆ¾ JoinLines)Â¨ rowGroups
    "table" Html lf âˆ¾ JoinLines (0 < â‰ Â¨rowGroups) / sections
  }

  # Paragraphs
  ProcParagraph â† {
    "p" Html ProcInline Â¯1 â†“ JoinLines TrimâŒ¾(Â¯1âŠ¸âŠ‘) (Lead ' 'âŠ¸=)âŠ¸â†“Â¨ ğ•©
  }

  # HTML blocks
  # Lazy rule: if it starts with < and contains >, it's probably HTML
  IsHtmlBlock â† âŠ‘ ">"âŠ¸âˆŠ
  ProcHtmlBlock â† {
    codeMask â† "<code>" Â¯6âŠ¸âŒ½âŠ¸(>â—‹(âŒˆ`(1+â†•âˆ˜â‰ )âŠ¸Ã—))â—‹(â·âŸœğ•© âˆ¾ 0â¥ŠËœ1-Ëœâ‰ ) "</code>"
    (1Â¨ <âŠ¸âˆ¾ codeMaskâŠ¸GetMultiHighlights)âŠ¸Modify ğ•©
  }âŸextensionsâŸœJoinLines

  lineCharsâ€¿lineClasâ€¿procFns â† <Ë˜â‰>âŸ¨
    ""    â€¿ (!âˆ˜0)       â€¿ ProcParagraph
    "#"   â€¿ LenHeading  â€¿ ProcHeading
    ""    â€¿ 0           â€¿ ProcCode
    ""    â€¿ 0           â€¿ ProcTable
    "-+*" â€¿ LenBullet   â€¿ ProcBullet
  # â€¢d    â€¿ LenListNum  â€¿ ProcListNum
    "<"   â€¿ IsHtmlBlock â€¿ ProcHtmlBlock
  âŸ©

  ######
  # Inline elements
  ProcInline â† {
    I2M â† (â‰ ğ•©) â†‘ /â¼  # Index to mask
    punc â† ğ•© âˆŠ "!""#$%&'()*+,-./:;<=>?@[\]^_`{|}~"
    actual â† Â¬ punc âˆ§ IsEscaped ğ•©  # backtick or *actual* backtick?

    # Code spans
    tick â† ğ•© = '`'
    tend â† / (âŠ¢ > 0âŠ¸Shr) tick
    tcount â† CountRuns tick
    # ğ•¨ are tick lengths and ğ•© are positions, both sorted by length
    MatchTicks â† {
      # Tick runs other than the last of each length
      notLast â† (âŠ¢=0âŠ¸Shr) ğ•¨
      # Ticks preceded by backslashes can't start code blocks, but can
      # end them. This approach is wrong for multiple ticks with a
      # leading backslash in front, which are excluded but should just
      # be treated as one shorter when leading.
      filter â† notLast / (ğ•©Â¬ğ•¨) âŠ actual
      # For leading ticks, filter by not-last; for trailing ones, rotate
      # by Â¯1 to filter by not-first.
      (filter / âŒ½âŸœnotLast / ğ•©Ëœ)Â¨ 0â€¿Â¯1
    }
    tlen â† tend âŠ tcount
    c â† TraceÂ´ tlen MatchTicksâ—‹((â‹tlen)âŠ¸âŠ) tend
    cl â† (âŠË˜c) âŠ tcount
    ctInds â† â¥ŠË˜ 1 + c -âŒœË˜ clÃ—âŒœ1â€¿0
    codeMask â† â‰ ` I2M â¥Š codeBounds â† 1â€¿2âŠ¸âŠË˜ ctInds
    ğ•© â†© ' 'Â¨âŒ¾((codeMaskâˆ§ğ•©=lf)âŠ¸/) ğ•©
    # If span has both a leading and a trailing space, they are removed.
    remSpace â† I2M â¥Š ((1<-ËœËË˜)âˆ§Â·âˆ§ËË˜' '=âŠâŸœğ•©)âŠ¸/ -âŸœ0â€¿1Ë˜ codeBounds
    codeMask âˆ§â†© Â¬ remSpace
    âŸ¨code,codePosâŸ© â† codeMask extensionsâ—¶(2â¥Š<âŸ¨âŸ©)â€¿GetMultiHighlights ğ•©
    include â† Â¬ remSpace âˆ¨ â‰ ` I2M â¥Š ctInds
    codeBounds â†© â¥Š -âŸœ1â€¿0Ë˜ codeBounds
    unused â† actual âˆ§ include âˆ§ Â¬ codeMask

    # Links
    ghPath â† "https://github.com/mlochbaum/BQN/blob/master/"âˆ¾path
    ReplaceMDSub â† { Â¯2 ("md"â‰¡â†‘)â—¶(ghPathâŠ¸âˆ¾)â€¿("README"â€¢_r_"index"âˆ˜â†“âˆ¾"html"Ëœ)âŸ(':'âˆ§Â´âˆ˜â‰ âŠ¢) ğ•© }
    ReplaceMD â† { ReplaceMDSubâŸ(0<â‰ )âŒ¾((âŠ‘ğ•©âŠ"#")âŠ¸â†‘) ğ•© }
    ProcLink â† { âˆ¾âŸ¨"<a href=""",(ReplaceMD ğ•©),""">",ProcInline ğ•¨,"</a>"âŸ© }
    # Find matched-depth [] and () pairs, then join adjacent ones
    brak â† (unused âˆ§ ğ•©âŠ¸=)Â¨ 2â€¿2â¥Š"[]()"
    depth â† (+`-0âŒŠâŠ¢)âˆ˜(-Â´)Ë˜ brak
    FindPairs â† âŸ¨âŸ©â€¿2 â¥Š 1âŠ¸âŠ /Ëœ 2âŠ¸âŠ â‰  (Â¯âˆâŠ¸ShlâŠ¸=(âˆ§+âŠ¢)âˆâŠ¸ShrâŠ¸=)âˆ˜âŠ
    pairs â† depth <âˆ˜(FindPairsâŸ(0<â‰ ))âˆ˜â‰âˆ˜(âˆ§(âŠËœâ‰Ë˜âŠ¢)âŸœâˆ¾âˆ¾Ë˜Â·/â‰ Â¨âˆ˜âŠ¢)Ë˜ /Â¨brak
    JoinPairs â† {
      eâ†1+1âŠË˜ğ•¨ â‹„ bâ†âŠË˜ğ•© â‹„ mâ†(â‰ b)>iâ†bâŠe
      (m/ğ•¨) âˆ¾Ë˜ (m/i)âŠğ•©
    }
    lInds â† âˆ§â—‹(0<â‰ )â—¶(0â€¿4â¥Š0)â€¿JoinPairsÂ´ pairs
    linkPos â† âŠË˜ lInds
    lInds +â‰1â†© 1â€¿0â€¿1â€¿0
    unused âˆ§â†© include âˆ§â†© Â¬ â‰ ` I2M â¥Š (Â¯1â€¿1+0â€¿3âŠ¸âŠ)Ë˜ lInds
    linkGroup â† 1 -Ëœ (1â€¿0â¥ŠËœâ‰¢)âŠ¸(/ (âŠ£Ã—>)â—‹(+`I2M) Â¬âŠ¸/) â¥ŠlInds
    links â† <âˆ˜ProcLinkÂ´Ë˜ (lIndsâ‰ âŠ¸âˆ¾2) (âŠ£â¥ŠÃ—Â´âŠ¸â†‘) linkGroup âŠ” ğ•©

    # Emphasis (still rudimentary)
    eMasks â† (unused âˆ§ ğ•©âŠ¸=)Â¨ "*_"
    eMasks â†© 0âŠ¸ShrâŠ¸âˆ§Â¨âŠ¸(âŠ£âˆ¾Ëœ0âŠ¸ShlâŠ¸âˆ¨âŠ¸<Â¨) eMasks
    eInds â† (âŠ¢-2|âŠ¢)âˆ˜â‰ âŠ¸â†‘âˆ˜/Â¨ eMasks
    include âˆ§â†© Â¬ I2M âˆ§ âˆ¾ eIndsâˆ¾1+2â†“eInds
    eInds âˆ¾â†© âŸ¨codeBoundsâŸ©
    eTags â† âˆ¾ eInds â‰ âŠ¸â¥ŠÂ¨ 2â€¿2â€¿1 / ("<"â€¿"</"âˆ¾Â¨Â·<âˆ¾âŸœ">")Â¨ "em"â€¿"strong"â€¿"code"
    eInds â†© âˆ¾ eInds

    # Remove backslashes used for escaping
    include âˆ§â†© codeMask âˆ¨ 1 âŒ½ actual

    emâ€¿entâ€¿ei â† include CharEntities ğ•©
    include âˆ§â†© em

    add â† âˆ¾âŸ¨eTags,ent,code,linksâŸ©         # Text to be added
    pos â† âˆ¾âŸ¨eInds,ei,codePos,linkPosâŸ©     # Where to add it
    âŸ¨include,add,posâŸ© Modify ğ•©
  }

  ######
  # Create the block structure using line classifications.

  # First remove the html link line: the output *is* the html file.
  ğ•© â†© 2âŠ¸â†“âŸ("*View this file" (âŠ£ â‰¡ âŒŠâ—‹â‰ â†‘âŠ¢) âŠ‘) ğ•©

  lengths â† â‰ Â¨ ğ•©                   # Length of each line
  blanks â† (Lead ' 'âŠ¸=)Â¨ ğ•©         # Number of leading blanks
  nonEmptyMask â† blanks < lengths  # Empty â†â†’ all leading blanks

  # Get line classifications: type of line, and data to be passed into
  # the line processor. Note that leading blanks aren't passed in.
  lineTypeâ€¿lineDat â† <Ë˜â‰ > ClassifyLineÂ¨ blanks â†“Â¨ ğ•©
  # Empty lines have type Â¯1.
  lineType â†© Â¯1Â¨âŒ¾((Â¬nonEmptyMask)âŠ¸/) lineType

  # Lines that could be included in code blocks (will be refined)
  codeMask â† nonEmptyMask âˆ§ blanks â‰¥ 4
  paragraphMask â† 0 = lineType
  # A header can't have 4 spaces of indentation. If it doesn't become
  # part of a code block, it will be included in a paragraph.
  lineType -â†© codeMask âˆ§ 1 = lineType

  # Tables are made up of rows that would otherwise be paragraph rows.
  # They are indicated by the delimiter row, consisting of only a few
  # allowed characters, preceded (!) by a header row with the same
  # number of cells.
  IsTD â† (âˆ§Â´ âˆŠ âˆ¾ âŠ£ âˆŠËœ 2â†‘âŠ¢)âŸœ"-|: "
  tableMask â† (0âŒ¾âŠ‘ nonEmptyMask) âˆ§ paragraphMask âˆ§Â¬ codeMask
  tableDelimMask â† { ğ•© IsTDÂ¨âˆ˜âŠ£âŒ¾(ğ•¨âŠ¸/) ğ•¨ }âŸœğ•© tableMask
  delimValid â† (âŠ¢ =â—‹(â‰ âˆ˜âŠ”âˆ˜CutTableRowÂ¨ âŠâŸœğ•©) -âŸœ1) / tableDelimMask
  headerMask â† 1 âŒ½ delimValidâŒ¾(tableDelimMaskâŠ¸/) 0Â¨ğ•©
  tableMask â†© headerMask (âŠ¢ âˆ§ âŠ£ âˆ¨ âŠ£ PrecedesGroup <) tableMask
  lineType â†© 3Â¨âŒ¾(tableMaskâŠ¸/) lineType

  # Code blocks consist of indented lines, possibly with blank lines
  # in between. They must be separated from paragraphs by blank lines.
  codeMask âˆ§â†© Â¬ paragraphMask PrecedesGroup codeMask
  codeMask âˆ¨â†© codeMask (âŠ¢ âˆ§ PrecedesGroup âˆ§ PrecedesGroupâŒ¾âŒ½) lineType < 0
  lineType â†© 2Â¨âŒ¾(codeMaskâŠ¸/) lineType

  # Lines continue blocks if they are part of the same multi-line
  # type as the previous line, and otherwise start new ones.
  # Headers (type 1) always start new blocks.
  blockStart â† nonEmptyMask âˆ§ (1 = lineType) âˆ¨ Â¯1âŠ¸ShlâŠ¸â‰  lineType
  # Headers and paragraphs ignore leading blanks.
  drop â† blanks Ã— lineType < 2
  # Group blocks based on blockStart, with type Â¯1 lines excluded.
  blocks â† (1 -Ëœ (lineType â‰¥ 0) Ã— +`blockStart) âŠ” drop â†“Â¨ ğ•©

  # To process a block, pick the appropriate function from procFns.
  ProcBlock â† {tâ€¿l G b: fâ†tâŠ‘procFns â‹„ l F âŠ‘b }
  JoinLines (blockStart / lineTypeâ‰Ë˜lineDat) <âˆ˜ProcBlockË˜ blocks
}


################################
# Testing
# Uses the test cases at https://spec.commonmark.org/0.29/spec.json
# since Github doesn't seem to have published theirs
TestSections â† {
  tests â† Â¯2 â†“Ë˜ 8âŠ¸(Ã·ËœâŸœâ‰ âˆ¾âŠ£)âŠ¸â¥Š2â†“â€¢LNS â€¢pathâˆ¾"spec.json"
  tests â†© ((âŠ‘2+âŠâŸœ':')Â¨âˆ˜âŠ ((-','=Â¯1âŠ‘âŠ¢)â†“â†“)Â¨â‰1 âŠ¢) tests
  testSection â† (1â†“Â¯1â†“âŠ¢)Â¨ 5âŠË˜tests
  UnEscape â† {
    EscapeChar â† { ("\""tn"âŠğ•©) âŠ "\"""âˆ¾â€¢UCS 9â€¿10 }
    esc â† IsEscaped ğ•©
    (Â¬1âŒ½esc) / EscapeCharâŒ¾(escâŠ¸/) ğ•©
  }
  RunTest â† {
    inâ€¿exp â† UnEscapeâˆ˜(1â†“Â¯1â†“âŠ¢)Â¨2â†‘ğ•©
    out â† 0 Markdown (â€¢UCS 10) ((âŠ¢-ËœÂ¬Ã—+`)âˆ˜=âŠ”âŠ¢) in
    âŸ¨expâ‰¡out,in,exp,out,2âŠ‘ğ•©âŸ©
  }

  ignore â† (2 âŠË˜ tests) âˆŠ âŸ¨"47","85"âŸ©
  res â† 1 â†“Ë˜ (Â¬âŠË˜)âŠ¸/ RunTestË˜ tests /Ëœ ignore < testSection âˆŠ ğ•©
  res
}


################################
# Syntax highlighting

# Characters in identifiers. These are also used in ProcCode to detect
# if a statement is an assignment.
idChars â† âŸ¨
  â€¢dâˆ¾"Â¯.Ï€âˆ"
  ' '+âŒ¾â€¢UCSâ€¢a
  â€¢a
  "_"
âŸ©

# Return BQN highlights for an string ğ•©, as an âŸ¨add,posâŸ© list for Modify
# (include will be all 1s).
GetHighlights â† {
  # Characters used by BQN, and the HTML class they are associated with.
  classesâ€¿chars â† <Ë˜ â‰ âŸ¨âŸ©â€¿2â¥ŠâŸ¨
    0             , " "âˆ¾â€¢UCS 9â€¿10  # Should never be highlighted
    "Value"       , Â¯1âŠË˜5â€¿2â¥Š"ğ•¨ğ•©ğ•—ğ•˜ğ•¤"# Hack around UTF-16
    "Function"    , "+-Ã—Ã·â‹†âˆšâŒŠâŒˆ|Â¬âˆ§âˆ¨<>â‰ =â‰¤â‰¥â‰¡â‰¢âŠ£âŠ¢â¥Šâˆ¾â‰â†‘â†“â†•âŒ½â‰/â‹â’âŠâŠ‘âŠâŠ’âˆŠâ·âŠ”!"âˆ¾Â¯1âŠË˜5â€¿2â¥Š"ğ•ğ•ğ”½ğ”¾ğ•Š"
    "Modifier"    , "ËœË˜Â¨âŒœâ¼Â´Ë`"
    "Modifier2"   , "âˆ˜â—‹âŠ¸âŸœâŒ¾âŠ˜â—¶â‰âš‡âŸâŠ"
    "Number"      , âˆ¾idChars       # Will be classified among â†‘â†‘ later
    "Gets"        , "â†â†©â†’"
    "Paren"       , "()"
    "Bracket"     , "âŸ¨âŸ©"
    "Brace"       , "{}"
    "Ligature"    , "â€¿"
    "Nothing"     , "Â·"
    "Separator"   , "â‹„,"
    "Comment"     , "#"
    "String"      , "'"""
  âŸ©
  # Turn non-whitespace classes into âŸ¨open,closeâŸ© html tags.
  classTag â† ""â€¿"" âˆ¾ > {âŸ¨"<span class='"âˆ¾ğ•©âˆ¾"'>","</span>"âŸ©}Â¨ 1â†“classes

  # Find each character's group, sending quotes to 0 and unknowns to 1.
  col â† (1-Ëœâ‰ chars) | chars FindGroup ğ•©

  # Locate comments and strings.
  c â† ğ•©='#'
  leâ† /(ğ•©=lf)âˆ¾1
  # Line endings (le) end every comment (/c) on the line, so take a copy
  # for each # before that line but not the previous.
  ceâ† le /Ëœ -âŸœ(0âŠ¸Shl) c/âŠ¸â‹le
  # A single quote can only be used if there's another two places down.
  s â† /0â€¿0âŠ¸ShrâŠ¸âˆ§ğ•©='''
  d â† /ğ•©='"'
  css â† âŸ¨ s   â‹„ Â¯1â†“d â‹„ /c âŸ© # Comment or string start
  cse â† âŸ¨ 2+s â‹„  1â†“d â‹„ ce âŸ© # Corresponding end indices
  # Now b is a table of (start,end) pairs
  b â† css Traceâ—‹âˆ¾ cse
  # Given a list of pairs, get a mask indicating included regions
  ToMask â† (â‰ `âˆ¨âŠ¢) (â‰ ğ•©)â†‘/â¼âˆ˜âˆ¾
  # Split rows and group into textâ€¿comments
  tc â† ((âŠË˜b)âŠc) 2{ğ•—â†‘âŠ”â—‹(âˆ¾âŸœğ•—)} <Ë˜b
  # Color with "String" and "Comment"
  col âŒˆâ†© +Â´ (1â€¿2-Ëœâ‰ classes) Ã— ToMaskÂ¨ tc

  # Color numeric literals and identifiers
  id â† col=5                 # â†â†’ ğ•©âˆŠidChars
  w  â† 0âŠ¸ShlâŠ¸< id            # Word (identifier or number) beginning mask
  wt â† idChars FindGroup w/ğ•© # Type based on first character
  wt+â†© '_' = (0âŠ¸ShrâŠ¸<id)/ğ•©   # Modifier1 to Modifier2 based on word end
  wt+â†© 5Ã—0=wt                # Shift 0 to Number
  wi â† 1-Ëœ+`id/w             # Index of word containing each of /id
  colâ†©(wiâŠwt)âŒ¾(idâŠ¸/) col

  # UTF-16 hack: first half of a special name needs to match the second
  colâ†© (1âŒ½col) âŠ£âŒ¾((ğ•©=âŠ‘"ğ•©")âŠ¸/) col

  # Tags are placed at boundaries between different colors
  boundary â† Â¯1âŠ¸ShlâŠ¸â‰  col
  bcol â† boundary / col
  # Windows gives us rows of start,end where the end position of one
  # color is the start of the next
  # Subtract one to place before the starting character
  pos â† 2 â†• 1-Ëœ/boundaryâˆ¾1
  # Remove class 0 regions, as these don't use tags
  (â¥Š (0<bcol)âŠ¸/)Â¨ âŸ¨bcolâŠclassTag, posâŸ©
}

# Return highlights for areas in ğ•© where ğ•¨ is true.
GetMultiHighlights â† {
  start â† 0âŠ¸ShlâŠ¸< ğ•¨
  groups â† (1 -Ëœ ğ•¨ Ã— +` start) âŠ” ğ•©
  <âˆ˜âˆ¾Ë˜ â‰ ((â‰ âˆ¾2Ëœ) â¥Š Â·> (/start) {ğ•¨âŠ¸+âŒ¾(1âŠ¸âŠ‘)ğ•©}âŸœGetHighlightsÂ¨ âŠ¢) groups
}


################################
# Format an array to a character matrix
# Won't work on functions until we can catch errors
Fmt â† {
  # Vertical padding for arrays of rank greater than 2
  PadV â† {
    # Leading shape
    ls â† Â¯1â†“â‰¢ğ•©
    # Empty lines after each row: 1 if it's at the end of a 2-cell, plus
    # 1 if it's at the end of a 2-cell and a 3-cell, and so on
    p â† â¥Š +â‰Â¯1â€¿âˆÂ´ Ã—âŒœËœ`âŒ¾âŒ½ (-1âŒˆls)â†‘Â¨1
    # But none at the very end
    p â†© 0âŒ¾(Â¯1âŠ¸âŠ‘) p
    Pad â† {iâ†/1+ğ•¨ â‹„ (Â¯1Â¨âŒ¾((Â¬âˆŠi)âŠ¸/)i) âŠ ğ•©âˆ¾(Â¯1âŠ‘â‰¢ğ•©)â¥Š" "}
    p (âŠ‘0âˆŠls)â—¶âŸ¨Pad,+Â´âŠ¸â†‘âŸ© ((Ã—Â´ls)âˆ¾Â¯1âŠ‘â‰¢ğ•©) â¥Š ğ•©
  }âŸ(2 < =)
  # Horizontal padding: just some spaces on either side
  PadH â† {
    (ğ•¨/" ") (âˆ¾â‰1âˆ¾â‰1âŠ£) ğ•©
  }
  Pad â† PadHâŸœPadV
  Enframe â† {(1â‰ ğ•¨)âˆ¨(1â‰ â‰ ğ•©)âˆ¨âŠ‘2âˆŠ+`-Ë"âŸ¨âŸ©"=âŒœâŠğ•©}â—¶{
    â‰"âŸ¨"âˆ¾(Â¯1â†“1â†“âŠğ•©)âˆ¾"âŸ©"
  }â€¿{
    l â† Â¯1 âŠ‘ â‰¢ğ•©
    âˆ¾ âŸ¨ # "â”¼â•’â•›â•ª"
      1â€¿lâ†‘âˆ¾âŸ¨"â”Œ",(5âŠ¸<)â—¶âŸ¨â¥Š"Â·â”€"âŠËœ1âŒŠâŠ¢,â•âŸ©ğ•¨âŸ©
      ((4âŒŠ0âŒˆğ•¨-1)âŠ‘"Â·â•µâ•â”†â”Š")âŒ¾âŠ‘ ğ•©
      (1âˆ¾-l)â†‘"â”˜"
    âŸ©
  }
  FmtEmpty â† (0â€¿0â‰¢â‰¢)â—¶("â”Œâ”"â‰"â””â”˜")â€¿(((2â‰ =)âˆ¨0=â‰ )â—¶{
    'â”'âŒ¾(0â€¿Â¯1âŠ¸âŠ‘) 2 Enframe 1 PadH " "Â¨ğ•©
  }â€¿{
    â‰"âŸ¨âŸ©"âˆ¾Ëœ(1<â‰ )â—¶âŸ¨"",'â¥Š'âŒ¾(Â¯1âŠ¸âŠ‘)Â·âˆ¾Â·âˆ¾âŸœ"â€¿"Â¨â•Â¨âŸ©â‰¢ğ•©
  })
  PaddingJoin â† {1ğ•Šğ•©;
    s â† â‰¢Â¨ ğ•©
    w â† âŒˆËâŸ(=-1Ëœ)1âŠ‘Â¨s
    h â† âŒˆËâ‰1 âŠ‘Â¨s
    âˆ¾â‰2 â‰âŸ(0âŒˆ2-=) (h âˆ¾âŒœ ğ•¨Ã—wÂ¬(-ğ•¨Ã—â‰ w)â†‘1) â†‘Â¨ ğ•©
  }
  FmtMixed â† {
    (=ğ•©) Enframe 2 Pad ğ•¨ PaddingJoin FÂ¨ğ•©
  }
  F â† (2âŒŠâ‰¡)â—¶(â‰â‰¤âŸœâˆâ—¶âŸ¨"'"âŠ¸(âˆ¾âˆ¾âŠ£),â•âŸ©)â€¿{
    num â† ğ•©â‰¤âˆ â‹„ r â† =ğ•©
    ((â‰ (0âŠ¸<+â‰¤)+Â´)â¥Šnum)â—¶{
      # All characters
      k â† -â‰  c â† Â¯1â†“â‰¢ğ•©
      q â† '"'
      ğ•© â†© (1+q=âŠ¢)âŠ¸/âŸ(k=0) ğ•©
      (r Enframe 1 PadH PadV)âŸ(1â‰ r) â‰ (câ†‘q) âˆ¾â‰k ğ•© âˆ¾â‰k âŒ½âŒ¾â¥Šcâ†‘q
    }â€¿{
      # Not homogeneous, or empty
      (âˆ¨Â´0=â‰¢)â—¶FmtMixedâ€¿FmtEmpty ğ•©
    }â€¿{
      # All numbers
      Â¯1 FmtMixed ğ•©
    } ğ•©
  }â€¿FmtMixed
  F ğ•©
}


################################
# Creating HTML files
Head â† "<head><link href="""âˆ¾("../"/Ëœ"/"âŠ‘âˆ˜âˆŠâŠ¢)âˆ¾"style.css"" rel=""stylesheet""/></head>"âˆ¾lfËœ
nav  â† "<div class=""nav""><a href=""https://github.com/mlochbaum/BQN"">BQN</a></div>"âˆ¾lf
ConvertFile â† Head âˆ¾ nav âˆ¾ MarkdownâŸœ(â€¢LNS â€¢pathâˆ¾âŠ¢)
