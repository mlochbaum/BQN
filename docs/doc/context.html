<head>
  <meta charset="utf-8">
  <link href="../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../style.css" rel="stylesheet"/>
  <title>BQN's context-free grammar</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../index.html">BQN</a> / <a href="index.html">doc</a></div>
<h1 id="bqns-context-free-grammar"><a class="header" href="#bqns-context-free-grammar">BQN's context-free grammar</a></h1>
<p><em>See <a href="expression.html#syntactic-role">syntactic role</a> for the plain description of the features discussed here. This page explains why you'd want this system, particularly coming from an APL or J background.</em></p>
<p>APL has a problem. To illustrate, let's look at an APL expression:</p>
<pre><span class='Value'>a</span> <span class='Value'>b</span> <span class='Value'>c</span> <span class='Value'>d</span> <span class='Value'>e</span>
</pre>
<p>It is impossible to say anything about this sentence! Is <code><span class='Value'>c</span></code> a dyadic operator being applied to <code><span class='Value'>b</span></code> and <code><span class='Value'>d</span></code>, or are <code><span class='Value'>b</span></code> and <code><span class='Value'>d</span></code> two dyadic functions being applied to arrays? In contrast, expressions in C-like or Lisp-like languages show their structure of application:</p>
<pre><span class='Value'>b</span><span class='Paren'>(</span><span class='Value'>a</span><span class='Separator'>,</span> <span class='Value'>d</span><span class='Paren'>(</span><span class='Value'>c</span><span class='Paren'>)(</span><span class='Value'>e</span><span class='Paren'>))</span>    <span class='Comment'># C
</span><span class='Paren'>(</span><span class='Value'>b</span> <span class='Value'>a</span> <span class='Paren'>((</span><span class='Value'>d</span> <span class='Value'>c</span><span class='Paren'>)</span> <span class='Value'>e</span><span class='Paren'>))</span>  <span class='Comment'># Lisp
</span></pre>
<p>In each case, some values are passed to functions while others are the functions being applied (both variables and function results can be used in these two ways). These expressions correspond to the APL one if <code><span class='Value'>a</span></code> and <code><span class='Value'>e</span></code> are arrays, <code><span class='Value'>b</span></code> and <code><span class='Value'>c</span></code> are functions, and <code><span class='Value'>d</span></code> is a monadic operator. But in APL the types aren't part of the expression‚Äîthey're a form of context that's required for a reader to know the grammatical structure of the expression. Simple C or Lisp expressions don't need this context because a value's grammatical role is determined by the parentheses: they come after the function in C and before it in Lisp. Of course, a consequence of using parentheses in this way is having a lot of parentheses. BQN has its own way to annotate grammatical role:</p>
<pre><span class='Value'>a</span> <span class='Function'>B</span> <span class='Function'>C</span> <span class='Modifier'>_d</span> <span class='Value'>e</span>
</pre>
<p>Here, the lowercase spelling indicates that <code><span class='Value'>a</span></code> and <code><span class='Value'>e</span></code> are to be treated as subjects (&quot;arrays&quot; in APL) while the uppercase <code><span class='Function'>B</span></code> and <code><span class='Function'>C</span></code> are used as functions and <code><span class='Modifier'>_d</span></code> as a 1-modifier (&quot;monadic operator&quot;). Like parentheses for function application, the spelling is not inherent to the variable values used, but instead indicates their grammatical role in this particular expression. A variable has no inherent spelling and can be used in any role: the names <code><span class='Value'>a</span></code>, <code><span class='Function'>A</span></code>, <code><span class='Modifier'>_a</span></code>, and <code><span class='Modifier2'>_a_</span></code> refer to the exact same variable. While we still don't know anything about what values <code><span class='Value'>a</span></code>, <code><span class='Value'>b</span></code>, <code><span class='Value'>c</span></code>, and so on have, we know how they interact in the line of code above.</p>
<h2 id="is-grammatical-context-really-a-problem"><a class="header" href="#is-grammatical-context-really-a-problem">Is grammatical context really a problem?</a></h2>
<p>Yes, in the sense of <a href="../commentary/problems.html">problems with BQN</a>. A grammar that uses context is harder for humans to read and machines to execute. A particular difficulty is that parts of an expression you don't yet understand can interfere with parts you do, making it difficult to work through an unknown codebase.</p>
<p>One difficulty beginners to APL will encounter is that code in APL at first appears like a string of undifferentiated symbols. For example, a tacit Unique Mask implementation <code><span class='Value'>‚ç≥‚ç®</span><span class='Function'>=</span><span class='Value'>‚ç≥</span><span class='Modifier2'>‚àò</span><span class='Function'>‚â¢</span></code> consists of six largely unfamiliar characters with little to distinguish them (in fact, the one obvious bit of structure, the repeated <code><span class='Value'>‚ç≥</span></code>, is misleading as it means different things in each case!). Simply placing parentheses into the expression, like <code><span class='Paren'>(</span><span class='Value'>‚ç≥‚ç®</span><span class='Paren'>)</span><span class='Function'>=</span><span class='Paren'>(</span><span class='Value'>‚ç≥</span><span class='Modifier2'>‚àò</span><span class='Function'>‚â¢</span><span class='Paren'>)</span></code>, can be a great help to a beginner, and part of learning APL is to naturally see where the parentheses should go. The equivalent BQN expression, <code><span class='Function'>‚äê</span><span class='Modifier'>Àú</span><span class='Function'>=‚Üï</span><span class='Modifier2'>‚àò</span><span class='Function'>‚â†</span></code>, will likely appear equally intimidating at first, but the path to learning which things apply to which is much shorter. Rather than learning the entire list of APL primitives, a beginner just needs to know that superscript characters like <code><span class='Modifier'>Àú</span></code> are 1-modifiers, and characters like <code><span class='Modifier2'>‚àò</span></code> with unbroken circles are 2-modifiers, to start learning the BQN grammar that tie the various parts together.</p>
<p>This sounds like a distant concern to a master of APL or a computer that has no difficulty memorizing a few dozen glyphs. Quite the opposite: the same concern applies to variables whenever you begin work with an unfamiliar codebase! Many APL programmers even enforce variable name conventions to ensure they know the class of a variable. By having such a system built in, BQN keeps you from having to rely on other programmers following a style guide, and also allows greater flexibility, including <a href="functional.html">functional programming</a>, as we'll see later.</p>
<p>Shouldn't a codebase define all the variables it uses, so we can see their class from the definition? Not always: consider that in a language with libraries, code might be imported from dependencies. Many APLs also have some dynamic features that can allow a variable to have more than one class, such as the <code><span class='Value'>‚ç∫</span><span class='Gets'>‚Üê</span><span class='Function'>‚ä¢</span></code> pattern in a dfn that makes <code><span class='Value'>‚ç∫</span></code> an array in the dyadic case but a function in the monadic case. Regardless, searching for a definition somewhere in the code is certainly a lot more work than knowing the class just from looking! One final difficulty is that even one unknown can delay understanding of an entire expression. Suppose in <code><span class='Function'>A</span> <span class='Function'>B</span> <span class='Value'>c</span></code>, <code><span class='Function'>B</span></code> is a function and <code><span class='Value'>c</span></code> is an array, and both values are known to be constant. If <code><span class='Function'>A</span></code> is known to be a function (even if its value is not yet known), its right argument <code><span class='Function'>B</span> <span class='Value'>c</span></code> can be evaluated ahead of time. But if <code><span class='Function'>A</span></code>'s type isn't known, it's impossible to know if this optimization is worth it, because if it is an array, <code><span class='Function'>B</span></code> will instead be called dyadically.</p>
<h2 id="bqns-spelling-system"><a class="header" href="#bqns-spelling-system">BQN's spelling system</a></h2>
<p>BQN's <a href="expression.html">expression grammar</a> is a simplified version of the typical APL, removing some oddities like niladic functions and the two-glyph Outer Product operator. Every value can be used in any of four syntactic roles:</p>
<table>
<thead>
<tr>
<th>BQN</th>
<th>APL</th>
<th>J</th>
</tr>
</thead>
<tbody>
<tr>
<td>Subject</td>
<td>Array</td>
<td>Noun</td>
</tr>
<tr>
<td>Function</td>
<td>Function</td>
<td>Verb</td>
</tr>
<tr>
<td>1-modifier</td>
<td>Monadic operator</td>
<td>Adverb</td>
</tr>
<tr>
<td>2-modifier</td>
<td>Dyadic operator</td>
<td>Conjunction</td>
</tr>
</tbody>
</table>
<p>BQN uses <a href="expression.html#role-spellings">a few rules</a> to determine what role various parts of the grammar have. Primitive glyphs follow patterns: 1-modifiers like <code><span class='Modifier'>Àù</span></code> are superscripts and 2-modifiers like <code><span class='Modifier2'>‚óã</span></code> use circles. A variable can be spelled with different casing or underscores to indicate the role each time it's used.</p>
<p>The syntactic role is a property of an expression, and BQN's grammar determines how roles interact in expressions. But <a href="types.html">type</a> is a property of a value, and evaluation rules control what types can be used. This means that roles exist statically in the code (context-free grammar!) while values can change between or within runs of the program. This is necessary to have a context-free grammar with unrestricted dynamic types. Are unrestricted dynamic types useful? Read on‚Ä¶</p>
<h2 id="mixing-roles"><a class="header" href="#mixing-roles">Mixing roles</a></h2>
<p>BQN's value types align closely with its syntactic roles: functions, 1-modifiers, and 2-modifiers are all types (<em>operation</em> types) as well as roles, while the other types (<em>data</em> types) are split into numbers, characters, and arrays. This is no accident, and usually values will be used in roles that correspond to their underlying type. However, the ability to use a role that doesn't match the type is also useful.</p>
<p>Any type can be passed as an argument to a function, or as an operand, by treating it as a subject. This means that BQN fully supports Lisp-style <a href="functional.html">functional programming</a>, where functions can be used as first-class entities.</p>
<p>It can also be useful to treat a value of a data type as a function, in which case it applies as a constant function. Most primitive modifiers are used in this way at least some of the time. For example, <code><span class='Function'>F</span><span class='Modifier2'>‚éâ</span><span class='Number'>1</span></code> has a constant for the rank even though in general a function can be given, and if <code><span class='Value'>a</span></code> is an array then <code><span class='Value'>a</span><span class='Modifier2'>‚åæ</span><span class='Paren'>(</span><span class='Value'>b</span><span class='Modifier2'>‚ä∏</span><span class='Function'>/</span><span class='Paren'>)</span></code> inserts the values in <code><span class='Value'>a</span></code> into the positions selected by <code><span class='Value'>b</span></code>, ignoring the old values rather than applying a function to them.</p>
<p>Other mixes of roles are generally not useful. For example, just writing a function as a modifier is allowed, but actually applying it to operands will fail. Only a 1-modifier can be applied as a 1-modifier and only a 2-modifier can be applied as a 2-modifier. Only a function or data can be applied as a function.</p>
<p>It's also worth noting that a subject may unexpectedly be a function! For example, the result of <code><span class='Value'>ùï®</span><span class='Modifier'>Àú</span><span class='Value'>ùï©</span></code> may not always be <code><span class='Value'>ùï®</span></code>. <code><span class='Value'>ùï®</span><span class='Modifier'>Àú</span><span class='Value'>ùï©</span></code> is exactly identical to <code><span class='Function'>ùïé</span><span class='Modifier'>Àú</span><span class='Value'>ùï©</span></code>, which gives <code><span class='Value'>ùï©</span><span class='Function'>ùïé</span><span class='Value'>ùï©</span></code>. If <code><span class='Function'>ùïé</span></code> is a number, character, or array, that's the same as <code><span class='Value'>ùï®</span></code>, but if it is a function, then it will be applied. The <a href="constant.html">Constant</a> (<code><span class='Modifier'>Àô</span></code>) modifier keeps a function from being applied when that isn't wanted.</p>
<p>The most general way to change the role of a value in BQN is to give it a name. A convenient trick is to use <code><span class='Brace'>{</span><span class='Function'>ùîΩ</span><span class='Brace'>}</span></code> to convert a subject operand into a function. Converting a function to a subject is more difficult. Often an array of functions is wanted, in which case they can be stranded together; otherwise it's probably best to give the function a name. Picking a function out of a list, for example <code><span class='Function'>‚äë</span><span class='Bracket'>‚ü®</span><span class='Function'>+</span><span class='Bracket'>‚ü©</span></code>, will give it as a subject.</p>
