<head>
  <link href="../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../style.css" rel="stylesheet"/>
  <title>BQN: Functions and modifiers</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../index.html">BQN</a> / <a href="index.html">doc</a></div>
<h1 id="functions-and-modifiers"><a class="header" href="#functions-and-modifiers">Functions and modifiers</a></h1>
<p>BQN's three operation <a href="types.html">types</a> are the function, 1-modifier, and 2-modifier.</p>
<p>In general, an operation is <em>called</em> by passing in <em>inputs</em>, and returns a <em>result</em> value. The inputs and result can have any type. Since BQN isn't a pure <a href="functional.html">functional</a> language, the operation might also have side effects: it can modify the values of variables, perform program input or output, or call other operations with their own side effects.</p>
<p>This page deals with types, not syntax. Expressions with a function or modifier <a href="expression.html#syntactic-role">role</a> don't have to yield a value of that type when run. However, primitives and blocks do have roles that match their types.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>A function has one or two inputs called <em>arguments</em>. The general layout is <code><span class='Value'>𝕨</span> <span class='Function'>Fn</span> <span class='Value'>𝕩</span></code>, with an optional left argument <code><span class='Value'>𝕨</span></code> and a non-optional right argument <code><span class='Value'>𝕩</span></code>. The number of arguments is called its <em>valence</em>, and functions are naturally <em>ambivalent</em>, allowing one or two arguments. When called with one argument—<code><span class='Value'>𝕩</span></code> only—it's <em>monadic</em>, and when called with two it's <em>dyadic</em>. More arguments, or a variable number, should be handled by using a list argument; <a href="block.html#destructuring">destructuring headers</a> can be useful in this case.</p>
<p>Functions can be <a href="primitive.html">primitives</a> or <a href="block.html">blocks</a> (or system functions), but there are also two kinds of <em>compound</em> functions: <em>derived</em> functions that consist of a modifier and its operands, and <a href="train.html">trains</a>. <a href="tacit.html">Tacit</a> programming refers to code written without blocks, so of course it uses compound functions heavily.</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=MyArIDQgICAgICMgUHJpbWl0aXZlIGZ1bmN0aW9uCnvwnZWpK/Cdlal9IDQgICAjIEJsb2NrIGZ1bmN0aW9uCivLnCA0ICAgICAgIyBEZXJpdmVkIGZ1bmN0aW9uCijiiqIrw7cpIDQgICAjIFRyYWlu">↗️</a><pre>    <span class='Number'>3</span> <span class='Function'>+</span> <span class='Number'>4</span>     <span class='Comment'># Primitive function
</span>7
    <span class='Brace'>{</span><span class='Value'>𝕩</span><span class='Function'>+</span><span class='Value'>𝕩</span><span class='Brace'>}</span> <span class='Number'>4</span>   <span class='Comment'># Block function
</span>8
    <span class='Function'>+</span><span class='Modifier'>˜</span> <span class='Number'>4</span>      <span class='Comment'># Derived function
</span>8
    <span class='Paren'>(</span><span class='Function'>⊢+÷</span><span class='Paren'>)</span> <span class='Number'>4</span>   <span class='Comment'># Train
</span>4.25
</pre>
<p>Compound functions have some differences with blocks, most importantly that blocks can express <a href="lexical.html#mutation">mutation</a> while a compound function can't have side effects unless one of its constituent functions or modifiers does. More subtly, compound functions <a href="match.html#atomic-equality">match</a> when they have the same composition (much like lists) while blocks must be the same instance to match. A function's composition can also be inspected directly with <code><span class='Function'>•Decompose</span></code> (<a href="../spec/system.html#operation-properties">spec</a>).</p>
<p>While normally functions are just called, some primitives might try to infer properties of functions, which necessarily involves inspecting their definitions. The <a href="fold.html#identity-values">identity value</a> used by reductions and the results of <a href="undo.html">Undo</a> and <a href="under.html">Under</a> rely on inference.</p>
<h2 id="modifiers"><a class="header" href="#modifiers">Modifiers</a></h2>
<p>There are two modifier types, separated for syntax reasons: 1-modifiers follow the layout <code><span class='Function'>𝔽</span> <span class='Modifier'>_mod</span></code> and 2-modifiers follow <code><span class='Function'>𝔽</span> <span class='Modifier2'>_mod_</span> <span class='Function'>𝔾</span></code>. The values <code><span class='Function'>𝔽</span></code> and <code><span class='Function'>𝔾</span></code> are called <em>operands</em>. There aren't any compound modifiers, so modifiers are always <a href="primitive.html">primitives</a> or system-provided, or <a href="block.html">blocks</a>. A primitive is a 1-modifier when it's written as a superscript like <code><span class='Modifier'>˘</span></code> or <code><span class='Modifier'>˝</span></code>, and a 2-modifier when it has an unbroken circle like <code><span class='Modifier2'>∘</span></code> or <code><span class='Modifier2'>⍟</span></code> (not <code><span class='Function'>⌽</span></code> or <code><span class='Function'>⍉</span></code>).</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=K+KOiTMgICAgIyBQcmltaXRpdmUgMi1tb2RpZmllciAoZGVmZXJyZWQpCjJ7LfCdlZd9ICAjIEJsb2NrIDEtbW9kaWZpZXI=">↗️</a><pre>    <span class='Function'>+</span><span class='Modifier2'>⎉</span><span class='Number'>3</span>    <span class='Comment'># Primitive 2-modifier (deferred)
</span>+⎉3
    <span class='Number'>2</span><span class='Brace'>{</span><span class='Function'>-</span><span class='Value'>𝕗</span><span class='Brace'>}</span>  <span class='Comment'># Block 1-modifier
</span>¯2
</pre>
<p>In general, a modifier call works just like a function: inputs out, result in. Syntactically, a modifier call expression has a function role, but that doesn't affect execution. However, one kind of modifier is more strict: a <em>deferred</em> modifier doesn't evaluate anything when called, but returns a derived function. When the derived function is finally called, the modifier's definition determines what happens. Primitive modifiers are always deferred, and a block modifier is deferred if it includes arguments, either in the header or with <code><span class='Value'>𝕨</span></code>, <code><span class='Value'>𝕩</span></code>, or <code><span class='Value'>𝕤</span></code> in the body.</p>
