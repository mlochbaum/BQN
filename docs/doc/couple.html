<head>
  <link href="../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../style.css" rel="stylesheet"/>
  <title>BQN: Couple and Merge</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../index.html">BQN</a> / <a href="index.html">doc</a></div>
<h1 id="couple-and-merge"><a class="header" href="#couple-and-merge">Couple and Merge</a></h1>
<p>Solo/Couple (<code><span class='Function'>â‰</span></code>) and Merge (<code><span class='Function'>&gt;</span></code>) are functions that create a higher-rank array from lower-rank components. Each takes some number of inner arrays organized in an outer structure, and creates a single array combining all elements of those inner arrays. For example, let's couple two arrays of shape <code><span class='Number'>2</span><span class='Ligature'>â€¿</span><span class='Number'>3</span></code>:</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=4oqiIHAg4oaQIDPigL81w5fijJzihpUzCuKKoiBxIOKGkCAy4oC/M+KliiJhYmNkZWYiCnAg4omNIHEgICAjIHAgY291cGxlZCB0byBxCuKJoiBwIOKJjSBx">â†—ï¸</a><pre>    <span class='Function'>âŠ¢</span> <span class='Value'>p</span> <span class='Gets'>â†</span> <span class='Number'>3</span><span class='Ligature'>â€¿</span><span class='Number'>5</span><span class='Function'>Ã—</span><span class='Modifier'>âŒœ</span><span class='Function'>â†•</span><span class='Number'>3</span>
â”Œâ”€        
â•µ 0 3  6  
  0 5 10  
         â”˜
    <span class='Function'>âŠ¢</span> <span class='Value'>q</span> <span class='Gets'>â†</span> <span class='Number'>2</span><span class='Ligature'>â€¿</span><span class='Number'>3</span><span class='Function'>â¥Š</span><span class='String'>&quot;abcdef&quot;</span>
â”Œâ”€     
â•µ"abc  
  def" 
      â”˜
    <span class='Value'>p</span> <span class='Function'>â‰</span> <span class='Value'>q</span>   <span class='Comment'># p coupled to q
</span>â”Œâ”€             
â• 0   3   6    
  0   5   10   
               
  'a' 'b' 'c'  
  'd' 'e' 'f'  
              â”˜
    <span class='Function'>â‰¢</span> <span class='Value'>p</span> <span class='Function'>â‰</span> <span class='Value'>q</span>
âŸ¨ 2 2 3 âŸ©
</pre>
<p>The result has two inner axes that are shared by <code><span class='Value'>p</span></code> and <code><span class='Value'>q</span></code>, preceded by an outer axis: length 2 because there are two arguments. Calling <code><span class='Function'>â‰</span></code> with no left argument does something simpler: because there is one argument, it just adds a length-1 axis to the front. The argument goes solo, becoming the only major cell of the result.</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=4omNIHEK4omiIOKJjSBx">â†—ï¸</a><pre>    <span class='Function'>â‰</span> <span class='Value'>q</span>
â”Œâ”€     
â•"abc  
  def" 
      â”˜
    <span class='Function'>â‰¢</span> <span class='Function'>â‰</span> <span class='Value'>q</span>
âŸ¨ 1 2 3 âŸ©
</pre>
<p>Merge (<code><span class='Function'>&gt;</span></code>) also takes one argument, but a nested one. Its argument is an array of arrays, each with the same shape. The shape of the result is then the outer shape followed by this shared inner shape.</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=4oqiIGEg4oaQICJBQiLigL8iQ0QiIOKIvuKMnCAicnN0IuKAvyJ1dnci4oC/Inh5eiIKPiBhCuKJoiA+IGE=">â†—ï¸</a><pre>    <span class='Function'>âŠ¢</span> <span class='Value'>a</span> <span class='Gets'>â†</span> <span class='String'>&quot;AB&quot;</span><span class='Ligature'>â€¿</span><span class='String'>&quot;CD&quot;</span> <span class='Function'>âˆ¾</span><span class='Modifier'>âŒœ</span> <span class='String'>&quot;rst&quot;</span><span class='Ligature'>â€¿</span><span class='String'>&quot;uvw&quot;</span><span class='Ligature'>â€¿</span><span class='String'>&quot;xyz&quot;</span>
â”Œâ”€                         
â•µ "ABrst" "ABuvw" "ABxyz"  
  "CDrst" "CDuvw" "CDxyz"  
                          â”˜
    <span class='Function'>&gt;</span> <span class='Value'>a</span>
â”Œâ”€       
â•"ABrst  
  ABuvw  
  ABxyz  
         
 Â·CDrst  
  CDuvw  
  CDxyz" 
        â”˜
    <span class='Function'>â‰¢</span> <span class='Function'>&gt;</span> <span class='Value'>a</span>
âŸ¨ 2 3 5 âŸ©
</pre>
<p>Merge is effectively a generalization of Solo and Couple, since Solo is <code><span class='Brace'>{</span><span class='Function'>&gt;</span><span class='Bracket'>âŸ¨</span><span class='Value'>ğ•©</span><span class='Bracket'>âŸ©</span><span class='Brace'>}</span></code> and Couple is <code><span class='Brace'>{</span><span class='Function'>&gt;</span><span class='Bracket'>âŸ¨</span><span class='Value'>ğ•¨</span><span class='Separator'>,</span><span class='Value'>ğ•©</span><span class='Bracket'>âŸ©</span><span class='Brace'>}</span></code>. Since <code><span class='Function'>â‰</span></code> works on the &quot;list&quot; of arguments, it can only add one dimension, but <code><span class='Function'>&gt;</span></code> can take any number of dimensions as its input.</p>
<h2 id="merge-and-array-theory"><a class="header" href="#merge-and-array-theory">Merge and array theory</a></h2>
<p>In all cases what these functions do is more like reinterpreting existing data than creating new information. In fact, if we ignore the shape and look at the ravels of the arrays involved in a call to Merge, we find that it just <a href="join.html">joins</a> them together. Essentially, Merge is a request to ensure that the inner arrays (which, being independent elements, could be any sort of &quot;ragged&quot; array) can fit together in an array, and then to consider them to be such an array. For this reason, Merge (or a virtual analogue) is used to combine the result cells when calling a function with Rank into a single array.</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=4qWKID4gYQripYog4qWKwqggYQriiL4g4qWKIOKlisKoIGE=">â†—ï¸</a><pre>    <span class='Function'>â¥Š</span> <span class='Function'>&gt;</span> <span class='Value'>a</span>
"ABrstABuvwABxyzCDrstCDuvwCDxyz"
    <span class='Function'>â¥Š</span> <span class='Function'>â¥Š</span><span class='Modifier'>Â¨</span> <span class='Value'>a</span>
âŸ¨ "ABrst" "ABuvw" "ABxyz" "CDrst" "CDuvw" "CDxyz" âŸ©
    <span class='Function'>âˆ¾</span> <span class='Function'>â¥Š</span> <span class='Function'>â¥Š</span><span class='Modifier'>Â¨</span> <span class='Value'>a</span>
"ABrstABuvwABxyzCDrstCDuvwCDxyz"
</pre>
<p>The way this happens, and the constraint that all inner arrays have the same shape, is closely connected to the concept of an array, and like <a href="map.html#table">Table</a> <code><span class='Modifier'>âŒœ</span></code>, Merge might be considered a fundamental way to build up multidimensional arrays from lists. In both cases rank-0 or <a href="enclose.html#whats-a-unit">unit</a> arrays are somewhat special. They are the <a href="fold.html#identity-values">identity value</a> of a function with Table, and can be produced by Merge <a href="undo.html">inverse</a>, <code><span class='Function'>&gt;</span><span class='Modifier'>â¼</span></code> <strong>on a list</strong>, which forces either the outer or inner shape to be empty (BQN chooses <code><span class='Function'>&gt;</span><span class='Modifier'>â¼</span></code> to be <code><span class='Function'>&lt;</span></code>, but only on an array, as <code><span class='Function'>&gt;</span></code> cannot produce non-arrays). Merge has another catch as well: it cannot produce arrays with a <code><span class='Number'>0</span></code> in the shape, except at the end, without relying on a <a href="fill.html">fill</a> element.</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=4oqiIGUg4oaQIOKfqOKfqcKoIOKGlTMK4omiID4gZQriiaIgPiA+IGU=">â†—ï¸</a><pre>    <span class='Function'>âŠ¢</span> <span class='Value'>e</span> <span class='Gets'>â†</span> <span class='Bracket'>âŸ¨âŸ©</span><span class='Modifier'>Â¨</span> <span class='Function'>â†•</span><span class='Number'>3</span>
âŸ¨ âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ© âŸ©
    <span class='Function'>â‰¢</span> <span class='Function'>&gt;</span> <span class='Value'>e</span>
âŸ¨ 3 0 âŸ©
    <span class='Function'>â‰¢</span> <span class='Function'>&gt;</span> <span class='Function'>&gt;</span> <span class='Value'>e</span>
âŸ¨ 3 0 âŸ©
</pre>
<p>Above we start with a list of three empty arrays. After merging once we get a shape <code><span class='Number'>3</span><span class='Ligature'>â€¿</span><span class='Number'>0</span></code> array, sure, but what happens next? The shape added by another merge is the shared shape of that array's elementsâ€”and there aren't any! If the nested list kept some type information around then we might know, but extra type information is essentially how lists pretend to be arrays. True dynamic lists simply can't represent multidimensional arrays with a <code><span class='Number'>0</span></code> in the middle of the shape. In this sense, arrays are a richer model than nested lists.</p>
<h2 id="coupling-units"><a class="header" href="#coupling-units">Coupling units</a></h2>
<p>A note on the topic of Solo and Couple applied to units. As always, one axis will be added, so that the result is a list (strangely, J's <a href="https://code.jsoftware.com/wiki/Vocabulary/commaco#dyadic">laminate</a> differs from Couple in this one case, as it will add an axis to get a shape <code><span class='Number'>2</span><span class='Ligature'>â€¿</span><span class='Number'>1</span></code> result). For Solo, this is interchangeable with <a href="reshape.html">Deshape</a> (<code><span class='Function'>â¥Š</span></code>), and either primitive might be chosen for stylistic reasons. For Couple, it is equivalent to <a href="join.html">Join-to</a> (<code><span class='Function'>âˆ¾</span></code>), but this is an irregular form of Join-to because it is the only case where Join-to adds an axis to both arguments instead of just one. Couple should be preferred in this case.</p>
<p>The function <a href="pair.html">Pair</a> (<code><span class='Function'>â‹ˆ</span></code>) can be written <code><span class='Function'>â‰</span><span class='Modifier2'>â—‹</span><span class='Function'>&lt;</span></code>, while <code><span class='Function'>â‰</span></code> in either valence is <code><span class='Function'>&gt;</span><span class='Modifier2'>âˆ˜</span><span class='Function'>â‹ˆ</span></code>. As an interesting consequence, <code><span class='Function'>â‰</span> <span class='Gets'>â†â†’</span> <span class='Function'>&gt;</span><span class='Modifier2'>âˆ˜</span><span class='Function'>â‰</span><span class='Modifier2'>â—‹</span><span class='Function'>&lt;</span></code>, and <code><span class='Function'>â‹ˆ</span> <span class='Gets'>â†â†’</span> <span class='Function'>&gt;</span><span class='Modifier2'>âˆ˜</span><span class='Function'>â‹ˆ</span><span class='Modifier2'>â—‹</span><span class='Function'>&lt;</span></code>. These two identities have the same form because adding <code><span class='Modifier2'>â—‹</span><span class='Function'>&lt;</span></code> commutes with adding <code><span class='Function'>&gt;</span><span class='Modifier2'>âˆ˜</span></code>.</p>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<p>As discussed above, <code><span class='Function'>â‰</span></code> is equivalent to <code><span class='Function'>&gt;</span><span class='Brace'>{</span><span class='Bracket'>âŸ¨</span><span class='Value'>ğ•©</span><span class='Bracket'>âŸ©</span><span class='Value'>;</span><span class='Bracket'>âŸ¨</span><span class='Value'>ğ•¨</span><span class='Separator'>,</span><span class='Value'>ğ•©</span><span class='Bracket'>âŸ©</span><span class='Brace'>}</span></code>. To complete the picture we should describe Merge fully. Merge is defined on an array argument <code><span class='Value'>ğ•©</span></code> such that there's some shape <code><span class='Value'>s</span></code> satisfying <code><span class='Function'>âˆ§</span><span class='Modifier'>Â´</span><span class='Function'>â¥Š</span><span class='Paren'>(</span><span class='Value'>s</span><span class='Function'>â‰¡â‰¢</span><span class='Paren'>)</span><span class='Modifier'>Â¨</span><span class='Value'>ğ•©</span></code>. If <code><span class='Value'>ğ•©</span></code> is empty then any shape satisfies this expression; <code><span class='Value'>s</span></code> should be chosen based on known type information for <code><span class='Value'>ğ•©</span></code> or otherwise assumed to be <code><span class='Bracket'>âŸ¨âŸ©</span></code>. If <code><span class='Value'>s</span></code> is empty then <code><span class='Value'>ğ•©</span></code> is allowed to contain atoms as well as unit arrays, and these will be implicitly promoted to arrays by the <code><span class='Function'>âŠ‘</span></code> indexing used later. We construct the result by combining the outer and inner axes of the argument with Table; since the outer axes come first they must correspond to the left argument and the inner axes must correspond to the right argument. <code><span class='Value'>ğ•©</span></code> is a natural choice of left argument, and because no concrete array can be used, the right argument will be <code><span class='Function'>â†•</span><span class='Value'>s</span></code>, the array of indices into any element of <code><span class='Value'>ğ•©</span></code>. To get the appropriate element corresponding to a particular choice of index and element of <code><span class='Value'>ğ•©</span></code> we should select using that index. The result of Merge is <code><span class='Value'>ğ•©</span><span class='Function'>âŠ‘</span><span class='Modifier'>ËœâŒœ</span><span class='Function'>â†•</span><span class='Value'>s</span></code>.</p>
<p>Given this definition we can also describe Rank (<code><span class='Modifier2'>â‰</span></code>) in terms of Each (<code><span class='Modifier'>Â¨</span></code>) and the simpler monadic function Enclose-Rank <code><span class='Function'>&lt;</span><span class='Modifier2'>â‰</span><span class='Value'>k</span></code>. We assume effective ranks <code><span class='Value'>j</span></code> for <code><span class='Value'>ğ•¨</span></code> (if present) and <code><span class='Value'>k</span></code> for <code><span class='Value'>ğ•©</span></code> have been computed. Then the correspondence is <code><span class='Value'>ğ•¨</span><span class='Function'>F</span><span class='Modifier2'>â‰</span><span class='Value'>kğ•©</span> <span class='Gets'>â†â†’</span> <span class='Function'>&gt;</span><span class='Paren'>(</span><span class='Function'>&lt;</span><span class='Modifier2'>â‰</span><span class='Value'>jğ•¨</span><span class='Paren'>)</span><span class='Function'>F</span><span class='Modifier'>Â¨</span><span class='Paren'>(</span><span class='Function'>&lt;</span><span class='Modifier2'>â‰</span><span class='Value'>kğ•©</span><span class='Paren'>)</span></code>.</p>
