<head><link href="../style.css" rel="stylesheet"/></head>
<h1 id="indices">Indices</h1>
<p>One-dimensional arrays such as K lists or Python arrays have only one kind of index, a single number that refers to an element. For multidimensional arrays using the leading axis theory, there are several types of indexing that can be useful. Historically, nested APL designs have equivocated between these, which I believe can lead to subtle errors when programming. BQN focuses on single-number (depth 0) indices, which can refer to list elements or array major cells (or more generally indexing along any particular axis). When using this kind of element index, indexed arrays are required to be lists. Only two functions allow the use of list element indices: Range (<code><span class='Function'>â†•</span></code>), which can accept a list argument, and Pick (<code><span class='Function'>âŠ‘</span></code>), which uses the depth-1 arrays in its left argument as index scalars or lists. Others use single-number indices to refer to cells.</p>
<p>The following functions take or return indices. Except where marked, the indices are in the result; this is by far the most common type of index use. <code><span class='Function'>âŠ”</span></code> is given two rows as it falls into both cases. Note that in the result case, there is usually no possibility for the programmer to select the format of indices. Instead, the language should be carefully designed to make sure that the kind of index returned is as useful as possible.</p>
<table>
<thead>
<tr>
<th>Monad</th>
<th>Dyad</th>
<th>Where</th>
<th>How</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span class='Function'>â†•</span></code></td>
<td></td>
<td></td>
<td>Element scalar or list</td>
</tr>
<tr>
<td><code><span class='Function'>/</span></code></td>
<td></td>
<td></td>
<td>Element scalar</td>
</tr>
<tr>
<td><code><span class='Function'>âŠ”</span></code></td>
<td></td>
<td></td>
<td>Element scalar</td>
</tr>
<tr>
<td><code><span class='Function'>âŠ”</span></code></td>
<td><code><span class='Function'>âŠ”</span></code></td>
<td><code><span class='Value'>ğ•¨</span></code>/<code><span class='Value'>ğ•©</span></code></td>
<td>Along-axis scalar</td>
</tr>
<tr>
<td></td>
<td><code><span class='Function'>âŠ‘</span></code></td>
<td><code><span class='Value'>ğ•¨</span></code></td>
<td>Element list</td>
</tr>
<tr>
<td><code><span class='Function'>â‹</span></code></td>
<td><code><span class='Function'>â‹</span></code></td>
<td></td>
<td>Major cell scalar</td>
</tr>
<tr>
<td><code><span class='Function'>â’</span></code></td>
<td><code><span class='Function'>â’</span></code></td>
<td></td>
<td>Major cell scalar</td>
</tr>
<tr>
<td></td>
<td><code><span class='Function'>âŠ</span></code></td>
<td></td>
<td>Major cell scalar</td>
</tr>
<tr>
<td></td>
<td><code><span class='Function'>âŠ’</span></code></td>
<td></td>
<td>Major cell scalar</td>
</tr>
<tr>
<td></td>
<td><code><span class='Function'>âŠ</span></code></td>
<td><code><span class='Value'>ğ•¨</span></code></td>
<td>Major cell or along-axis scalar</td>
</tr>
<tr>
<td><code><span class='Function'>â‰</span></code></td>
<td></td>
<td></td>
<td>Axis scalar</td>
</tr>
</tbody>
</table>
<p>Dyadic Transpose (<code><span class='Function'>â‰</span></code>) uses indices into the right argument axes in its left argument, but since array shape is 1-dimensional, there is only one sensible choice for this, a single number.</p>
<h1 id="element-indices">Element indices</h1>
<p>In general, the index of an element of an array is a list whose length matches the array rank. It is also possible to use a number for an index into a list, as the list index is a singleton, but this must be kept consistent with the rest of the language. NARS-family APLs make the Index Generator (<code><span class='Function'>â†•</span></code> in BQN) return a numeric list when the argument has length 1 but a nested array otherwise. This means that the depth of the result depends on the shape of the argument, inverting the typical hierarchy. BQN shouldn't have such an inconsistency.</p>
<p>Functions <code><span class='Function'>â†•</span></code>, <code><span class='Function'>/</span></code>, <code><span class='Function'>âŠ”</span></code>, and <code><span class='Function'>âŠ‘</span></code> naturally deal with element indices. Each of these can be defined to use list indices. However, this usually rules out the possibility of using scalar indices, which makes these functions harder to use both with generic array manipulation and with the major cell indices discussed in the next section. For this reason BQN restricts <code><span class='Function'>âŠ”</span></code> and monadic <code><span class='Function'>/</span></code> to use depth-0 indices, which comes with the requirement that the arguments to monadic <code><span class='Function'>/</span></code> and <code><span class='Function'>âŠ”</span></code>, and the result of monadic <code><span class='Function'>âŠ”</span></code>, must be lists. For dyadic <code><span class='Function'>âŠ”</span></code> the depth-1 elements of the left argument are lists of indices along axes of the result; see <a href="group.html#multidimensional-grouping">the documentation</a>. The restriction that comes from using single-number indices is that all axes must be treated independently, so that for example it isn't possible to group elements along diagonals without preprocessing. However, this restriction also prevents Group from having to use an ordering on list indices.</p>
<p>Unlike <code><span class='Function'>/</span></code> and <code><span class='Function'>âŠ”</span></code>, <code><span class='Function'>â†•</span></code> and <code><span class='Function'>âŠ‘</span></code> do use list element indices. For <code><span class='Function'>â†•</span></code> this is because the output format can be controlled by the argument format: if passed a single number, the result uses single-number indices (so it's a numeric list); if passed a list, it uses list indices and the result has depth 2 (the result depth is always one greater than the argument depth). For <code><span class='Function'>âŠ‘</span></code>, list indices are chosen because <code><span class='Function'>âŠ</span></code> handles scalar indices well already. When selecting multiple elements from a list, they would typically have to be placed in an array, which is equivalent to <code><span class='Function'>âŠ</span></code> with a numeric list left argument. A single scalar index to <code><span class='Function'>âŠ‘</span></code> is converted to a list, so it can be used to select a single element if only one is wanted. To select multiple elements, <code><span class='Function'>âŠ‘</span></code> uses each depth-1 array in the left argument as an index and replaces it with that element from the right argument. Because this uses elements as elements (not cells), it is impossible to have conformability errors where elements do not fit together. Ill-formed index errors are of course still possible, and the requirements on indices are quite strict. They must exactly match the structure of the right argument's shape, with no scalars or higher-rank arrays allowed. Single numbers also cannot be used in this context, as it would create ambiguity: is a one-element list an index, or does it contain an index?</p>
<h1 id="major-cell-indices">Major cell indices</h1>
<p>One of the successes of the <a href="https://aplwiki.com/wiki/Leading_axis_theory">leading axis model</a> is to introduce a kind of index for multidimensional arrays that is easier to work with than list indices. The model introduces <a href="https://aplwiki.com/wiki/Cell">cells</a>, where a cell index is a list of any length up to the containing array's rank. General cell indices are discussed in the next section; first we introduce a special case, indices into major cells or Â¯1-cells. These cells naturally form a list, so the index of a major cell is a single number. These indices can also be considered indices along the first axis, since an index along any axis is a single number.</p>
<p>Ordering-based functions <code><span class='Function'>â‹</span></code>, <code><span class='Function'>â’</span></code>, <code><span class='Function'>âŠ</span></code>, and <code><span class='Function'>âŠ’</span></code> only really make sense with major cell indices: while it's possible to order other indices as ravel indices, this probably isn't useful from a programming standpoint. Note that <code><span class='Function'>âŠ</span></code> only uses the ordering in an incidental way, because it's defined to return the <em>first</em> index where a right argument cell is found. A mathematician would be more interested in a &quot;pre-image&quot; function that returns the set of all indices where a particular value appears. However, programming usefulness and consistency with the other search functions makes searching for the first index a reasonable choice.</p>
<p>Only one other functionâ€”but an important one!â€”deals with cells rather than elements: <code><span class='Function'>âŠ</span></code>, cell selection. Like dyadic <code><span class='Function'>â†‘â†“â†•âŒ½â‰</span></code> (depth 0) and <code><span class='Function'>/âŠ”</span></code> (depth 1), Select allows either a simple first-axis case where the left argument has depth 1 or less (a depth-0 argument is automatically enclosed), and a multi-axis case where it is a list of depth-1 elements. In each case the depth-1 arrays index along a single axis.</p>
<h1 id="general-cell-indices">General cell indices</h1>
<p>BQN does not use general cell indices directly, but it is useful to consider how they might work, and how a programmer might implement functions that use them in BQN if needed. The functions <code><span class='Function'>/</span></code>, <code><span class='Function'>âŠ”</span></code>, and <code><span class='Function'>âŠ</span></code> are the ones that can work with indices for multidimensional arrays but don't already. Here we will examine how multidimensional versions would work.</p>
<p>A cell index into an array of rank <code><span class='Value'>r</span></code> is a numeric list of length <code><span class='Value'>l</span><span class='Function'>â‰¤</span><span class='Value'>r</span></code>, which then refers to a cell of rank <code><span class='Value'>r</span><span class='Function'>-</span><span class='Value'>l</span></code>. In BQN, the cell at index <code><span class='Value'>i</span></code> of array <code><span class='Value'>a</span></code> is <code><span class='Value'>i</span><span class='Function'>&lt;</span><span class='Modifier'>Â¨</span><span class='Modifier2'>âŠ¸</span><span class='Function'>âŠ</span><span class='Value'>a</span></code>.</p>
<p>Because the shape of a cell index relates to the shape of the indexed array, it makes sense not to enclose cell indices, instead treating them as rows of an index array. A definition for <code><span class='Function'>âŠ</span></code> for depth-1 left arguments of rank at least 1 follows: replace each row of the left argument with the indexed cell of the right, yielding a result with the same depth as the right argument and shape <code><span class='Value'>ğ•¨</span><span class='Paren'>((</span><span class='Number'>Â¯1</span><span class='Function'>â†“âŠ£</span><span class='Paren'>)</span><span class='Function'>âˆ¾</span><span class='Paren'>(</span><span class='Number'>Â¯1</span><span class='Function'>â†‘âŠ£</span><span class='Paren'>)</span><span class='Modifier2'>âŠ¸</span><span class='Function'>â†“</span><span class='Paren'>)</span><span class='Modifier2'>â—‹</span><span class='Function'>â‰¢</span><span class='Value'>ğ•©</span></code>.</p>
<p>To match this format, Range (<code><span class='Function'>â†•</span></code>) could be changed to return a flat array when given a shapeâ€”what is now <code><span class='Function'>&gt;â†•</span></code>. Following this pattern, Indices (<code><span class='Function'>/</span></code>) would also return a flat array, where the indices are rows: using the modified Range, <code><span class='Function'>â¥Š/â†•</span><span class='Modifier2'>âˆ˜</span><span class='Function'>â‰¢</span></code>. Here the result cannot retain the argument's array structure; it is always a rank-2 list of rows.</p>
<p>The most interesting feature would be that <code><span class='Function'>âŠ</span></code> could still allow a nested left argument. In this case each element of the left argument would be an array with row indices as before. However, each row can now index along multiple axes, allowing some adjacent axes to be dependent while others remain independent. This nicely unifies scatter-point and per-axis selection, and allows a mix of the two. However, it doesn't allow total freedom, as non-adjacent axes can't be combined except by also mixing in all axes in between.</p>
<p>Group (<code><span class='Function'>âŠ”</span></code>) could accept the same index format for its index argument. Each depth-1 array in the left argument would correspond to multiple axes in the outer result array, but only a single axis in the argument and inner arrays. Because the ravel ordering of indices must be used to order cells of inner arrays, this modification is not quite as clean as the change to Select. It's also not so clearly useful, as the same results can be obtained by using numeric indices and reshaping the result.</p>
<p>Overall it seems to me that the main use of cell indices of the type discussed here is for the Select primitive, and the other cases are somewhat contrived an awkward. So I've chosen not to support it in BQN at all.</p>

