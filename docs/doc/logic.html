<head>
  <link href="../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../style.css" rel="stylesheet"/>
  <title>BQN Logic functions: And, Or, Not (also Span)</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../index.html">BQN</a> / <a href="index.html">doc</a></div>
<h1 id="logic-functions-and-or-not-also-span"><a class="header" href="#logic-functions-and-or-not-also-span">Logic functions: And, Or, Not (also Span)</a></h1>
<p>BQN uses the mathematical symbols <code><span class='Function'>âˆ§</span></code> and <code><span class='Function'>âˆ¨</span></code> for logical <em>and</em> and <em>or</em>, and <code><span class='Function'>Â¬</span></code> for <em>not</em> (APL's <code><span class='Value'>~</span></code> is discarded since it looks like <code><span class='Modifier'>Ëœ</span></code>, and is less common in mathematics today). These functions are arithmetically extended to apply to all numbers. In the case of Not, that means the linear function <code><span class='Number'>1</span><span class='Modifier2'>âŠ¸</span><span class='Function'>-</span></code>. The two-argument functions have bilinear extensions: And is identical to Times (<code><span class='Function'>Ã—</span></code>), while Or is <code><span class='Function'>Ã—</span><span class='Modifier2'>âŒ¾</span><span class='Function'>Â¬</span></code>, following De Morgan's laws (other ways of obtaining a function for Or give an equivalent resultâ€”there is only one bilinear extension).</p>
<p>If the arguments are probabilities of independent events, then an extended function gives the probability of the boolean function on their outcomes (for example, if <em>A</em> occurs with probability <code><span class='Value'>a</span></code> and <em>B</em> with probability <code><span class='Value'>b</span></code> independent of <em>A</em>, then <em>A</em> or <em>B</em> occurs with probability <code><span class='Value'>a</span><span class='Function'>âˆ¨</span><span class='Value'>b</span></code>). These extensions have also been used in complexity theory, because they allow mathematicians to transfer a logical circuit from the discrete to the continuous domain in order to use calculus on it.</p>
<p>Both valences of <code><span class='Function'>Â¬</span></code> are equivalent to the fork <code><span class='Number'>1</span><span class='Function'>+-</span></code>. The dyadic valence, called &quot;Span&quot;, computes the number of integers in the range from <code><span class='Value'>ğ•©</span></code> to <code><span class='Value'>ğ•¨</span></code>, inclusive, when both arguments are integers and <code><span class='Value'>ğ•©</span><span class='Function'>â‰¤</span><span class='Value'>ğ•¨</span></code> (note the reversed order, which is used for consistency with subtraction). This function has many uses, and in particular is relevant to the <a href="windows.html">Windows</a> function.</p>
<p>These functions are considered <a href="arithmetic.html">arithmetic</a> functions and thus are <a href="arithmetic.html#pervasion">pervasive</a>.</p>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<p>We define:</p>
<pre><span class='Function'>Not</span> <span class='Gets'>â†</span> <span class='Number'>1</span><span class='Function'>+-</span>  <span class='Comment'># also Span
</span><span class='Function'>And</span> <span class='Gets'>â†</span> <span class='Function'>Ã—</span>
<span class='Function'>Or</span>  <span class='Gets'>â†</span> <span class='Function'>Ã—</span><span class='Modifier2'>âŒ¾</span><span class='Function'>Â¬</span>
</pre>
<p>Note that <code><span class='Function'>Â¬</span><span class='Modifier'>â¼</span> <span class='Gets'>â†â†’</span> <span class='Function'>Â¬</span></code>, since when applying <code><span class='Function'>Â¬</span></code> twice the first added 1 will be negated but the second won't; the two 1s cancel leaving two subtractions, and <code><span class='Function'>-</span><span class='Modifier'>â¼</span> <span class='Gets'>â†â†’</span> <span class='Function'>-</span></code>. An alternate definition of Or that matches the typical formula from probability theory is</p>
<pre><span class='Function'>Or</span>  <span class='Gets'>â†</span> <span class='Function'>+-Ã—</span>
</pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>We can form truth <a href="map.html#table">tables</a> including the non-integer value one-half:</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=wqwgMOKAvzAuNeKAvzEKCuKIp+KMnMucIDDigL8wLjXigL8xCgriiKjijJzLnCAw4oC/MC414oC/MQ==">â†—ï¸</a><pre>    <span class='Function'>Â¬</span> <span class='Number'>0</span><span class='Ligature'>â€¿</span><span class='Number'>0.5</span><span class='Ligature'>â€¿</span><span class='Number'>1</span>
âŸ¨ 1 0.5 0 âŸ©

    <span class='Function'>âˆ§</span><span class='Modifier'>âŒœËœ</span> <span class='Number'>0</span><span class='Ligature'>â€¿</span><span class='Number'>0.5</span><span class='Ligature'>â€¿</span><span class='Number'>1</span>
â”Œâ”€            
â•µ 0    0   0  
  0 0.25 0.5  
  0  0.5   1  
             â”˜

    <span class='Function'>âˆ¨</span><span class='Modifier'>âŒœËœ</span> <span class='Number'>0</span><span class='Ligature'>â€¿</span><span class='Number'>0.5</span><span class='Ligature'>â€¿</span><span class='Number'>1</span>
â”Œâ”€            
â•µ   0  0.5 1  
  0.5 0.75 1  
    1    1 1  
             â”˜
</pre>
<p>As with logical And and Or, any value and 0 is 0, while any value or 1 is 1. The other boolean values give the identity values for the two functions: 1 and any value gives that value, as does 0 or the value.</p>
<h2 id="why-not-gcd-and-lcm"><a class="header" href="#why-not-gcd-and-lcm">Why not GCD and LCM?</a></h2>
<p>APL provides <a href="https://aplwiki.com/wiki/GCD">GCD</a> and <a href="https://aplwiki.com/wiki/LCM">LCM</a> as extensions of And and Or, while BQN doesn't make these functions primitives. The main reason for omitting them functions is that they are complicated and, when applied to real or complex numbers, require a significant number of design decisions where there is no obvious choice (for example, whether to use comparison tolerance). On the other hand, these functions are fairly easy to implement, which allows the programmer to control the details, and also add functionality such as the extended GCD. Possible implementations for GCD and LCM are shown in <a href="https://mlochbaum.github.io/bqncrate">bqncrate</a> (<a href="https://mlochbaum.github.io/bqncrate/?q=gcd">GCD</a>, <a href="https://mlochbaum.github.io/bqncrate/?q=lcm">LCM</a>).</p>
<p>A secondary reason is that the GCD falls short as an extension of Or, because its identity value 0 is not total. <code><span class='Number'>0</span><span class='Function'>âˆ¨</span><span class='Value'>x</span></code>, for a real number <code><span class='Value'>x</span></code>, is actually equal to <code><span class='Function'>|</span><span class='Value'>x</span></code> and not <code><span class='Value'>x</span></code>: for example, <code><span class='Number'>0</span><span class='Function'>âˆ¨</span><span class='Number'>Â¯2</span></code> is <code><span class='Number'>2</span></code> in APL. This means the identity <code><span class='Number'>0</span><span class='Function'>âˆ¨</span><span class='Value'>x</span> <span class='Gets'>â†â†’</span> <span class='Value'>x</span></code> isn't reliable in APL.</p>
<h2 id="identity-values"><a class="header" href="#identity-values">Identity values</a></h2>
<p>It's common to apply a <a href="fold.html">fold</a> <code><span class='Function'>âˆ§</span><span class='Modifier'>Â´</span></code> or <code><span class='Function'>âˆ¨</span><span class='Modifier'>Â´</span></code> to a list (checking whether all elements are true and whether any are true, respectively), and so it's important for extensions to And and Or to share their <a href="fold.html#identity-values">identity</a> value. <a href="arithmetic.html#additional-arithmetic">Minimum and Maximum</a> do match And and Or when restricted to booleans, but they have different identity values. It would be dangerous to use Maximum to check whether any element of a list is true because <code><span class='Function'>âŒˆ</span><span class='Modifier'>Â´</span><span class='Bracket'>âŸ¨âŸ©</span></code> yields <code><span class='Number'>Â¯âˆ</span></code> instead of <code><span class='Number'>0</span></code>â€”a bug waiting to happen. To avoid this the programmer would have to use an initial value <code><span class='Value'>ğ•¨</span></code> of <code><span class='Number'>0</span></code>, which is easy to forget.</p>
<p>It's not hard to prove that the bilinear extensions have the identity values we want. Of course <code><span class='Number'>1</span><span class='Function'>âˆ§</span><span class='Value'>x</span></code> is <code><span class='Number'>1</span><span class='Function'>Ã—</span><span class='Value'>x</span></code>, or <code><span class='Value'>x</span></code>, and <code><span class='Number'>0</span><span class='Function'>âˆ¨</span><span class='Value'>x</span></code> is <code><span class='Number'>0</span><span class='Function'>Ã—</span><span class='Modifier2'>âŒ¾</span><span class='Function'>Â¬</span><span class='Value'>x</span></code>, or <code><span class='Function'>Â¬</span><span class='Number'>1</span><span class='Function'>Ã—Â¬</span><span class='Value'>x</span></code>, giving <code><span class='Function'>Â¬Â¬</span><span class='Value'>x</span></code> or <code><span class='Value'>x</span></code> again. Both functions are commutative, so these values are identities on the right as well.</p>
<p>Other logical identities do not necessarily hold. For example, in boolean logic And distributes over Or and vice-versa: <code><span class='Value'>a</span><span class='Function'>âˆ§</span><span class='Value'>b</span><span class='Function'>âˆ¨</span><span class='Value'>c</span> <span class='Gets'>â†â†’</span> <span class='Paren'>(</span><span class='Value'>a</span><span class='Function'>âˆ§</span><span class='Value'>b</span><span class='Paren'>)</span><span class='Function'>âˆ¨</span><span class='Paren'>(</span><span class='Value'>a</span><span class='Function'>âˆ§</span><span class='Value'>c</span><span class='Paren'>)</span></code>. But substituting <code><span class='Function'>Ã—</span></code> for <code><span class='Function'>âˆ§</span></code> and <code><span class='Function'>+-Ã—</span></code> for <code><span class='Function'>âˆ¨</span></code> we find that the left hand side is <code><span class='Paren'>(</span><span class='Value'>a</span><span class='Function'>Ã—</span><span class='Value'>b</span><span class='Paren'>)</span><span class='Function'>+</span><span class='Paren'>(</span><span class='Value'>a</span><span class='Function'>Ã—</span><span class='Value'>c</span><span class='Paren'>)</span><span class='Function'>+</span><span class='Paren'>(</span><span class='Value'>a</span><span class='Function'>Ã—</span><span class='Value'>b</span><span class='Function'>Ã—</span><span class='Value'>c</span><span class='Paren'>)</span></code> while the right gives <code><span class='Paren'>(</span><span class='Value'>a</span><span class='Function'>Ã—</span><span class='Value'>b</span><span class='Paren'>)</span><span class='Function'>+</span><span class='Paren'>(</span><span class='Value'>a</span><span class='Function'>Ã—</span><span class='Value'>c</span><span class='Paren'>)</span><span class='Function'>+</span><span class='Paren'>(</span><span class='Value'>a</span><span class='Function'>Ã—</span><span class='Value'>b</span><span class='Function'>Ã—</span><span class='Value'>a</span><span class='Function'>Ã—</span><span class='Value'>c</span><span class='Paren'>)</span></code>. These are equivalent for arbitrary <code><span class='Value'>b</span></code> and <code><span class='Value'>c</span></code> only if <code><span class='Value'>a</span><span class='Function'>=</span><span class='Value'>a</span><span class='Function'>Ã—</span><span class='Value'>a</span></code>, that is, <code><span class='Value'>a</span></code> is 0 or 1. In terms of probabilities the difference when <code><span class='Value'>a</span></code> is not boolean is caused by failure of independence. On the left hand side, the two arguments of every logical function are independent. On the right hand side, each pair of arguments to <code><span class='Function'>âˆ§</span></code> are independent, but the two arguments to <code><span class='Function'>âˆ¨</span></code>, <code><span class='Value'>a</span><span class='Function'>âˆ§</span><span class='Value'>b</span></code> and <code><span class='Value'>a</span><span class='Function'>âˆ§</span><span class='Value'>c</span></code>, are not. The relationship between these arguments means that logical equivalences no longer apply.</p>
