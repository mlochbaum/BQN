<head>
  <link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../../style.css" rel="stylesheet"/>
  <title>BQN: Implementation of arithmetic</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../../index.html">BQN</a> / <a href="../index.html">implementation</a> / <a href="index.html">primitive</a></div>
<h1 id="implementation-of-arithmetic"><a class="header" href="#implementation-of-arithmetic">Implementation of arithmetic</a></h1>
<p>The dyadic arithmetic functions are <code><span class='Function'>+-Ã—Ã·â‹†âˆšâŒŠâŒˆ|Â¬âˆ§âˆ¨&lt;&gt;â‰ =â‰¤â‰¥</span></code>. There are also monadic arithmetic functions, but they're mostly easy to optimize.</p>
<p>Arithmetic with Table, leading axis extension, and Rank is also covered <a href="#table-and-leading-axis">below</a>.</p>
<h2 id="negative-zero"><a class="header" href="#negative-zero">Negative zero</a></h2>
<p>IEEE defines the float value -0. But to make sure integer-valued floats can be consistently optimized as integers, it's best to treat it identically to 0 (this is much easier than trying to not produce -0s, as a negative number times 0 is -0). To convert a number to 0 if it's -0, just add 0. This needs to be done in <code><span class='Function'>Ã·</span></code> for <code><span class='Value'>ğ•©</span></code>, in <code><span class='Function'>â‹†</span></code> for <code><span class='Value'>ğ•¨</span></code>, and in <code><span class='Function'>âˆš</span></code> for both arguments if it's defined separately. Also in <code><span class='Value'>â€¢math.</span><span class='Function'>Atan2</span></code> for both arguments if defined.</p>
<h2 id="boolean-functions"><a class="header" href="#boolean-functions">Boolean functions</a></h2>
<p>Many arithmetic functions give boolean results when both arguments are boolean. Because there are only 16 possible functions like this, they overlap a lot. Here's a categorization:</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=ZiDihpAg4oin4oC/4oio4oC/POKAvz7igL/iiaDigL894oC/4omk4oC/4oml4oC/K+KAvy3igL/Dl+KAv8O34oC/4ouG4oC/4oia4oC/4oyK4oC/4oyI4oC/fOKAv8KsCgpidCDihpAge+KlivCdlY/ijJzLnOKGlTJ9wqhmCuKIp+KMvijijL3CqOKMvijiio/LmCkpIGJ0ICjijbfiiJjiiqPiiY3LmOKKkOKKuOKKlCnil4soKOKIp8K04oiY4oiK4p+cKOKGlTIpwqhidCniirgvKSBm">â†—ï¸</a><pre>    <span class='Value'>f</span> <span class='Gets'>â†</span> <span class='Function'>âˆ§</span><span class='Ligature'>â€¿</span><span class='Function'>âˆ¨</span><span class='Ligature'>â€¿</span><span class='Function'>&lt;</span><span class='Ligature'>â€¿</span><span class='Function'>&gt;</span><span class='Ligature'>â€¿</span><span class='Function'>â‰ </span><span class='Ligature'>â€¿</span><span class='Function'>=</span><span class='Ligature'>â€¿</span><span class='Function'>â‰¤</span><span class='Ligature'>â€¿</span><span class='Function'>â‰¥</span><span class='Ligature'>â€¿</span><span class='Function'>+</span><span class='Ligature'>â€¿</span><span class='Function'>-</span><span class='Ligature'>â€¿</span><span class='Function'>Ã—</span><span class='Ligature'>â€¿</span><span class='Function'>Ã·</span><span class='Ligature'>â€¿</span><span class='Function'>â‹†</span><span class='Ligature'>â€¿</span><span class='Function'>âˆš</span><span class='Ligature'>â€¿</span><span class='Function'>âŒŠ</span><span class='Ligature'>â€¿</span><span class='Function'>âŒˆ</span><span class='Ligature'>â€¿</span><span class='Function'>|</span><span class='Ligature'>â€¿</span><span class='Function'>Â¬</span>

    <span class='Value'>bt</span> <span class='Gets'>â†</span> <span class='Brace'>{</span><span class='Function'>â¥Šğ•</span><span class='Modifier'>âŒœËœ</span><span class='Function'>â†•</span><span class='Number'>2</span><span class='Brace'>}</span><span class='Modifier'>Â¨</span><span class='Value'>f</span>
    <span class='Function'>âˆ§</span><span class='Modifier2'>âŒ¾</span><span class='Paren'>(</span><span class='Function'>âŒ½</span><span class='Modifier'>Â¨</span><span class='Modifier2'>âŒ¾</span><span class='Paren'>(</span><span class='Function'>âŠ</span><span class='Modifier'>Ë˜</span><span class='Paren'>))</span> <span class='Value'>bt</span> <span class='Paren'>(</span><span class='Function'>â·</span><span class='Modifier2'>âˆ˜</span><span class='Function'>âŠ£â‰</span><span class='Modifier'>Ë˜</span><span class='Function'>âŠ</span><span class='Modifier2'>âŠ¸</span><span class='Function'>âŠ”</span><span class='Paren'>)</span><span class='Modifier2'>â—‹</span><span class='Paren'>((</span><span class='Function'>âˆ§</span><span class='Modifier'>Â´</span><span class='Modifier2'>âˆ˜</span><span class='Function'>âˆŠ</span><span class='Modifier2'>âŸœ</span><span class='Paren'>(</span><span class='Function'>â†•</span><span class='Number'>2</span><span class='Paren'>)</span><span class='Modifier'>Â¨</span><span class='Value'>bt</span><span class='Paren'>)</span><span class='Modifier2'>âŠ¸</span><span class='Function'>/</span><span class='Paren'>)</span> <span class='Value'>f</span>
â”Œâ”€                       
â•µ âŸ¨ 0 1 0 0 âŸ© âŸ¨ < âŸ©      
  âŸ¨ 0 0 1 0 âŸ© âŸ¨ > âŸ©      
  âŸ¨ 0 1 1 0 âŸ© âŸ¨ â‰  âŸ©      
  âŸ¨ 0 0 0 1 âŸ© âŸ¨ âˆ§ Ã— âŒŠ âŸ©  
  âŸ¨ 1 0 0 1 âŸ© âŸ¨ = âŸ©      
  âŸ¨ 0 1 0 1 âŸ© âŸ¨ âˆš âŸ©      
  âŸ¨ 1 1 0 1 âŸ© âŸ¨ â‰¤ âŸ©      
  âŸ¨ 1 0 1 1 âŸ© âŸ¨ â‰¥ â‹† âŸ©    
  âŸ¨ 0 1 1 1 âŸ© âŸ¨ âˆ¨ âŒˆ âŸ©    
                        â”˜
</pre>
<p>Some functions have fast implementations when one argument is boolean. The only ones that really matter are <code><span class='Function'>Ã—</span></code>/<code><span class='Function'>âˆ§</span></code>, which can be implemented with a bitmask, and <code><span class='Function'>âˆ¨</span></code>, which changes the other argument to 1 when the boolean argument is 1 and otherwise leaves it alone. <code><span class='Function'>â‹†</span></code> is <code><span class='Function'>âˆ¨</span><span class='Modifier2'>âŸœ</span><span class='Function'>Â¬</span></code> when <code><span class='Value'>ğ•©</span></code> is boolean.</p>
<p>A function of an atom and a boolean array, or a monadic function on a boolean array, can be implemented by a lookup performed with (preferably SIMD) bitmasking.</p>
<h2 id="strength-reductions"><a class="header" href="#strength-reductions">Strength reductions</a></h2>
<h3 id="trivial-cases"><a class="header" href="#trivial-cases">Trivial cases</a></h3>
<p>Several cases where either one argument is an atom, or both arguments match, have a trivial result. Either the result value is constant, or it matches the argument.</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Constant</th>
<th>Identity</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>+</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>a</span><span class='Function'>-</span><span class='Value'>a</span></code></td>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>-</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>a</span><span class='Function'>Â¬</span><span class='Value'>a</span></code></td>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>Â¬</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>Ã—</span><span class='Number'>0</span></code>*</td>
<td><code><span class='Value'>a</span><span class='Function'>Ã—</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>âˆ¨</span><span class='Number'>1</span></code></td>
<td><code><span class='Value'>a</span><span class='Function'>âˆ¨</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>a</span><span class='Function'>Ã·</span><span class='Value'>a</span></code>*</td>
<td><code><span class='Number'>0</span><span class='Function'>Ã·</span><span class='Value'>a</span></code>*</td>
<td><code><span class='Value'>a</span><span class='Function'>Ã·</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>â‹†</span><span class='Number'>0</span></code>, <code><span class='Number'>1</span><span class='Function'>â‹†</span><span class='Value'>a</span></code></td>
<td><code><span class='Value'>a</span><span class='Function'>â‹†</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td></td>
<td></td>
<td><code><span class='Number'>Â¯âˆ</span><span class='Function'>âŒŠ</span><span class='Value'>a</span></code>, <code><span class='Number'>âˆ</span><span class='Function'>âŒˆ</span><span class='Value'>n</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>a</span><span class='Function'>&gt;</span><span class='Value'>a</span></code> etc.</td>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>âŒŠ</span><span class='Value'>a</span></code>, <code><span class='Value'>a</span><span class='Function'>âŒˆ</span><span class='Value'>a</span></code></td>
</tr>
</tbody>
</table>
<p>None of the constant column entries work for NaNs, except <code><span class='Value'>a</span><span class='Function'>â‹†</span><span class='Number'>0</span></code> and <code><span class='Number'>1</span><span class='Function'>â‹†</span><span class='Value'>a</span></code> which really are always 1. Starred entries have some values of <code><span class='Value'>a</span></code> that result in NaN instead of the expected constant: <code><span class='Number'>0</span></code> for division and <code><span class='Number'>âˆ</span></code> for multiplication. This means that constant-result <code><span class='Function'>Ã·</span></code> always requires checking for NaN while the other entries work for integers without a check.</p>
<h3 id="division-and-modulus"><a class="header" href="#division-and-modulus">Division and modulus</a></h3>
<p>Division, integer division, and Modulus by an atom (<code><span class='Value'>a</span><span class='Function'>Ã·</span><span class='Value'>n</span></code>, <code><span class='Value'>a</span><span class='Function'>âŒŠ</span><span class='Modifier2'>âˆ˜</span><span class='Function'>Ã·</span><span class='Value'>n</span></code>, <code><span class='Value'>n</span><span class='Function'>|</span><span class='Value'>a</span></code>) are subject to many optimizations.</p>
<ul>
<li>Floating-point with FMA: <a href="http://marc-b-reynolds.github.io/math/2019/03/12/FpDiv.html">this page</a> gives a slightly slower method that works for all divisors and a faster one that can be proven to work on over half of divisors.</li>
<li>Integer division: see <a href="https://github.com/ridiculousfish/libdivide">libdivide</a>. Most important is a mask for power-of-two <code><span class='Value'>n</span></code>. For smaller integer types, using SIMD code with 32-bit floats is also fast: see below.</li>
</ul>
<h4 id="integer-division-with-floats"><a class="header" href="#integer-division-with-floats">Integer division with floats</a></h4>
<p>If <code><span class='Value'>p</span></code> and <code><span class='Value'>q</span></code> are integers and <code><span class='Value'>p</span></code> is small enough, then the floor division <code><span class='Function'>âŒŠ</span><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span></code> gives an exact result. This isn't always the case for floats: for example <code><span class='Number'>1</span> <span class='Function'>âŒŠ</span><span class='Modifier2'>âˆ˜</span><span class='Function'>Ã·</span> <span class='Paren'>(</span><span class='Function'>Ã·</span><span class='Number'>9</span><span class='Paren'>)</span><span class='Function'>+</span><span class='Number'>1eÂ¯17</span></code> rounds up to 9 when an exact floor-divide would round down to 8. It means that <code><span class='Value'>q</span><span class='Function'>|</span><span class='Value'>p</span></code> is exactly <code><span class='Value'>p</span><span class='Function'>-</span><span class='Value'>q</span><span class='Function'>Ã—âŒŠ</span><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span></code>, a faster computation.</p>
<p>In particular, if <code><span class='Value'>p</span></code> is a 16-bit or smaller integer and <code><span class='Value'>q</span></code> is any integer, then the floor division <code><span class='Function'>âŒŠ</span><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span></code> and modulus <code><span class='Value'>q</span><span class='Function'>|</span><span class='Value'>p</span></code> can be computed exactly in single (32-bit float) precision. If <code><span class='Value'>p</span></code> is a 32-bit integer these can be computed exactly in double precision.</p>
<p>We will prove the case with 32-bit <code><span class='Value'>p</span></code> in double precision. If <code><span class='Value'>q</span></code> is large, say it has absolute value greater than <code><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>32</span></code>, then <code><span class='Paren'>(</span><span class='Function'>|</span><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span><span class='Paren'>)</span><span class='Function'>&lt;</span><span class='Number'>1</span></code>, meaning the correct result is <code><span class='Number'>Â¯1</span></code> if it's negative and <code><span class='Number'>0</span></code> otherwise. If <code><span class='Value'>p</span></code> is nonzero, then <code><span class='Paren'>(</span><span class='Function'>|</span><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span><span class='Paren'>)</span> <span class='Function'>&gt;</span> <span class='Function'>|Ã·</span><span class='Value'>q</span></code>, which is greater than the smallest subnormal for any <code><span class='Value'>q</span></code>, and so the division won't round up to 0. So suppose <code><span class='Value'>q</span></code> is small. If <code><span class='Value'>p</span></code> is a multiple of <code><span class='Value'>q</span></code>, say <code><span class='Value'>p</span><span class='Function'>=</span><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>q</span></code>, then <code><span class='Value'>k</span><span class='Function'>â‰¤</span><span class='Modifier2'>â—‹</span><span class='Function'>|</span><span class='Value'>p</span></code> so <code><span class='Value'>k</span></code> is exactly representable as a double and the division is exact. If <code><span class='Value'>p</span></code> is not an exact multiple, say <code><span class='Value'>p</span><span class='Function'>=</span><span class='Paren'>(</span><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>q</span><span class='Paren'>)</span><span class='Function'>-</span><span class='Value'>o</span></code> with nonzero <code><span class='Value'>o</span><span class='Function'>&lt;</span><span class='Value'>q</span></code>, then write it as <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Paren'>(</span><span class='Value'>q</span><span class='Function'>-</span><span class='Value'>o</span><span class='Function'>Ã·</span><span class='Value'>k</span><span class='Paren'>)</span></code> and the quotient is <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Number'>1</span><span class='Function'>-</span><span class='Value'>o</span><span class='Function'>Ã·</span><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>q</span></code>, or <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Number'>1</span><span class='Function'>-</span><span class='Value'>o</span><span class='Function'>Ã·</span><span class='Value'>p</span><span class='Function'>+</span><span class='Value'>o</span></code>. For this number to round up to <code><span class='Value'>k</span></code> it would have to be larger than <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Number'>1</span><span class='Function'>-Ã·</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>52</span></code>, but <code><span class='Value'>p</span><span class='Function'>+</span><span class='Value'>o</span></code> is less than <code><span class='Value'>p</span><span class='Function'>+</span><span class='Value'>q</span></code> which is much less than <code><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>52</span></code>, so the rounded division result is less than <code><span class='Value'>k</span></code>, giving a floor of <code><span class='Value'>k</span><span class='Function'>-</span><span class='Number'>1</span></code>.</p>
<h2 id="table-and-leading-axis"><a class="header" href="#table-and-leading-axis">Table and leading-axis</a></h2>
<p>While they can be viewed as special cases of the nested rank discussed in the next section, Table and leading-axis extension are easier to analyze, and are the most common forms. To avoid some tedium with shapes, we'll consider a result shape <code><span class='Value'>m</span><span class='Ligature'>â€¿</span><span class='Value'>n</span></code>, by assuming <code><span class='Value'>ğ•¨</span></code> is a list with length <code><span class='Value'>m</span></code>, and <code><span class='Value'>ğ•©</span></code> is either a list with length <code><span class='Value'>n</span></code>, for Table, or a shape <code><span class='Value'>m</span><span class='Ligature'>â€¿</span><span class='Value'>n</span></code> array, for leading-axis.</p>
<p>With these definitions, <code><span class='Function'>â¥Š</span><span class='Value'>ğ•¨</span><span class='Function'>ğ”½</span><span class='Modifier'>âŒœ</span><span class='Value'>ğ•©</span></code> is <code><span class='Paren'>(</span><span class='Value'>n</span><span class='Function'>/</span><span class='Value'>ğ•¨</span><span class='Paren'>)</span> <span class='Function'>ğ”½</span> <span class='Paren'>(</span><span class='Value'>m</span><span class='Function'>Ã—</span><span class='Value'>n</span><span class='Paren'>)</span><span class='Function'>â¥Š</span><span class='Value'>ğ•©</span></code>. An ideal Table implementation is not actually to compute these expanded arguments in full, but to pick a unit size <code><span class='Value'>k</span><span class='Function'>â‰¤</span><span class='Value'>m</span></code> so that <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>n</span></code> is small but not too small. Then pre-compute <code><span class='Paren'>(</span><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>n</span><span class='Paren'>)</span><span class='Function'>â¥Š</span><span class='Value'>ğ•©</span></code>, and work on <code><span class='Value'>ğ•¨</span></code> in chunks of length <code><span class='Value'>k</span></code>. For example, expand each chunk with <code><span class='Value'>k</span><span class='Function'>/</span></code> into the result, then apply the function in-place with the saved <code><span class='Paren'>(</span><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>n</span><span class='Paren'>)</span><span class='Function'>â¥Š</span><span class='Value'>ğ•©</span></code>. Of course, if the ideal <code><span class='Value'>k</span></code> is 1, then a scalar-vector operation into the result works just as well.</p>
<p>Leading-axis extension is similar: <code><span class='Function'>â¥Š</span><span class='Value'>ğ•¨</span><span class='Function'>ğ”½</span><span class='Value'>ğ•©</span></code> is <code><span class='Paren'>(</span><span class='Value'>n</span><span class='Function'>/</span><span class='Value'>ğ•¨</span><span class='Paren'>)</span> <span class='Function'>ğ”½</span> <span class='Function'>â¥Š</span><span class='Value'>ğ•©</span></code>, so the same strategy works, with minor modifications. Instead of <code><span class='Paren'>(</span><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>n</span><span class='Paren'>)</span><span class='Function'>â¥Š</span><span class='Value'>ğ•©</span></code>, a new chunk of length <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>n</span></code> from <code><span class='Value'>ğ•©</span></code> is needed at each step. And if <code><span class='Value'>k</span></code> is 1, the base case is vector-vector instead of scalar-vector.</p>
<p>Table also admits faster overflow checking for well-behaved functions like <code><span class='Function'>+-Â¬Ã—</span></code>: all combinations of <code><span class='Value'>ğ•¨</span></code> and <code><span class='Value'>ğ•©</span></code> will be used, so there's an overflow exactly if the extreme values would overflow. The range of <code><span class='Value'>ğ•¨</span><span class='Function'>+</span><span class='Modifier'>âŒœ</span><span class='Value'>ğ•©</span></code> is <code><span class='Value'>ğ•¨</span><span class='Function'>+</span><span class='Modifier2'>â—‹</span><span class='Paren'>(</span><span class='Function'>âŒŠ</span><span class='Modifier'>Â´</span><span class='Paren'>)</span><span class='Value'>ğ•©</span></code> to <code><span class='Value'>ğ•¨</span><span class='Function'>+</span><span class='Modifier2'>â—‹</span><span class='Paren'>(</span><span class='Function'>âŒˆ</span><span class='Modifier'>Â´</span><span class='Paren'>)</span><span class='Value'>ğ•©</span></code>, and similarly for <code><span class='Value'>ğ•¨</span><span class='Function'>-</span><span class='Modifier'>âŒœ</span><span class='Value'>ğ•©</span></code> but swapping the max and min of <code><span class='Value'>ğ•©</span></code>. For <code><span class='Value'>ğ•¨</span><span class='Function'>Ã—</span><span class='Modifier'>âŒœ</span><span class='Value'>ğ•©</span></code> all four combinations of min and max need to be checked.</p>
<h2 id="ranked-arithmetic"><a class="header" href="#ranked-arithmetic">Ranked arithmetic</a></h2>
<p>Dyadic arithmetic can be applied to various combinations of axes with leading-axis extension, Table (<code><span class='Modifier'>âŒœ</span></code>), and the Cells (<code><span class='Modifier'>Ë˜</span></code>) and Rank (<code><span class='Modifier2'>â‰</span></code>) modifiers. Cells is of course <code><span class='Modifier2'>â‰</span><span class='Number'>Â¯1</span></code>, and Table is <code><span class='Modifier2'>â‰</span><span class='Number'>0</span><span class='Ligature'>â€¿</span><span class='Number'>âˆ</span></code>, so the general case is arithmetic applied with the Rank operator any number of times.</p>
<p>An application of Rank is best described in terms of its frame ranks, not cells ranks. If <code><span class='Value'>a</span></code> and <code><span class='Value'>b</span></code> are these ranks, then there are <code><span class='Value'>a</span><span class='Function'>âŒŠ</span><span class='Value'>b</span></code> shared frame axes and <code><span class='Value'>a</span><span class='Paren'>(</span><span class='Function'>âŒˆ-âŒŠ</span><span class='Paren'>)</span><span class='Value'>b</span></code> non-shared axes from the argument with the higher-rank frame. Repeating on rank applications from the outside in, with a final rank 0 inherent in the arithmetic itself, the two sets of argument axes are partitioned into sets of shared and non-shared axes. For example consider <code><span class='Function'>+</span><span class='Modifier'>âŒœË˜</span><span class='Modifier2'>â‰</span><span class='Number'>4</span><span class='Ligature'>â€¿</span><span class='Number'>3</span></code> on arguments of ranks 6 and 8.</p>
<ul>
<li>The <code><span class='Modifier2'>â‰</span><span class='Number'>4</span><span class='Ligature'>â€¿</span><span class='Number'>3</span></code> implies frame ranks of 6-4=2 and 8-3=5. This gives 2 shared axes (label 0 below), then 3 non-shared axes from <code><span class='Value'>ğ•©</span></code> (label 1).</li>
<li>The <code><span class='Modifier'>Ë˜</span></code> takes a shared axis (label 2).</li>
<li>The <code><span class='Modifier'>âŒœ</span></code> takes all axes from <code><span class='Value'>ğ•¨</span></code> non-shared (3), then all from <code><span class='Value'>ğ•©</span></code> (label 4).</li>
</ul>
<pre>  <span class='Number'>0</span> <span class='Number'>1</span> <span class='Number'>2</span> <span class='Number'>3</span> <span class='Number'>4</span> <span class='Number'>5</span> <span class='Number'>6</span> <span class='Number'>7</span>
<span class='Value'>ğ•¨</span> <span class='Number'>0</span> <span class='Number'>0</span> <span class='Number'>2</span> <span class='Number'>3</span> <span class='Number'>3</span> <span class='Number'>3</span> 
<span class='Value'>ğ•©</span> <span class='Number'>0</span> <span class='Number'>0</span> <span class='Number'>1</span> <span class='Number'>1</span> <span class='Number'>1</span> <span class='Number'>2</span> <span class='Number'>4</span> <span class='Number'>4</span>
</pre>
<p>An axis set behaves like a single axis, and any adjacent axis sets of the same type (for example, non-shared from <code><span class='Value'>ğ•¨</span></code>) can be combined. Length-1 axes can be ignored as well, so a simplification pass <a href="transpose.html#axis-simplification">like transpose</a> might make sense.</p>
<p>Then the implementation needs to expand this mapping quickly. As usual, long axes are easy and short axes are harder. It's best to take enough result axes so that a cell is not too small, then use a slow outer loop (for example, based on index lists) to call that inner loop.</p>
<p>The scalar-vector, vector-vector cases work as base cases on one axis, and Table and leading-axis are two two-axis cases. There's also a flipped Table <code><span class='Modifier'>ËœâŒœËœ</span></code> and a trailing-axis case like <code><span class='Modifier2'>â‰</span><span class='Number'>1</span></code>. Representing each result axis with &quot;w&quot; if it comes from <code><span class='Value'>ğ•¨</span></code> only, &quot;x&quot; for <code><span class='Value'>ğ•©</span></code> only, and &quot;wx&quot; for shared, we can organize these cases.</p>
<ul>
<li>w, x (scalar-vector)</li>
<li>wx (vector-vector)</li>
<li>w-x (Table)</li>
<li>x-w (flipped Table)</li>
<li>wx-x, wx-w (leading)</li>
<li>w-wx, x-wx (trailing)</li>
</ul>
<p>That's six two-axis combinations; the remaining three possibilities w-w, x-x, and wx-wx are simplifiable.</p>
