<head>
  <meta charset="utf-8">
  <link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../../style.css" rel="stylesheet"/>
  <title>BQN: Implementation of arithmetic</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../../index.html">BQN</a> / <a href="../index.html">implementation</a> / <a href="index.html">primitive</a></div>
<h1 id="implementation-of-arithmetic"><a class="header" href="#implementation-of-arithmetic">Implementation of arithmetic</a></h1>
<p>The dyadic arithmetic functions are <code><span class='Function'>+-Ã—Ã·â‹†âˆšâŒŠâŒˆ|Â¬âˆ§âˆ¨&lt;&gt;â‰ =â‰¤â‰¥</span></code>. There are also monadic arithmetic functions, but they're mostly easy to optimize.</p>
<p>Arithmetic with Table, leading axis extension, and Rank is also covered <a href="#table-and-leading-axis">below</a>.</p>
<h2 id="negative-zero"><a class="header" href="#negative-zero">Negative zero</a></h2>
<p>IEEE defines the float value -0. But to make sure integer-valued floats can be consistently optimized as integers, it's best to treat it identically to 0 (this is much easier than trying to not produce -0s, as a negative number times 0 is -0). To convert a number to 0 if it's -0, just add 0. This needs to be done in <code><span class='Function'>Ã·</span></code> for <code><span class='Value'>ğ•©</span></code>, in <code><span class='Function'>â‹†</span></code> for <code><span class='Value'>ğ•¨</span></code>, and in <code><span class='Function'>âˆš</span></code> for both arguments if it's defined separately. Also in <code><span class='Value'>â€¢math.</span><span class='Function'>Atan2</span></code> for both arguments if defined.</p>
<h2 id="boolean-functions"><a class="header" href="#boolean-functions">Boolean functions</a></h2>
<p>Many arithmetic functions give boolean results when both arguments are boolean. Because there are only 16 possible functions like this, they overlap a lot. Here's a categorization:</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=ZiDihpAg4oin4oC/4oio4oC/POKAvz7igL/iiaDigL894oC/4omk4oC/4oml4oC/K+KAvy3igL/Dl+KAv8O34oC/4ouG4oC/4oia4oC/4oyK4oC/4oyI4oC/fOKAv8KsCgpidCDihpAge+KlivCdlY/ijJzLnOKGlTJ9wqhmCuKIp+KMvijijL3CqOKMvijiio/LmCkpIGJ0ICjijbfiiJjiiqPiiY3LmOKKkOKKuOKKlCnil4soKOKIp8K04oiY4oiK4p+cKOKGlTIpwqhidCniirgvKSBm">â†—ï¸</a><pre>    <span class='Value'>f</span> <span class='Gets'>â†</span> <span class='Function'>âˆ§</span><span class='Ligature'>â€¿</span><span class='Function'>âˆ¨</span><span class='Ligature'>â€¿</span><span class='Function'>&lt;</span><span class='Ligature'>â€¿</span><span class='Function'>&gt;</span><span class='Ligature'>â€¿</span><span class='Function'>â‰ </span><span class='Ligature'>â€¿</span><span class='Function'>=</span><span class='Ligature'>â€¿</span><span class='Function'>â‰¤</span><span class='Ligature'>â€¿</span><span class='Function'>â‰¥</span><span class='Ligature'>â€¿</span><span class='Function'>+</span><span class='Ligature'>â€¿</span><span class='Function'>-</span><span class='Ligature'>â€¿</span><span class='Function'>Ã—</span><span class='Ligature'>â€¿</span><span class='Function'>Ã·</span><span class='Ligature'>â€¿</span><span class='Function'>â‹†</span><span class='Ligature'>â€¿</span><span class='Function'>âˆš</span><span class='Ligature'>â€¿</span><span class='Function'>âŒŠ</span><span class='Ligature'>â€¿</span><span class='Function'>âŒˆ</span><span class='Ligature'>â€¿</span><span class='Function'>|</span><span class='Ligature'>â€¿</span><span class='Function'>Â¬</span>

    <span class='Value'>bt</span> <span class='Gets'>â†</span> <span class='Brace'>{</span><span class='Function'>â¥Šğ•</span><span class='Modifier'>âŒœËœ</span><span class='Function'>â†•</span><span class='Number'>2</span><span class='Brace'>}</span><span class='Modifier'>Â¨</span><span class='Value'>f</span>
    <span class='Function'>âˆ§</span><span class='Modifier2'>âŒ¾</span><span class='Paren'>(</span><span class='Function'>âŒ½</span><span class='Modifier'>Â¨</span><span class='Modifier2'>âŒ¾</span><span class='Paren'>(</span><span class='Function'>âŠ</span><span class='Modifier'>Ë˜</span><span class='Paren'>))</span> <span class='Value'>bt</span> <span class='Paren'>(</span><span class='Function'>â·</span><span class='Modifier2'>âˆ˜</span><span class='Function'>âŠ£â‰</span><span class='Modifier'>Ë˜</span><span class='Function'>âŠ</span><span class='Modifier2'>âŠ¸</span><span class='Function'>âŠ”</span><span class='Paren'>)</span><span class='Modifier2'>â—‹</span><span class='Paren'>((</span><span class='Function'>âˆ§</span><span class='Modifier'>Â´</span><span class='Modifier2'>âˆ˜</span><span class='Function'>âˆŠ</span><span class='Modifier2'>âŸœ</span><span class='Paren'>(</span><span class='Function'>â†•</span><span class='Number'>2</span><span class='Paren'>)</span><span class='Modifier'>Â¨</span><span class='Value'>bt</span><span class='Paren'>)</span><span class='Modifier2'>âŠ¸</span><span class='Function'>/</span><span class='Paren'>)</span> <span class='Value'>f</span>
â”Œâ”€                       
â•µ âŸ¨ 0 1 0 0 âŸ© âŸ¨ < âŸ©      
  âŸ¨ 0 0 1 0 âŸ© âŸ¨ > âŸ©      
  âŸ¨ 0 1 1 0 âŸ© âŸ¨ â‰  âŸ©      
  âŸ¨ 0 0 0 1 âŸ© âŸ¨ âˆ§ Ã— âŒŠ âŸ©  
  âŸ¨ 1 0 0 1 âŸ© âŸ¨ = âŸ©      
  âŸ¨ 0 1 0 1 âŸ© âŸ¨ âˆš âŸ©      
  âŸ¨ 1 1 0 1 âŸ© âŸ¨ â‰¤ âŸ©      
  âŸ¨ 1 0 1 1 âŸ© âŸ¨ â‰¥ â‹† âŸ©    
  âŸ¨ 0 1 1 1 âŸ© âŸ¨ âˆ¨ âŒˆ âŸ©    
                        â”˜
</pre>
<p>Some functions have fast implementations when one argument is boolean. The only ones that really matter are <code><span class='Function'>Ã—</span></code>/<code><span class='Function'>âˆ§</span></code>, which can be implemented with a bitmask, and <code><span class='Function'>âˆ¨</span></code>, which changes the other argument to 1 when the boolean argument is 1 and otherwise leaves it alone. <code><span class='Function'>â‹†</span></code> is <code><span class='Function'>âˆ¨</span><span class='Modifier2'>âŸœ</span><span class='Function'>Â¬</span></code> when <code><span class='Value'>ğ•©</span></code> is boolean.</p>
<p>A function of an atom and a boolean array, or a monadic function on a boolean array, can be implemented by a lookup performed with (preferably SIMD) bitmasking.</p>
<h2 id="strength-reductions"><a class="header" href="#strength-reductions">Strength reductions</a></h2>
<h3 id="trivial-cases"><a class="header" href="#trivial-cases">Trivial cases</a></h3>
<p>Several cases where either one argument is an atom, or both arguments match, have a trivial result. Either the result value is constant, or it matches the argument.</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Constant</th>
<th>Identity</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>+</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>a</span><span class='Function'>-</span><span class='Value'>a</span></code></td>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>-</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>a</span><span class='Function'>Â¬</span><span class='Value'>a</span></code></td>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>Â¬</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>Ã—</span><span class='Number'>0</span></code>*</td>
<td><code><span class='Value'>a</span><span class='Function'>Ã—</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>âˆ¨</span><span class='Number'>1</span></code></td>
<td><code><span class='Value'>a</span><span class='Function'>âˆ¨</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>a</span><span class='Function'>Ã·</span><span class='Value'>a</span></code>*</td>
<td><code><span class='Number'>0</span><span class='Function'>Ã·</span><span class='Value'>a</span></code>*</td>
<td><code><span class='Value'>a</span><span class='Function'>Ã·</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>â‹†</span><span class='Number'>0</span></code>, <code><span class='Number'>1</span><span class='Function'>â‹†</span><span class='Value'>a</span></code></td>
<td><code><span class='Value'>a</span><span class='Function'>â‹†</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td></td>
<td><code><span class='Number'>Â¯âˆ</span><span class='Function'>âŒŠ</span><span class='Value'>a</span></code>, <code><span class='Number'>âˆ</span><span class='Function'>âŒˆ</span><span class='Value'>a</span></code></td>
<td><code><span class='Number'>Â¯âˆ</span><span class='Function'>âŒˆ</span><span class='Value'>a</span></code>, <code><span class='Number'>âˆ</span><span class='Function'>âŒŠ</span><span class='Value'>a</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>a</span><span class='Function'>&gt;</span><span class='Value'>a</span></code> etc.</td>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>âŒŠ</span><span class='Value'>a</span></code>, <code><span class='Value'>a</span><span class='Function'>âŒˆ</span><span class='Value'>a</span></code></td>
</tr>
</tbody>
</table>
<p>None of the constant column entries work for NaNs, except <code><span class='Value'>a</span><span class='Function'>â‹†</span><span class='Number'>0</span></code> and <code><span class='Number'>1</span><span class='Function'>â‹†</span><span class='Value'>a</span></code> which really are always 1. Starred entries have some values of <code><span class='Value'>a</span></code> that result in NaN instead of the expected constant: <code><span class='Number'>0</span></code> for division and <code><span class='Number'>âˆ</span></code> for multiplication. This means that constant-result <code><span class='Function'>Ã·</span></code> always requires checking for NaN while the other entries work for integers without a check.</p>
<h3 id="division-and-modulus"><a class="header" href="#division-and-modulus">Division and modulus</a></h3>
<p>Division, integer division, and Modulus by an atom (<code><span class='Value'>a</span><span class='Function'>Ã·</span><span class='Value'>n</span></code>, <code><span class='Value'>a</span><span class='Function'>âŒŠ</span><span class='Modifier2'>âˆ˜</span><span class='Function'>Ã·</span><span class='Value'>n</span></code>, <code><span class='Value'>n</span><span class='Function'>|</span><span class='Value'>a</span></code>) are subject to many optimizations.</p>
<ul>
<li>Floating-point with FMA: <a href="http://marc-b-reynolds.github.io/math/2019/03/12/FpDiv.html">this page</a> gives a slightly slower method that works for all divisors and a faster one that can be proven to work on over half of divisors.</li>
<li>Integer division: see <a href="https://github.com/ridiculousfish/libdivide">libdivide</a>. Most important is a mask for power-of-two <code><span class='Value'>n</span></code>. For smaller integer types, using SIMD code with 32-bit floats is also fast: see below.</li>
</ul>
<h4 id="integer-division-with-floats"><a class="header" href="#integer-division-with-floats">Integer division with floats</a></h4>
<p>If <code><span class='Value'>p</span></code> and <code><span class='Value'>q</span></code> are integers and <code><span class='Value'>p</span></code> is small enough, then the floor division <code><span class='Function'>âŒŠ</span><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span></code> gives an exact result. This isn't always the case for floats: for example <code><span class='Number'>1</span> <span class='Function'>âŒŠ</span><span class='Modifier2'>âˆ˜</span><span class='Function'>Ã·</span> <span class='Paren'>(</span><span class='Function'>Ã·</span><span class='Number'>9</span><span class='Paren'>)</span><span class='Function'>+</span><span class='Number'>1eÂ¯17</span></code> rounds up to 9 when an exact floor-divide would round down to 8. It means that <code><span class='Value'>q</span><span class='Function'>|</span><span class='Value'>p</span></code> is exactly <code><span class='Value'>p</span><span class='Function'>-</span><span class='Value'>q</span><span class='Function'>Ã—âŒŠ</span><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span></code>, a faster computation.</p>
<p>In particular, if <code><span class='Value'>p</span></code> is a 16-bit or smaller integer and <code><span class='Value'>q</span></code> is any integer, then the floor division <code><span class='Function'>âŒŠ</span><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span></code> and modulus <code><span class='Value'>q</span><span class='Function'>|</span><span class='Value'>p</span></code> can be computed exactly in single (32-bit float) precision. If <code><span class='Value'>p</span></code> is a 32-bit integer these can be computed exactly in double precision. An additional optimization if <code><span class='Value'>q</span></code> is constant is to pre-compute <code><span class='Value'>r</span><span class='Gets'>â†</span><span class='Value'>u</span><span class='Function'>Ã·</span><span class='Value'>q</span></code>, where <code><span class='Value'>u</span></code> is slightly larger than 1. Then <code><span class='Function'>âŒŠ</span><span class='Value'>p</span><span class='Function'>Ã—</span><span class='Value'>r</span></code> is equal to <code><span class='Function'>âŒŠ</span><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span></code>.</p>
<p>We will prove the case with 32-bit <code><span class='Value'>p</span></code> in double precision. If <code><span class='Value'>q</span></code> is large, say it has absolute value greater than <code><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>32</span></code>, then <code><span class='Paren'>(</span><span class='Function'>|</span><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span><span class='Paren'>)</span><span class='Function'>&lt;</span><span class='Number'>1</span></code>, meaning the correct result is <code><span class='Number'>Â¯1</span></code> if it's negative and <code><span class='Number'>0</span></code> otherwise. If <code><span class='Value'>p</span></code> is nonzero, then <code><span class='Paren'>(</span><span class='Function'>|</span><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span><span class='Paren'>)</span> <span class='Function'>&gt;</span> <span class='Function'>|Ã·</span><span class='Value'>q</span></code>, which is greater than the smallest subnormal for any <code><span class='Value'>q</span></code>, and so the division won't round up to 0. So suppose <code><span class='Value'>q</span></code> is small. If <code><span class='Value'>p</span></code> is a multiple of <code><span class='Value'>q</span></code>, say <code><span class='Value'>p</span><span class='Function'>=</span><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>q</span></code>, then <code><span class='Value'>k</span><span class='Function'>â‰¤</span><span class='Modifier2'>â—‹</span><span class='Function'>|</span><span class='Value'>p</span></code> so <code><span class='Value'>k</span></code> is exactly representable as a double and the division is exact. If <code><span class='Value'>p</span></code> is not an exact multiple, say <code><span class='Value'>p</span><span class='Function'>=</span><span class='Paren'>(</span><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>q</span><span class='Paren'>)</span><span class='Function'>-</span><span class='Value'>o</span></code> with nonzero <code><span class='Value'>o</span><span class='Function'>&lt;</span><span class='Value'>q</span></code>, then write it as <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Paren'>(</span><span class='Value'>q</span><span class='Function'>-</span><span class='Value'>o</span><span class='Function'>Ã·</span><span class='Value'>k</span><span class='Paren'>)</span></code> and the quotient is <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Number'>1</span><span class='Function'>-</span><span class='Value'>o</span><span class='Function'>Ã·</span><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>q</span></code>, or <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Number'>1</span><span class='Function'>-</span><span class='Value'>o</span><span class='Function'>Ã·</span><span class='Value'>p</span><span class='Function'>+</span><span class='Value'>o</span></code>. For this number to round up to <code><span class='Value'>k</span></code> it would have to be larger than <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Number'>1</span><span class='Function'>-Ã·</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>52</span></code>, but <code><span class='Value'>p</span><span class='Function'>+</span><span class='Value'>o</span></code> is less than <code><span class='Value'>p</span><span class='Function'>+</span><span class='Value'>q</span></code> which is much less than <code><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>52</span></code>, so the rounded division result is less than <code><span class='Value'>k</span></code>, giving a floor of <code><span class='Value'>k</span><span class='Function'>-</span><span class='Number'>1</span></code>.</p>
<p>Furthermore, in this case, the division <code><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span></code> can be performed by a single multiplicationâ€”not by <code><span class='Function'>Ã·</span><span class='Value'>q</span></code>, which may be too small (49 is the first positive <code><span class='Value'>q</span></code> where it fails), but by a value slightly further from 0. Rounding the reciprocal away from 0 works, but in case this isn't possible, using either <code><span class='Value'>u</span><span class='Function'>Ã·</span><span class='Value'>q</span></code> or <code><span class='Value'>u</span><span class='Function'>Ã—Ã·</span><span class='Value'>q</span></code> with <code><span class='Value'>u</span><span class='Gets'>â†</span><span class='Number'>1</span><span class='Function'>+</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>Â¯52</span></code> is fine. This is true for the large-<code><span class='Value'>q</span></code> case because multiplying by <code><span class='Value'>u</span></code> won't bring <code><span class='Function'>|Ã·</span><span class='Value'>q</span></code> up to <code><span class='Number'>1</span><span class='Function'>Ã·</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>32</span></code>, as can easily be checked with <code><span class='Value'>q</span><span class='Gets'>â†</span><span class='Number'>1</span><span class='Function'>+</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>32</span></code>. And it's true for the small-<code><span class='Value'>q</span></code> case because <code><span class='Value'>p</span><span class='Function'>Ã—</span><span class='Value'>u</span><span class='Function'>Ã—Ã·</span><span class='Value'>q</span></code> is at most <code><span class='Paren'>(</span><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span><span class='Paren'>)</span><span class='Function'>Ã—</span><span class='Number'>1</span><span class='Function'>+</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>Â¯51</span></code> (being rather generous with the error term to account for any rounding). Now to avoid bad rounding <code><span class='Value'>p</span><span class='Function'>Ã·</span><span class='Value'>q</span></code> would have to be larger than <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Paren'>(</span><span class='Number'>1</span><span class='Function'>-Ã·</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>52</span><span class='Paren'>)</span><span class='Function'>Ã·</span><span class='Number'>1</span><span class='Function'>+</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>Â¯51</span></code>, which is greater than <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Number'>1</span><span class='Function'>-Ã·</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>50</span></code>, and it's still far away from this bound.</p>
<h2 id="power-and-logarithm"><a class="header" href="#power-and-logarithm">Power and logarithm</a></h2>
<p>The monadic exponential <code><span class='Function'>â‹†</span></code> and logarithm <code><span class='Function'>â‹†</span><span class='Modifier'>â¼</span></code> functions are well-known and hopefully have adequate implementations in math libraries. Power and logarithm with an arbitrary base present some additional concerns, as well as optimization opportunities when one argument is fixed.</p>
<p>Researchers associated with Inria <a href="https://hal.science/hal-01227877">propose</a> a logarithm that takes a 64-bit floating-point argument and returns a fixed-point value, scaled by <code><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>52</span></code>. This is a natural choice because the base-2 log of a float fits in [0,1024) by design, and it's much better at maintaining precision at the larger end of that range. The applications in BQN are to compute <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>a</span> <span class='Gets'>â†â†’</span> <span class='Paren'>(</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>a</span><span class='Paren'>)</span><span class='Function'>Ã·â‹†</span><span class='Modifier'>â¼</span><span class='Value'>b</span></code> and possibly <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Value'>a</span> <span class='Gets'>â†â†’</span> <span class='Function'>â‹†</span><span class='Value'>a</span><span class='Function'>Ã—â‹†</span><span class='Modifier'>â¼</span><span class='Value'>b</span></code> and <code><span class='Value'>a</span><span class='Function'>âˆš</span><span class='Value'>b</span> <span class='Gets'>â†â†’</span> <span class='Function'>â‹†</span><span class='Paren'>(</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>b</span><span class='Paren'>)</span><span class='Function'>Ã·</span><span class='Value'>a</span></code> with good precision; these formulas allow precomputing <code><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>b</span></code> if it's fixed, as is often the case.</p>
<h3 id="number-of-digits"><a class="header" href="#number-of-digits">Number of digits</a></h3>
<p>A common problem is to find the number of digits required to represent integer <code><span class='Value'>a</span></code> in integer base <code><span class='Value'>b</span></code>, <code><span class='Number'>1</span><span class='Function'>+âŒŠ</span><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>a</span></code>. This code is a lot less reliable than repeated division. As we'll see, even a correctly-rounded <code><span class='Function'>â‹†</span><span class='Modifier'>â¼</span></code> can overestimate the count when <code><span class='Value'>a</span></code> is somewhat above <code><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>48</span></code>, resulting in a leading 0 if the number is expanded with that many digits. With an imprecise logarithm, such as <code><span class='Value'>a</span><span class='Function'>Ã·</span><span class='Modifier2'>â—‹</span><span class='Paren'>(</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Paren'>)</span><span class='Value'>b</span></code> with correctly-rounded components, we can get a more severe issue: <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Value'>k</span></code> for integer <code><span class='Value'>k</span></code> can end up below <code><span class='Value'>k</span></code> and round down at small values like <code><span class='Function'>âŒŠ</span><span class='Number'>10</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Number'>1000</span></code>, clipping off the leading digit.</p>
<p>The best fix is to get the error of dyadic log under 1 ULP, which ensures the log of an integer will never round past an integer. However, it's also possible to correct the result of <code><span class='Value'>x</span><span class='Function'>Ã·</span><span class='Modifier2'>â—‹</span><span class='Paren'>(</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Paren'>)</span><span class='Value'>b</span></code> to fix near-integers, when <code><span class='Value'>x</span></code> is not large. The idea is this: the case we need to fix is that the true value of <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span></code> is on one side of an integer <code><span class='Value'>i</span></code>, but numeric error puts the computed value <code><span class='Value'>r</span><span class='Gets'>â†</span><span class='Value'>e</span><span class='Function'>+</span><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span></code> on the other side (or it should be equal but is computed unequal). In this case the computed value must be within <code><span class='Value'>e</span></code> of <code><span class='Value'>i</span></code>, <code><span class='Value'>e</span><span class='Function'>â‰¥|</span><span class='Value'>r</span><span class='Function'>-</span><span class='Value'>i</span></code>. And the true <code><span class='Paren'>(</span><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Paren'>)</span> <span class='Function'>-</span> <span class='Value'>i</span></code> must have the same sign as <code><span class='Value'>x</span> <span class='Function'>-</span> <span class='Value'>b</span><span class='Function'>â‹†</span><span class='Value'>i</span></code>, as <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Value'>ğ•©</span></code> is monotonically increasing; if <code><span class='Value'>r</span><span class='Function'>-</span><span class='Value'>i</span></code> differs then <code><span class='Function'>âŒŠ</span><span class='Number'>0.5</span><span class='Function'>+</span><span class='Value'>r</span></code> would be a more accurate result.</p>
<pre><span class='Function'>Log</span> <span class='Gets'>â†</span> <span class='Brace'>{</span><span class='Value'>b</span> <span class='Function'>ğ•Š</span> <span class='Value'>x</span><span class='Head'>:</span>
  <span class='Value'>r</span> <span class='Gets'>â†</span> <span class='Paren'>(</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Paren'>)</span> <span class='Function'>Ã·</span> <span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>b</span>  <span class='Comment'># Unadjusted result
</span>  <span class='Value'>u</span> <span class='Gets'>â†</span> <span class='Value'>r</span> <span class='Function'>Ã—</span> <span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>Â¯51</span>    <span class='Comment'># Max error, â‰¥2 ULP
</span>  <span class='Function'>D</span> <span class='Gets'>â†</span> <span class='Brace'>{</span><span class='Value'>ğ•©</span> <span class='Function'>-</span> <span class='Function'>âŒŠ</span><span class='Number'>0.5</span><span class='Function'>+</span><span class='Value'>ğ•©</span><span class='Brace'>}</span> <span class='Comment'># Distance from nearest int
</span>  <span class='Value'>dr</span> <span class='Gets'>â†</span> <span class='Function'>D</span> <span class='Value'>r</span>
  <span class='Value'>r</span> <span class='Function'>-</span> <span class='Value'>dr</span> <span class='Function'>Ã—</span> <span class='Paren'>(</span><span class='Value'>u</span><span class='Function'>â‰¥|</span><span class='Value'>dr</span><span class='Paren'>)</span> <span class='Function'>âˆ§</span> <span class='Value'>dr</span> <span class='Function'>â‰ </span><span class='Modifier2'>â—‹</span><span class='Function'>Ã—</span> <span class='Function'>D</span> <span class='Value'>x</span>
<span class='Brace'>}</span>
</pre>
<p>The above code corrects <code><span class='Value'>r</span></code> if it's within a certain relative error of an integer (with the conservative assumption that <code><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span></code> has a relative error of at most 0.75 ULP, and <code><span class='Function'>Ã·</span></code> is correctly rounded, we have <code><span class='Paren'>(</span><span class='Number'>2</span><span class='Function'>Ã—</span><span class='Number'>0.75</span><span class='Paren'>)</span><span class='Function'>+</span><span class='Number'>0.5</span></code> or 2 ULP), and the direction (-1, 0, or 1) from that integer is different from the direction to <code><span class='Value'>x</span></code> from the nearest integer to it. So it just assumes the nearest integer to <code><span class='Value'>x</span></code> is a power of <code><span class='Value'>b</span></code>! But testing <code><span class='Value'>dr</span></code> ensures this is true for <code><span class='Value'>x</span></code> up to a little past <code><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>44</span></code>, as we show in the next section. Past this (well, certainly past <code><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>46</span></code>) the implementer has to decide between correcting and possibly bringing the error up from 2 ULP to 4 ULP, or not correcting and allowing too-low results from <code><span class='Function'>âŒŠ</span><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>a</span></code>.</p>
<h4 id="logarithm-error-analysis"><a class="header" href="#logarithm-error-analysis">Logarithm error analysis</a></h4>
<p>To analyze the distance between adjacent values of <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>a</span></code> we'll look at ratios like <code><span class='Paren'>(</span><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Function'>+</span><span class='Number'>1</span><span class='Paren'>)</span><span class='Function'>Ã·</span><span class='Paren'>(</span><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Paren'>)</span></code>, since <code><span class='Value'>b</span></code> instantly drops out giving <code><span class='Paren'>(</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Function'>+</span><span class='Number'>1</span><span class='Paren'>)</span><span class='Function'>Ã·</span><span class='Paren'>(</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Paren'>)</span></code>. We can get some bounds on the logarithm <code><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span></code> using the fact that it's a concave function, meaning it curves downwards from its linear approximation at any point <code><span class='Value'>x</span></code>. So the value at <code><span class='Value'>x</span><span class='Function'>+</span><span class='Value'>k</span></code> is at most <code><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span></code> plus <code><span class='Value'>k</span></code> times the derivative <code><span class='Function'>Ã·</span><span class='Value'>x</span></code> at <code><span class='Value'>x</span></code> (alternatively, start with <code><span class='Paren'>(</span><span class='Number'>1</span><span class='Function'>+</span><span class='Value'>y</span><span class='Paren'>)</span> <span class='Function'>â‰¤</span> <span class='Function'>â‹†</span><span class='Value'>y</span></code> and substitute <code><span class='Value'>y</span> <span class='Gets'>â†</span> <span class='Paren'>(</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Function'>+</span><span class='Value'>k</span><span class='Paren'>)</span><span class='Function'>-â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span> <span class='Gets'>â†â†’</span> <span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Number'>1</span><span class='Function'>+</span><span class='Value'>k</span><span class='Function'>Ã·</span><span class='Value'>x</span></code>). Then we divide each through by <code><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span></code>:</p>
<pre><span class='Paren'>(</span><span class='Function'>Ã·</span><span class='Value'>x</span><span class='Paren'>)</span> <span class='Function'>â‰¤</span> <span class='Paren'>(</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Paren'>)</span> <span class='Function'>-</span> <span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Function'>-</span><span class='Number'>1</span>
<span class='Paren'>(</span><span class='Function'>Ã·</span><span class='Value'>x</span><span class='Function'>Ã—â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Paren'>)</span> <span class='Function'>â‰¤</span> <span class='Number'>1</span> <span class='Function'>-</span> <span class='Paren'>((</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Function'>-</span><span class='Number'>1</span><span class='Paren'>)</span> <span class='Function'>Ã·</span> <span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Paren'>)</span>

<span class='Paren'>(</span><span class='Function'>Ã·</span><span class='Value'>x</span><span class='Function'>+</span><span class='Number'>1</span><span class='Paren'>)</span> <span class='Function'>â‰¤</span> <span class='Paren'>(</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Function'>+</span><span class='Number'>1</span><span class='Paren'>)</span> <span class='Function'>-</span> <span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span>
<span class='Paren'>(</span><span class='Function'>Ã·</span><span class='Paren'>(</span><span class='Value'>x</span><span class='Function'>+</span><span class='Number'>1</span><span class='Paren'>)</span><span class='Function'>Ã—â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Paren'>)</span> <span class='Function'>â‰¤</span> <span class='Paren'>((</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Function'>+</span><span class='Number'>1</span><span class='Paren'>)</span> <span class='Function'>Ã·</span> <span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span><span class='Paren'>)</span> <span class='Function'>-</span> <span class='Number'>1</span>
</pre>
<p>So when might <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span></code> come within <code><span class='Value'>m</span></code> ULP of an integer <code><span class='Value'>i</span></code>? Setting <code><span class='Value'>u</span><span class='Gets'>â†</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>Â¯52</span></code> and <code><span class='Value'>xi</span> <span class='Gets'>â†</span> <span class='Value'>b</span><span class='Function'>â‹†</span><span class='Value'>i</span></code>, a ULP is at most <code><span class='Value'>i</span><span class='Function'>Ã—</span><span class='Value'>u</span></code>, and the distance from the true result is at least <code><span class='Value'>i</span><span class='Function'>Ã·</span><span class='Paren'>(</span><span class='Value'>x</span><span class='Function'>âŒˆ</span><span class='Value'>xi</span><span class='Paren'>)</span><span class='Function'>Ã—â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span></code>, giving the following inequality:</p>
<pre><span class='Paren'>(</span><span class='Value'>m</span><span class='Function'>Ã—</span><span class='Value'>i</span><span class='Function'>Ã—</span><span class='Value'>u</span><span class='Paren'>)</span> <span class='Function'>â‰¥</span> <span class='Value'>i</span><span class='Function'>Ã·</span><span class='Paren'>(</span><span class='Value'>x</span><span class='Function'>âŒˆ</span><span class='Value'>xi</span><span class='Paren'>)</span><span class='Function'>Ã—â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span>
<span class='Value'>m</span> <span class='Function'>â‰¥</span> <span class='Function'>Ã·</span><span class='Value'>u</span><span class='Function'>Ã—</span><span class='Paren'>(</span><span class='Value'>x</span><span class='Function'>âŒˆ</span><span class='Value'>xi</span><span class='Paren'>)</span><span class='Function'>Ã—â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span>
</pre>
<p>First we consider the case <code><span class='Value'>m</span><span class='Function'>=</span><span class='Number'>0.5</span></code> meaning that <code><span class='Value'>i</span></code> is the correctly-rounded result. The inequality is very close to exact, and for <code><span class='Value'>x</span> <span class='Function'>=</span> <span class='Number'>1</span><span class='Function'>+</span><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Value'>i</span></code> it correctly predicts the smallest <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Value'>i</span></code> that causes a problem, <code><span class='Number'>271029746912941</span><span class='Function'>â‹†</span><span class='Number'>1</span></code> (so, the long number is <code><span class='Value'>b</span></code> such that <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>b</span><span class='Function'>+</span><span class='Number'>1</span></code> rounds to exactly 1 instead of larger). When adding one, power-of-two <code><span class='Value'>i</span></code> has the smallest error tolerance, but for <code><span class='Value'>x</span> <span class='Function'>=</span> <span class='Number'>1</span><span class='Function'>-</span><span class='Modifier'>Ëœ</span><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Value'>i</span></code>, it's largest instead, and one plus a power of two is smallest; a larger power further decreases the tolerance but makes possible <code><span class='Value'>x</span></code> values sparser. With <code><span class='Value'>i</span><span class='Function'>â‰¥</span><span class='Number'>3</span></code> the relevant range is not too hard to search exhaustively, and <code><span class='Number'>41</span><span class='Function'>â‹†</span><span class='Number'>9</span></code> is the smallest <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Value'>i</span></code> such that <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Number'>1</span><span class='Function'>-</span><span class='Modifier'>Ëœ</span><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Value'>i</span></code> rounds to <code><span class='Value'>i</span></code>. These two values of <code><span class='Value'>x</span></code> are about <code><span class='Number'>0.96</span><span class='Function'>Ã—</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>48</span></code> and <code><span class='Number'>1.16</span><span class='Function'>Ã—</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>48</span></code>, which unfortunately is not all that large.</p>
<p>Next we look at when the 2 ULP threshold for our corrected logarithm can fail. The problem is when <code><span class='Value'>x</span></code> differs from <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Value'>i</span></code> by 0.5 or more, and the computed <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span></code> comes within 2 ULP of <code><span class='Value'>i</span></code>â€”so, the true <code><span class='Value'>b</span><span class='Function'>â‹†</span><span class='Modifier'>â¼</span><span class='Value'>x</span></code> is within 4ULP of <code><span class='Value'>i</span></code>. It turns out we're looking for the equivalent of <code><span class='Value'>m</span><span class='Function'>=</span><span class='Number'>8</span></code>, which is guaranteed by <code><span class='Value'>x</span><span class='Function'>â‰¤</span><span class='Number'>1.04</span><span class='Function'>Ã—</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>44</span></code>. We can improve this a bit by replacing the constant bound <code><span class='Value'>dr</span></code> in <code><span class='Value'>u</span><span class='Function'>â‰¥|</span><span class='Value'>dr</span></code> with the piecewise linear <code><span class='Value'>dr</span> <span class='Function'>+</span> <span class='Paren'>(</span><span class='Function'>D</span> <span class='Value'>x</span><span class='Paren'>)</span> <span class='Function'>Ã·</span> <span class='Value'>x</span><span class='Function'>âŒˆâŒŠ</span><span class='Number'>0.5</span><span class='Function'>+</span><span class='Value'>x</span></code>, which works to <code><span class='Value'>m</span><span class='Function'>=</span><span class='Number'>4</span></code>, <code><span class='Value'>x</span><span class='Function'>â‰¤</span><span class='Number'>1.02</span><span class='Function'>Ã—</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>45</span></code> (while this linear approximation is also a more accurate correction for <code><span class='Value'>r</span></code> below that <code><span class='Value'>x</span></code> threshold, it must not be used above it, as this will incorrectly cross integer boundaries). Past <code><span class='Value'>m</span><span class='Function'>=</span><span class='Number'>2</span></code> at <code><span class='Value'>x</span><span class='Function'>â‰¤</span><span class='Number'>1.00</span><span class='Function'>Ã—</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Number'>46</span></code> we are definitely done for, as the log of an integer non-power might result in an integer: we can't distinguish this case from a power of <code><span class='Value'>b</span></code> without actually knowing some powers of <code><span class='Value'>b</span></code>!</p>
<h2 id="table-and-leading-axis"><a class="header" href="#table-and-leading-axis">Table and leading-axis</a></h2>
<p>While they can be viewed as special cases of the nested rank discussed in the next section, Table and leading-axis extension are easier to analyze, and are the most common forms. To avoid some tedium with shapes, we'll consider a result shape <code><span class='Value'>m</span><span class='Ligature'>â€¿</span><span class='Value'>n</span></code>, by assuming <code><span class='Value'>ğ•¨</span></code> is a list with length <code><span class='Value'>m</span></code>, and <code><span class='Value'>ğ•©</span></code> is either a list with length <code><span class='Value'>n</span></code>, for Table, or a shape <code><span class='Value'>m</span><span class='Ligature'>â€¿</span><span class='Value'>n</span></code> array, for leading-axis.</p>
<p>With these definitions, <code><span class='Function'>â¥Š</span><span class='Value'>ğ•¨</span><span class='Function'>ğ”½</span><span class='Modifier'>âŒœ</span><span class='Value'>ğ•©</span></code> is <code><span class='Paren'>(</span><span class='Value'>n</span><span class='Function'>/</span><span class='Value'>ğ•¨</span><span class='Paren'>)</span> <span class='Function'>ğ”½</span> <span class='Paren'>(</span><span class='Value'>m</span><span class='Function'>Ã—</span><span class='Value'>n</span><span class='Paren'>)</span><span class='Function'>â¥Š</span><span class='Value'>ğ•©</span></code>, which can make use of a fast <a href="replicate.html#constant-replicate">constant replicate</a>. It's better not to compute these expanded arguments in full, and instead choose a unit size <code><span class='Value'>k</span><span class='Function'>â‰¤</span><span class='Value'>m</span></code> so that <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>n</span></code> is small but not too small. Then pre-compute <code><span class='Paren'>(</span><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>n</span><span class='Paren'>)</span><span class='Function'>â¥Š</span><span class='Value'>ğ•©</span></code>, and work on <code><span class='Value'>ğ•¨</span></code> in chunks of length <code><span class='Value'>k</span></code>. For example, expand each chunk with <code><span class='Value'>k</span><span class='Function'>/</span></code> into the result, then apply the function in-place with the saved <code><span class='Paren'>(</span><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>n</span><span class='Paren'>)</span><span class='Function'>â¥Š</span><span class='Value'>ğ•©</span></code>. Of course, if the optimal <code><span class='Value'>k</span></code> is 1, then a scalar-vector operation into the result works just as well.</p>
<p>Leading-axis extension is similar: <code><span class='Function'>â¥Š</span><span class='Value'>ğ•¨</span><span class='Function'>ğ”½</span><span class='Value'>ğ•©</span></code> is <code><span class='Paren'>(</span><span class='Value'>n</span><span class='Function'>/</span><span class='Value'>ğ•¨</span><span class='Paren'>)</span> <span class='Function'>ğ”½</span> <span class='Function'>â¥Š</span><span class='Value'>ğ•©</span></code>, so the same strategy works, with minor modifications. Instead of <code><span class='Paren'>(</span><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>n</span><span class='Paren'>)</span><span class='Function'>â¥Š</span><span class='Value'>ğ•©</span></code>, a new chunk of length <code><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>n</span></code> from <code><span class='Value'>ğ•©</span></code> is needed at each step. And if <code><span class='Value'>k</span></code> is 1, the base case is vector-vector instead of scalar-vector.</p>
<p>Table also admits faster overflow checking for well-behaved functions like <code><span class='Function'>+-Â¬Ã—</span></code>: all combinations of <code><span class='Value'>ğ•¨</span></code> and <code><span class='Value'>ğ•©</span></code> will be used, so there's an overflow exactly if the extreme values would overflow. The range of <code><span class='Value'>ğ•¨</span><span class='Function'>+</span><span class='Modifier'>âŒœ</span><span class='Value'>ğ•©</span></code> is <code><span class='Value'>ğ•¨</span><span class='Function'>+</span><span class='Modifier2'>â—‹</span><span class='Paren'>(</span><span class='Function'>âŒŠ</span><span class='Modifier'>Â´</span><span class='Paren'>)</span><span class='Value'>ğ•©</span></code> to <code><span class='Value'>ğ•¨</span><span class='Function'>+</span><span class='Modifier2'>â—‹</span><span class='Paren'>(</span><span class='Function'>âŒˆ</span><span class='Modifier'>Â´</span><span class='Paren'>)</span><span class='Value'>ğ•©</span></code>, and similarly for <code><span class='Value'>ğ•¨</span><span class='Function'>-</span><span class='Modifier'>âŒœ</span><span class='Value'>ğ•©</span></code> but swapping the max and min of <code><span class='Value'>ğ•©</span></code>. For <code><span class='Value'>ğ•¨</span><span class='Function'>Ã—</span><span class='Modifier'>âŒœ</span><span class='Value'>ğ•©</span></code> all four combinations of min and max need to be checked.</p>
<h2 id="ranked-arithmetic"><a class="header" href="#ranked-arithmetic">Ranked arithmetic</a></h2>
<p>Dyadic arithmetic can be applied to various combinations of axes with leading-axis extension, Table (<code><span class='Modifier'>âŒœ</span></code>), and the Cells (<code><span class='Modifier'>Ë˜</span></code>) and Rank (<code><span class='Modifier2'>â‰</span></code>) modifiers. Cells is of course <code><span class='Modifier2'>â‰</span><span class='Number'>Â¯1</span></code>, and Table is <code><span class='Modifier2'>â‰</span><span class='Number'>0</span><span class='Ligature'>â€¿</span><span class='Number'>âˆ</span></code>, so the general case is arithmetic applied with the Rank operator any number of times.</p>
<p>An application of Rank is best described in terms of its frame ranks, not cell ranks. If <code><span class='Value'>a</span></code> and <code><span class='Value'>b</span></code> are these ranks, then there are <code><span class='Value'>a</span><span class='Function'>âŒŠ</span><span class='Value'>b</span></code> shared frame axes and <code><span class='Value'>a</span><span class='Paren'>(</span><span class='Function'>âŒˆ-âŒŠ</span><span class='Paren'>)</span><span class='Value'>b</span></code> non-shared axes from the argument with the higher-rank frame. Repeating on rank applications from the outside in, with a final rank 0 inherent in the arithmetic itself, the two sets of argument axes are partitioned into sets of shared and non-shared axes. For example consider <code><span class='Function'>+</span><span class='Modifier'>âŒœË˜</span><span class='Modifier2'>â‰</span><span class='Number'>4</span><span class='Ligature'>â€¿</span><span class='Number'>3</span></code> on arguments of ranks 6 and 8.</p>
<ul>
<li>The <code><span class='Modifier2'>â‰</span><span class='Number'>4</span><span class='Ligature'>â€¿</span><span class='Number'>3</span></code> implies frame ranks of 6-4=2 and 8-3=5. This gives 2 shared axes (label 0 below), then 3 non-shared axes from <code><span class='Value'>ğ•©</span></code> (label 1).</li>
<li>The <code><span class='Modifier'>Ë˜</span></code> takes a shared axis (label 2).</li>
<li>The <code><span class='Modifier'>âŒœ</span></code> takes all axes from <code><span class='Value'>ğ•¨</span></code> non-shared (3), then all from <code><span class='Value'>ğ•©</span></code> (label 4).</li>
</ul>
<pre>  <span class='Number'>0</span> <span class='Number'>1</span> <span class='Number'>2</span> <span class='Number'>3</span> <span class='Number'>4</span> <span class='Number'>5</span> <span class='Number'>6</span> <span class='Number'>7</span>
<span class='Value'>ğ•¨</span> <span class='Number'>0</span> <span class='Number'>0</span> <span class='Number'>2</span> <span class='Number'>3</span> <span class='Number'>3</span> <span class='Number'>3</span> 
<span class='Value'>ğ•©</span> <span class='Number'>0</span> <span class='Number'>0</span> <span class='Number'>1</span> <span class='Number'>1</span> <span class='Number'>1</span> <span class='Number'>2</span> <span class='Number'>4</span> <span class='Number'>4</span>
</pre>
<p>An axis set behaves like a single axis, and any adjacent axis sets of the same type (for example, non-shared from <code><span class='Value'>ğ•¨</span></code>) can be combined. Length-1 axes can be ignored as well, so a simplification pass <a href="transpose.html#axis-simplification">like transpose</a> might make sense.</p>
<p>Then the implementation needs to expand this mapping quickly. As usual, long axes are easy and short axes are harder. It's best to take enough result axes so that a cell is not too small, then use a slow outer loop (for example, based on index lists) to call that inner loop. One result axis can be split in blocks if the cell size would be too small without it, but too big with it.</p>
<p>Because a result cell should be much larger than a cache line, there's no need for the outer loop to traverse these cells in orderâ€”that is, the axes can be moved around to iterate in a transposed order. An easy way to do this is to represent each result axis with a length, stride in the result, and stride in both arguments; axes represented this way can be freely rearranged. It's best to iterate over shared axes first (outermost), then non-shared axes, because a non-shared axis means cells in the other argument are repeated, and if it's placed last then no other cells will be used between those repeated accesses. If both arguments have non-shared axes then a blocked order that keeps the repeated cells in cache might be best, but it's complicated to implement.</p>
<h3 id="base-cases"><a class="header" href="#base-cases">Base cases</a></h3>
<p>The scalar-vector, vector-vector cases work as base cases on one axis, and Table and leading-axis are two two-axis cases. There's also a flipped Table <code><span class='Modifier'>ËœâŒœËœ</span></code> and a trailing-axis case like <code><span class='Modifier2'>â‰</span><span class='Number'>1</span></code>. Representing each result axis with &quot;w&quot; if it comes from <code><span class='Value'>ğ•¨</span></code> only, &quot;x&quot; for <code><span class='Value'>ğ•©</span></code> only, and &quot;wx&quot; for shared, we can organize these cases.</p>
<ul>
<li>w, x (scalar-vector)</li>
<li>wx (vector-vector)</li>
<li>w-x (Table)</li>
<li>x-w (flipped Table)</li>
<li>wx-x, wx-w (leading)</li>
<li>w-wx, x-wx (trailing)</li>
</ul>
<p>That's six two-axis combinations; the remaining three possibilities w-w, x-x, and wx-wx are simplifiable. Trailing-axis agreement takes half of Table like leading-axis agreement, but it's the reshaping half instead of replicate.</p>
<p>The general case is to expand the arguments with Replicate along various axes so that they have the same shape as the result, and then use vector-vector arithmetic. More concretely, insert a length-1 axis into the argument for each non-shared axis in the other argument. Then replicate these axes to to required length. This can be done one axis at a time from the bottom up, or by constructing an array of indices and applying them at once, and probably other ways as well. See also <a href="replicate.html#higher-ranks">high-rank Replicate</a>.</p>
