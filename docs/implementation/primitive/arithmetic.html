<head>
  <link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../../style.css" rel="stylesheet"/>
  <title>BQN: Implementation of arithmetic</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../../index.html">BQN</a> / <a href="../index.html">implementation</a> / <a href="index.html">primitive</a></div>
<h1 id="implementation-of-arithmetic"><a class="header" href="#implementation-of-arithmetic">Implementation of arithmetic</a></h1>
<p>The dyadic arithmetic functions are <code><span class='Function'>+-×÷⋆√⌊⌈|¬∧∨&lt;&gt;≠=≤≥</span></code>. There are also monadic arithmetic functions, but they're mostly easy to optimize.</p>
<p>Arithmetic with Table, leading axis extension, and Rank is also covered <a href="#table-and-leading-axis">below</a>.</p>
<h2 id="negative-zero"><a class="header" href="#negative-zero">Negative zero</a></h2>
<p>IEEE defines the float value -0. But to make sure integer-valued floats can be consistently optimized as integers, it's best to treat it identically to 0 (this is much easier than trying to not produce -0s, as a negative number times 0 is -0). To convert a number to 0 if it's -0, just add 0. This needs to be done in <code><span class='Function'>÷</span></code> for <code><span class='Value'>𝕩</span></code>, in <code><span class='Function'>⋆</span></code> for <code><span class='Value'>𝕨</span></code>, and in <code><span class='Function'>√</span></code> for both arguments if it's defined separately. Also in <code><span class='Value'>•math.</span><span class='Function'>Atan2</span></code> for both arguments if defined.</p>
<h2 id="boolean-functions"><a class="header" href="#boolean-functions">Boolean functions</a></h2>
<p>Many arithmetic functions give boolean results when both arguments are boolean. Because there are only 16 possible functions like this, they overlap a lot. Here's a categorization:</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=ZiDihpAg4oin4oC/4oio4oC/POKAvz7igL/iiaDigL894oC/4omk4oC/4oml4oC/K+KAvy3igL/Dl+KAv8O34oC/4ouG4oC/4oia4oC/4oyK4oC/4oyI4oC/fOKAv8KsCgpidCDihpAge+KlivCdlY/ijJzLnOKGlTJ9wqhmCuKIp+KMvijijL3CqOKMvijiio/LmCkpIGJ0ICjijbfiiJjiiqPiiY3LmOKKkOKKuOKKlCnil4soKOKIp8K04oiY4oiK4p+cKOKGlTIpwqhidCniirgvKSBm">↗️</a><pre>    <span class='Value'>f</span> <span class='Gets'>←</span> <span class='Function'>∧</span><span class='Ligature'>‿</span><span class='Function'>∨</span><span class='Ligature'>‿</span><span class='Function'>&lt;</span><span class='Ligature'>‿</span><span class='Function'>&gt;</span><span class='Ligature'>‿</span><span class='Function'>≠</span><span class='Ligature'>‿</span><span class='Function'>=</span><span class='Ligature'>‿</span><span class='Function'>≤</span><span class='Ligature'>‿</span><span class='Function'>≥</span><span class='Ligature'>‿</span><span class='Function'>+</span><span class='Ligature'>‿</span><span class='Function'>-</span><span class='Ligature'>‿</span><span class='Function'>×</span><span class='Ligature'>‿</span><span class='Function'>÷</span><span class='Ligature'>‿</span><span class='Function'>⋆</span><span class='Ligature'>‿</span><span class='Function'>√</span><span class='Ligature'>‿</span><span class='Function'>⌊</span><span class='Ligature'>‿</span><span class='Function'>⌈</span><span class='Ligature'>‿</span><span class='Function'>|</span><span class='Ligature'>‿</span><span class='Function'>¬</span>

    <span class='Value'>bt</span> <span class='Gets'>←</span> <span class='Brace'>{</span><span class='Function'>⥊𝕏</span><span class='Modifier'>⌜˜</span><span class='Function'>↕</span><span class='Number'>2</span><span class='Brace'>}</span><span class='Modifier'>¨</span><span class='Value'>f</span>
    <span class='Function'>∧</span><span class='Modifier2'>⌾</span><span class='Paren'>(</span><span class='Function'>⌽</span><span class='Modifier'>¨</span><span class='Modifier2'>⌾</span><span class='Paren'>(</span><span class='Function'>⊏</span><span class='Modifier'>˘</span><span class='Paren'>))</span> <span class='Value'>bt</span> <span class='Paren'>(</span><span class='Function'>⍷</span><span class='Modifier2'>∘</span><span class='Function'>⊣≍</span><span class='Modifier'>˘</span><span class='Function'>⊐</span><span class='Modifier2'>⊸</span><span class='Function'>⊔</span><span class='Paren'>)</span><span class='Modifier2'>○</span><span class='Paren'>((</span><span class='Function'>∧</span><span class='Modifier'>´</span><span class='Modifier2'>∘</span><span class='Function'>∊</span><span class='Modifier2'>⟜</span><span class='Paren'>(</span><span class='Function'>↕</span><span class='Number'>2</span><span class='Paren'>)</span><span class='Modifier'>¨</span><span class='Value'>bt</span><span class='Paren'>)</span><span class='Modifier2'>⊸</span><span class='Function'>/</span><span class='Paren'>)</span> <span class='Value'>f</span>
┌─                       
╵ ⟨ 0 1 0 0 ⟩ ⟨ < ⟩      
  ⟨ 0 0 1 0 ⟩ ⟨ > ⟩      
  ⟨ 0 1 1 0 ⟩ ⟨ ≠ ⟩      
  ⟨ 0 0 0 1 ⟩ ⟨ ∧ × ⌊ ⟩  
  ⟨ 1 0 0 1 ⟩ ⟨ = ⟩      
  ⟨ 0 1 0 1 ⟩ ⟨ √ ⟩      
  ⟨ 1 1 0 1 ⟩ ⟨ ≤ ⟩      
  ⟨ 1 0 1 1 ⟩ ⟨ ≥ ⋆ ⟩    
  ⟨ 0 1 1 1 ⟩ ⟨ ∨ ⌈ ⟩    
                        ┘
</pre>
<p>Some functions have fast implementations when one argument is boolean. The only ones that really matter are <code><span class='Function'>×</span></code>/<code><span class='Function'>∧</span></code>, which can be implemented with a bitmask, and <code><span class='Function'>∨</span></code>, which changes the other argument to 1 when the boolean argument is 1 and otherwise leaves it alone. <code><span class='Function'>⋆</span></code> is <code><span class='Function'>∨</span><span class='Modifier2'>⟜</span><span class='Function'>¬</span></code> when <code><span class='Value'>𝕩</span></code> is boolean.</p>
<p>A function of an atom and a boolean array, or a monadic function on a boolean array, can be implemented by a lookup performed with (preferably SIMD) bitmasking.</p>
<h2 id="strength-reductions"><a class="header" href="#strength-reductions">Strength reductions</a></h2>
<h3 id="trivial-cases"><a class="header" href="#trivial-cases">Trivial cases</a></h3>
<p>Several cases where either one argument is an atom, or both arguments match, have a trivial result. Either the result value is constant, or it matches the argument.</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Constant</th>
<th>Identity</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>+</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>a</span><span class='Function'>-</span><span class='Value'>a</span></code></td>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>-</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>a</span><span class='Function'>¬</span><span class='Value'>a</span></code></td>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>¬</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>×</span><span class='Number'>0</span></code>*</td>
<td><code><span class='Value'>a</span><span class='Function'>×</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>∨</span><span class='Number'>1</span></code></td>
<td><code><span class='Value'>a</span><span class='Function'>∨</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>a</span><span class='Function'>÷</span><span class='Value'>a</span></code>*</td>
<td><code><span class='Number'>0</span><span class='Function'>÷</span><span class='Value'>a</span></code>*</td>
<td><code><span class='Value'>a</span><span class='Function'>÷</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>⋆</span><span class='Number'>0</span></code>, <code><span class='Number'>1</span><span class='Function'>⋆</span><span class='Value'>a</span></code></td>
<td><code><span class='Value'>a</span><span class='Function'>⋆</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td></td>
<td><code><span class='Number'>¯∞</span><span class='Function'>⌊</span><span class='Value'>a</span></code>, <code><span class='Number'>∞</span><span class='Function'>⌈</span><span class='Value'>a</span></code></td>
<td><code><span class='Number'>¯∞</span><span class='Function'>⌈</span><span class='Value'>a</span></code>, <code><span class='Number'>∞</span><span class='Function'>⌊</span><span class='Value'>a</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>a</span><span class='Function'>&gt;</span><span class='Value'>a</span></code> etc.</td>
<td></td>
<td><code><span class='Value'>a</span><span class='Function'>⌊</span><span class='Value'>a</span></code>, <code><span class='Value'>a</span><span class='Function'>⌈</span><span class='Value'>a</span></code></td>
</tr>
</tbody>
</table>
<p>None of the constant column entries work for NaNs, except <code><span class='Value'>a</span><span class='Function'>⋆</span><span class='Number'>0</span></code> and <code><span class='Number'>1</span><span class='Function'>⋆</span><span class='Value'>a</span></code> which really are always 1. Starred entries have some values of <code><span class='Value'>a</span></code> that result in NaN instead of the expected constant: <code><span class='Number'>0</span></code> for division and <code><span class='Number'>∞</span></code> for multiplication. This means that constant-result <code><span class='Function'>÷</span></code> always requires checking for NaN while the other entries work for integers without a check.</p>
<h3 id="division-and-modulus"><a class="header" href="#division-and-modulus">Division and modulus</a></h3>
<p>Division, integer division, and Modulus by an atom (<code><span class='Value'>a</span><span class='Function'>÷</span><span class='Value'>n</span></code>, <code><span class='Value'>a</span><span class='Function'>⌊</span><span class='Modifier2'>∘</span><span class='Function'>÷</span><span class='Value'>n</span></code>, <code><span class='Value'>n</span><span class='Function'>|</span><span class='Value'>a</span></code>) are subject to many optimizations.</p>
<ul>
<li>Floating-point with FMA: <a href="http://marc-b-reynolds.github.io/math/2019/03/12/FpDiv.html">this page</a> gives a slightly slower method that works for all divisors and a faster one that can be proven to work on over half of divisors.</li>
<li>Integer division: see <a href="https://github.com/ridiculousfish/libdivide">libdivide</a>. Most important is a mask for power-of-two <code><span class='Value'>n</span></code>. For smaller integer types, using SIMD code with 32-bit floats is also fast: see below.</li>
</ul>
<h4 id="integer-division-with-floats"><a class="header" href="#integer-division-with-floats">Integer division with floats</a></h4>
<p>If <code><span class='Value'>p</span></code> and <code><span class='Value'>q</span></code> are integers and <code><span class='Value'>p</span></code> is small enough, then the floor division <code><span class='Function'>⌊</span><span class='Value'>p</span><span class='Function'>÷</span><span class='Value'>q</span></code> gives an exact result. This isn't always the case for floats: for example <code><span class='Number'>1</span> <span class='Function'>⌊</span><span class='Modifier2'>∘</span><span class='Function'>÷</span> <span class='Paren'>(</span><span class='Function'>÷</span><span class='Number'>9</span><span class='Paren'>)</span><span class='Function'>+</span><span class='Number'>1e¯17</span></code> rounds up to 9 when an exact floor-divide would round down to 8. It means that <code><span class='Value'>q</span><span class='Function'>|</span><span class='Value'>p</span></code> is exactly <code><span class='Value'>p</span><span class='Function'>-</span><span class='Value'>q</span><span class='Function'>×⌊</span><span class='Value'>p</span><span class='Function'>÷</span><span class='Value'>q</span></code>, a faster computation.</p>
<p>In particular, if <code><span class='Value'>p</span></code> is a 16-bit or smaller integer and <code><span class='Value'>q</span></code> is any integer, then the floor division <code><span class='Function'>⌊</span><span class='Value'>p</span><span class='Function'>÷</span><span class='Value'>q</span></code> and modulus <code><span class='Value'>q</span><span class='Function'>|</span><span class='Value'>p</span></code> can be computed exactly in single (32-bit float) precision. If <code><span class='Value'>p</span></code> is a 32-bit integer these can be computed exactly in double precision.</p>
<p>We will prove the case with 32-bit <code><span class='Value'>p</span></code> in double precision. If <code><span class='Value'>q</span></code> is large, say it has absolute value greater than <code><span class='Number'>2</span><span class='Function'>⋆</span><span class='Number'>32</span></code>, then <code><span class='Paren'>(</span><span class='Function'>|</span><span class='Value'>p</span><span class='Function'>÷</span><span class='Value'>q</span><span class='Paren'>)</span><span class='Function'>&lt;</span><span class='Number'>1</span></code>, meaning the correct result is <code><span class='Number'>¯1</span></code> if it's negative and <code><span class='Number'>0</span></code> otherwise. If <code><span class='Value'>p</span></code> is nonzero, then <code><span class='Paren'>(</span><span class='Function'>|</span><span class='Value'>p</span><span class='Function'>÷</span><span class='Value'>q</span><span class='Paren'>)</span> <span class='Function'>&gt;</span> <span class='Function'>|÷</span><span class='Value'>q</span></code>, which is greater than the smallest subnormal for any <code><span class='Value'>q</span></code>, and so the division won't round up to 0. So suppose <code><span class='Value'>q</span></code> is small. If <code><span class='Value'>p</span></code> is a multiple of <code><span class='Value'>q</span></code>, say <code><span class='Value'>p</span><span class='Function'>=</span><span class='Value'>k</span><span class='Function'>×</span><span class='Value'>q</span></code>, then <code><span class='Value'>k</span><span class='Function'>≤</span><span class='Modifier2'>○</span><span class='Function'>|</span><span class='Value'>p</span></code> so <code><span class='Value'>k</span></code> is exactly representable as a double and the division is exact. If <code><span class='Value'>p</span></code> is not an exact multiple, say <code><span class='Value'>p</span><span class='Function'>=</span><span class='Paren'>(</span><span class='Value'>k</span><span class='Function'>×</span><span class='Value'>q</span><span class='Paren'>)</span><span class='Function'>-</span><span class='Value'>o</span></code> with nonzero <code><span class='Value'>o</span><span class='Function'>&lt;</span><span class='Value'>q</span></code>, then write it as <code><span class='Value'>k</span><span class='Function'>×</span><span class='Paren'>(</span><span class='Value'>q</span><span class='Function'>-</span><span class='Value'>o</span><span class='Function'>÷</span><span class='Value'>k</span><span class='Paren'>)</span></code> and the quotient is <code><span class='Value'>k</span><span class='Function'>×</span><span class='Number'>1</span><span class='Function'>-</span><span class='Value'>o</span><span class='Function'>÷</span><span class='Value'>k</span><span class='Function'>×</span><span class='Value'>q</span></code>, or <code><span class='Value'>k</span><span class='Function'>×</span><span class='Number'>1</span><span class='Function'>-</span><span class='Value'>o</span><span class='Function'>÷</span><span class='Value'>p</span><span class='Function'>+</span><span class='Value'>o</span></code>. For this number to round up to <code><span class='Value'>k</span></code> it would have to be larger than <code><span class='Value'>k</span><span class='Function'>×</span><span class='Number'>1</span><span class='Function'>-÷</span><span class='Number'>2</span><span class='Function'>⋆</span><span class='Number'>52</span></code>, but <code><span class='Value'>p</span><span class='Function'>+</span><span class='Value'>o</span></code> is less than <code><span class='Value'>p</span><span class='Function'>+</span><span class='Value'>q</span></code> which is much less than <code><span class='Number'>2</span><span class='Function'>⋆</span><span class='Number'>52</span></code>, so the rounded division result is less than <code><span class='Value'>k</span></code>, giving a floor of <code><span class='Value'>k</span><span class='Function'>-</span><span class='Number'>1</span></code>.</p>
<h2 id="table-and-leading-axis"><a class="header" href="#table-and-leading-axis">Table and leading-axis</a></h2>
<p>While they can be viewed as special cases of the nested rank discussed in the next section, Table and leading-axis extension are easier to analyze, and are the most common forms. To avoid some tedium with shapes, we'll consider a result shape <code><span class='Value'>m</span><span class='Ligature'>‿</span><span class='Value'>n</span></code>, by assuming <code><span class='Value'>𝕨</span></code> is a list with length <code><span class='Value'>m</span></code>, and <code><span class='Value'>𝕩</span></code> is either a list with length <code><span class='Value'>n</span></code>, for Table, or a shape <code><span class='Value'>m</span><span class='Ligature'>‿</span><span class='Value'>n</span></code> array, for leading-axis.</p>
<p>With these definitions, <code><span class='Function'>⥊</span><span class='Value'>𝕨</span><span class='Function'>𝔽</span><span class='Modifier'>⌜</span><span class='Value'>𝕩</span></code> is <code><span class='Paren'>(</span><span class='Value'>n</span><span class='Function'>/</span><span class='Value'>𝕨</span><span class='Paren'>)</span> <span class='Function'>𝔽</span> <span class='Paren'>(</span><span class='Value'>m</span><span class='Function'>×</span><span class='Value'>n</span><span class='Paren'>)</span><span class='Function'>⥊</span><span class='Value'>𝕩</span></code>, which can make use of a fast <a href="replicate.html#constant-replicate">constant replicate</a>. An ideal Table implementation is not actually to compute these expanded arguments in full, but to pick a unit size <code><span class='Value'>k</span><span class='Function'>≤</span><span class='Value'>m</span></code> so that <code><span class='Value'>k</span><span class='Function'>×</span><span class='Value'>n</span></code> is small but not too small. Then pre-compute <code><span class='Paren'>(</span><span class='Value'>k</span><span class='Function'>×</span><span class='Value'>n</span><span class='Paren'>)</span><span class='Function'>⥊</span><span class='Value'>𝕩</span></code>, and work on <code><span class='Value'>𝕨</span></code> in chunks of length <code><span class='Value'>k</span></code>. For example, expand each chunk with <code><span class='Value'>k</span><span class='Function'>/</span></code> into the result, then apply the function in-place with the saved <code><span class='Paren'>(</span><span class='Value'>k</span><span class='Function'>×</span><span class='Value'>n</span><span class='Paren'>)</span><span class='Function'>⥊</span><span class='Value'>𝕩</span></code>. Of course, if the ideal <code><span class='Value'>k</span></code> is 1, then a scalar-vector operation into the result works just as well.</p>
<p>Leading-axis extension is similar: <code><span class='Function'>⥊</span><span class='Value'>𝕨</span><span class='Function'>𝔽</span><span class='Value'>𝕩</span></code> is <code><span class='Paren'>(</span><span class='Value'>n</span><span class='Function'>/</span><span class='Value'>𝕨</span><span class='Paren'>)</span> <span class='Function'>𝔽</span> <span class='Function'>⥊</span><span class='Value'>𝕩</span></code>, so the same strategy works, with minor modifications. Instead of <code><span class='Paren'>(</span><span class='Value'>k</span><span class='Function'>×</span><span class='Value'>n</span><span class='Paren'>)</span><span class='Function'>⥊</span><span class='Value'>𝕩</span></code>, a new chunk of length <code><span class='Value'>k</span><span class='Function'>×</span><span class='Value'>n</span></code> from <code><span class='Value'>𝕩</span></code> is needed at each step. And if <code><span class='Value'>k</span></code> is 1, the base case is vector-vector instead of scalar-vector.</p>
<p>Table also admits faster overflow checking for well-behaved functions like <code><span class='Function'>+-¬×</span></code>: all combinations of <code><span class='Value'>𝕨</span></code> and <code><span class='Value'>𝕩</span></code> will be used, so there's an overflow exactly if the extreme values would overflow. The range of <code><span class='Value'>𝕨</span><span class='Function'>+</span><span class='Modifier'>⌜</span><span class='Value'>𝕩</span></code> is <code><span class='Value'>𝕨</span><span class='Function'>+</span><span class='Modifier2'>○</span><span class='Paren'>(</span><span class='Function'>⌊</span><span class='Modifier'>´</span><span class='Paren'>)</span><span class='Value'>𝕩</span></code> to <code><span class='Value'>𝕨</span><span class='Function'>+</span><span class='Modifier2'>○</span><span class='Paren'>(</span><span class='Function'>⌈</span><span class='Modifier'>´</span><span class='Paren'>)</span><span class='Value'>𝕩</span></code>, and similarly for <code><span class='Value'>𝕨</span><span class='Function'>-</span><span class='Modifier'>⌜</span><span class='Value'>𝕩</span></code> but swapping the max and min of <code><span class='Value'>𝕩</span></code>. For <code><span class='Value'>𝕨</span><span class='Function'>×</span><span class='Modifier'>⌜</span><span class='Value'>𝕩</span></code> all four combinations of min and max need to be checked.</p>
<h2 id="ranked-arithmetic"><a class="header" href="#ranked-arithmetic">Ranked arithmetic</a></h2>
<p>Dyadic arithmetic can be applied to various combinations of axes with leading-axis extension, Table (<code><span class='Modifier'>⌜</span></code>), and the Cells (<code><span class='Modifier'>˘</span></code>) and Rank (<code><span class='Modifier2'>⎉</span></code>) modifiers. Cells is of course <code><span class='Modifier2'>⎉</span><span class='Number'>¯1</span></code>, and Table is <code><span class='Modifier2'>⎉</span><span class='Number'>0</span><span class='Ligature'>‿</span><span class='Number'>∞</span></code>, so the general case is arithmetic applied with the Rank operator any number of times.</p>
<p>An application of Rank is best described in terms of its frame ranks, not cell ranks. If <code><span class='Value'>a</span></code> and <code><span class='Value'>b</span></code> are these ranks, then there are <code><span class='Value'>a</span><span class='Function'>⌊</span><span class='Value'>b</span></code> shared frame axes and <code><span class='Value'>a</span><span class='Paren'>(</span><span class='Function'>⌈-⌊</span><span class='Paren'>)</span><span class='Value'>b</span></code> non-shared axes from the argument with the higher-rank frame. Repeating on rank applications from the outside in, with a final rank 0 inherent in the arithmetic itself, the two sets of argument axes are partitioned into sets of shared and non-shared axes. For example consider <code><span class='Function'>+</span><span class='Modifier'>⌜˘</span><span class='Modifier2'>⎉</span><span class='Number'>4</span><span class='Ligature'>‿</span><span class='Number'>3</span></code> on arguments of ranks 6 and 8.</p>
<ul>
<li>The <code><span class='Modifier2'>⎉</span><span class='Number'>4</span><span class='Ligature'>‿</span><span class='Number'>3</span></code> implies frame ranks of 6-4=2 and 8-3=5. This gives 2 shared axes (label 0 below), then 3 non-shared axes from <code><span class='Value'>𝕩</span></code> (label 1).</li>
<li>The <code><span class='Modifier'>˘</span></code> takes a shared axis (label 2).</li>
<li>The <code><span class='Modifier'>⌜</span></code> takes all axes from <code><span class='Value'>𝕨</span></code> non-shared (3), then all from <code><span class='Value'>𝕩</span></code> (label 4).</li>
</ul>
<pre>  <span class='Number'>0</span> <span class='Number'>1</span> <span class='Number'>2</span> <span class='Number'>3</span> <span class='Number'>4</span> <span class='Number'>5</span> <span class='Number'>6</span> <span class='Number'>7</span>
<span class='Value'>𝕨</span> <span class='Number'>0</span> <span class='Number'>0</span> <span class='Number'>2</span> <span class='Number'>3</span> <span class='Number'>3</span> <span class='Number'>3</span> 
<span class='Value'>𝕩</span> <span class='Number'>0</span> <span class='Number'>0</span> <span class='Number'>1</span> <span class='Number'>1</span> <span class='Number'>1</span> <span class='Number'>2</span> <span class='Number'>4</span> <span class='Number'>4</span>
</pre>
<p>An axis set behaves like a single axis, and any adjacent axis sets of the same type (for example, non-shared from <code><span class='Value'>𝕨</span></code>) can be combined. Length-1 axes can be ignored as well, so a simplification pass <a href="transpose.html#axis-simplification">like transpose</a> might make sense.</p>
<p>Then the implementation needs to expand this mapping quickly. As usual, long axes are easy and short axes are harder. It's best to take enough result axes so that a cell is not too small, then use a slow outer loop (for example, based on index lists) to call that inner loop. One result axis can be split in blocks if the cell size would be too small without it, but too big with it.</p>
<p>Because a result cell should be much larger than a cache line, there's no need for the outer loop to traverse these cells in order—that is, the axes can be moved around to iterate in a transposed order. An easy way to do this is to represent each result axis with a length, stride in the result, and stride in both arguments; axes represented this way can be freely rearranged. It's best to iterate over shared axes first (outermost), then non-shared axes, because a non-shared axis means cells in the other argument are repeated, and if it's placed last then no other cells will be used between those repeated accesses. If both arguments have non-shared axes then a blocked order that keeps the repeated cells in cache might be best, but it's complicated to implement.</p>
<h3 id="base-cases"><a class="header" href="#base-cases">Base cases</a></h3>
<p>The scalar-vector, vector-vector cases work as base cases on one axis, and Table and leading-axis are two two-axis cases. There's also a flipped Table <code><span class='Modifier'>˜⌜˜</span></code> and a trailing-axis case like <code><span class='Modifier2'>⎉</span><span class='Number'>1</span></code>. Representing each result axis with &quot;w&quot; if it comes from <code><span class='Value'>𝕨</span></code> only, &quot;x&quot; for <code><span class='Value'>𝕩</span></code> only, and &quot;wx&quot; for shared, we can organize these cases.</p>
<ul>
<li>w, x (scalar-vector)</li>
<li>wx (vector-vector)</li>
<li>w-x (Table)</li>
<li>x-w (flipped Table)</li>
<li>wx-x, wx-w (leading)</li>
<li>w-wx, x-wx (trailing)</li>
</ul>
<p>That's six two-axis combinations; the remaining three possibilities w-w, x-x, and wx-wx are simplifiable. Trailing-axis agreement takes half of Table like leading-axis agreement, but it's the reshaping half instead of replicate.</p>
<p>The general case is to expand the arguments with Replicate along various axes so that they have the same shape as the result, and then use vector-vector arithmetic. More concretely, insert a length-1 axis into the argument for each non-shared axis in the other argument. Then replicate these axes to to required length. This can be done one axis at a time from the bottom up, or by constructing an array of indices and applying them at once, and probably other ways as well. See also <a href="replicate.html#higher-ranks">high-rank Replicate</a>.</p>
