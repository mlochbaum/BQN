<head>
  <link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../../style.css" rel="stylesheet"/>
  <title>BQN: Implementation of Take and Drop</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../../index.html">BQN</a> / <a href="../index.html">implementation</a> / <a href="index.html">primitive</a></div>
<h1 id="implementation-of-take-and-drop"><a class="header" href="#implementation-of-take-and-drop">Implementation of Take and Drop</a></h1>
<p>The function <a href="../../doc/take.html">Take</a> on multidimensional arrays can be an important utility for working with arrays that have an odd cell shape. For example, a sorting algorithm on 25-bit cells would be very hard to write, but it's fast to expand each cell to 32 bits, sort, and trim back to 25 bits.</p>
<h2 id="bit-interleaving-and-uninterleaving"><a class="header" href="#bit-interleaving-and-uninterleaving">Bit interleaving and uninterleaving</a></h2>
<p>When the argument and result cells fit in a machine word, Take performs an operation I call bit interleaving if the width increases, or bit uninterleaving if it decreases. That's because it inserts some number of zero bits between every few bits of <code><span class='Function'>‚•ä</span><span class='Value'>ùï©</span></code>, or undoes this process. Bit interleaving with nonzero bits might be used for <code><span class='Function'>‚çâ</span><span class='Value'>ùï©</span></code> when <code><span class='Function'>‚â†</span><span class='Value'>ùï©</span></code> is small, or <code><span class='Value'>ùï©</span><span class='Function'>‚àæ</span><span class='Modifier'>Àò</span><span class='Value'>ùï®</span></code> when both arguments have small cells.</p>
<p><strong>Careful!</strong> A cell under 64 bits wide might not fit into any single machine word. For example, 57 bits starting at a 6-bit offset span 9 bytes. The first bit is bit 6 of byte 0, and the last is bit 0 of byte 8. Assuming the entire array is byte aligned, each cell always fits in a word for sizes ‚â§58, and 60. Cell sizes ‚â•61, and 59, might not. <strong>Beware 59!</strong></p>
<p>Interleaving can be implemented with pdep, and uninterleaving with pext, in the BMI2 instructions. And these operations can be performed generically with a series of shifts and masks. Consider <code><span class='Number'>7</span> <span class='Function'>‚Üë</span> <span class='Value'>ùï©</span></code> where a cell of <code><span class='Value'>ùï©</span></code> is 5 bits. Here are the input and expected result, labelling zeros with <code><span class='Value'>.</span></code> and argument bits with letters:</p>
<pre><span class='Value'>...................</span><span class='Function'>ABCDEabcdeABCDEabcdeABCDEabcdeABCDEabcdeABCDE</span>
<span class='Value'>...</span><span class='Function'>ABCDE</span><span class='Value'>..abcde..</span><span class='Function'>ABCDE</span><span class='Value'>..abcde..</span><span class='Function'>ABCDE</span><span class='Value'>..abcde..</span><span class='Function'>ABCDE</span><span class='Value'>..abcde..</span><span class='Function'>ABCDE</span>
</pre>
<p>The number of cells that can be widened at a time is <code><span class='Function'>‚åä</span><span class='Number'>64</span><span class='Function'>√∑</span><span class='Number'>7</span></code>, or <code><span class='Number'>9</span></code>. In some cases I suppose it'd be possible to pack in one more by letting the leading zeros run past the top bit; that sounds complicated.</p>
<p>With the pdep instruction all we need to do is construct the appropriate mask indicating where the output cells should go. Let <code><span class='Function'>K</span> <span class='Value'>m</span></code> be <code><span class='Paren'>(</span><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Value'>m</span><span class='Paren'>)</span><span class='Function'>-</span><span class='Number'>1</span></code>, that is, a number consisting of <code><span class='Value'>m</span></code> ones in binary. Then the appropriate mask is <code><span class='Paren'>(</span><span class='Function'>K</span> <span class='Number'>5</span><span class='Paren'>)</span> <span class='Function'>√ó</span> <span class='Paren'>(</span><span class='Function'>K</span> <span class='Number'>7</span><span class='Function'>√ó</span><span class='Number'>9</span><span class='Paren'>)</span> <span class='Function'>√∑</span> <span class='Paren'>(</span><span class='Function'>K</span> <span class='Number'>7</span><span class='Paren'>)</span></code>. The mask <code><span class='Function'>K</span> <span class='Number'>7</span><span class='Function'>√ó</span><span class='Number'>9</span></code> has 9 groups of 7 1s, and division by <code><span class='Function'>K</span> <span class='Number'>7</span></code> converts each group to its bottom bit. Then multiplying by <code><span class='Function'>K</span> <span class='Number'>5</span></code> converts each bit to 5 of them.</p>
<p>Because interleaving and uninterleaving are useful even on short arrays, it's best to precompute the division <code><span class='Paren'>(</span><span class='Function'>K</span> <span class='Number'>7</span><span class='Function'>√ó</span><span class='Number'>9</span><span class='Paren'>)</span> <span class='Function'>√∑</span> <span class='Paren'>(</span><span class='Function'>K</span> <span class='Number'>7</span><span class='Paren'>)</span></code>. Since <code><span class='Number'>9</span></code> was computed as <code><span class='Function'>‚åä</span><span class='Number'>64</span><span class='Function'>√∑</span><span class='Number'>7</span></code>, this value depends only on the width 7 so a table of 64 words is enough. And <code><span class='Number'>7</span><span class='Function'>|</span><span class='Number'>64</span></code>, which might be useful for alignment, can be computed from the word as <code><span class='Value'>l</span><span class='Function'>¬¨</span><span class='Number'>7</span></code>, where <code><span class='Value'>l</span></code> is the number of leading 0 bits. Other similar schemes are possible.</p>
<p>On generic hardware these operations take more work. If we have <code><span class='Value'>n</span></code> cells in a word (9 here), then it can be done with <code><span class='Function'>‚åà</span><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Modifier'>‚Åº</span><span class='Value'>n</span></code> steps. Numbering the cells starting at 0 on the right (little-endian) and the steps <em>ending</em> at 0 for interleaving, step <code><span class='Value'>j</span></code> moves cells that have a 1 in bit position <code><span class='Value'>j</span></code>.</p>
<pre><span class='Value'>...................</span><span class='Function'>ABCDEabcdeABCDEabcdeABCDEabcdeABCDEabcdeABCDE</span>
<span class='Value'>...</span><span class='Function'>ABCDE</span><span class='Value'>................abcdeABCDEabcdeABCDEabcdeABCDEabcdeABCDE</span>
<span class='Value'>...</span><span class='Function'>ABCDE</span><span class='Value'>........abcdeABCDEabcdeABCDE........abcdeABCDEabcdeABCDE</span>
<span class='Value'>...</span><span class='Function'>ABCDE</span><span class='Value'>....abcdeABCDE....abcdeABCDE....abcdeABCDE....abcdeABCDE</span>
<span class='Value'>...</span><span class='Function'>ABCDE</span><span class='Value'>..abcde..</span><span class='Function'>ABCDE</span><span class='Value'>..abcde..</span><span class='Function'>ABCDE</span><span class='Value'>..abcde..</span><span class='Function'>ABCDE</span><span class='Value'>..abcde..</span><span class='Function'>ABCDE</span>
</pre>
<p>The amount to move is <code><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Value'>j</span></code> times the difference between the argument and result widths. To move the appropriate cells but not others, we need to blend with a mask, as in <code><span class='Paren'>(</span><span class='Value'>w</span><span class='Function'>&lt;&lt;</span><span class='Value'>sh</span> <span class='Value'>&amp;~</span> <span class='Value'>mask</span><span class='Paren'>)</span> <span class='Function'>|</span> <span class='Paren'>(</span><span class='Value'>w</span> <span class='Value'>&amp;</span> <span class='Value'>mask</span><span class='Paren'>)</span></code>. To go backwards, shift first, like <code><span class='Paren'>(</span><span class='Value'>w</span> <span class='Value'>&amp;~</span> <span class='Value'>mask</span><span class='Paren'>)</span><span class='Function'>&gt;&gt;</span><span class='Value'>sh</span> <span class='Function'>|</span> <span class='Paren'>(</span><span class='Value'>w</span> <span class='Value'>&amp;</span> <span class='Value'>mask</span><span class='Paren'>)</span></code>. Interleaving leaves some junk that needs to be cleared out with a final mask (same as the one used for pdep), and likewise uninterleaving requires the initial word to be cleaned with that mask. Here are the masks interleaved (heh) with results:</p>
<pre><span class='Value'>...................</span><span class='Function'>ABCDEabcdeABCDEabcdeABCDEabcdeABCDEabcdeABCDE</span>
<span class='Number'>0000000011111111111111111111111111111111111111111111111111111111</span>
<span class='Value'>...</span><span class='Function'>ABCDE</span><span class='Value'>................abcdeABCDEabcdeABCDEabcdeABCDEabcdeABCDE</span>
<span class='Number'>1111111100000000000000000000000000001111111111111111111111111111</span>
<span class='Value'>...</span><span class='Function'>ABCDE</span><span class='Value'>........abcdeABCDEabcdeABCDE........abcdeABCDEabcdeABCDE</span>
<span class='Number'>1111111100000000000000111111111111110000000000000011111111111111</span>
<span class='Value'>...</span><span class='Function'>ABCDE</span><span class='Value'>....abcdeABCDE....abcdeABCDE....abcdeABCDE....abcdeABCDE</span>
<span class='Number'>0111111100000001111111000000011111110000000111111100000001111111</span>
<span class='Value'>...</span><span class='Function'>ABCDE</span><span class='Value'>..abcde..</span><span class='Function'>ABCDE</span><span class='Value'>..abcde..</span><span class='Function'>ABCDE</span><span class='Value'>..abcde..</span><span class='Function'>ABCDE</span><span class='Value'>..abcde..</span><span class='Function'>ABCDE</span>
<span class='Number'>0001111100111110011111001111100111110011111001111100111110011111</span>
</pre>
<p>The masks aren't very quick to generate, so it's best to do it once for all cells and save them. One way is to start with a mask <code><span class='Value'>m</span></code> of all ones, then repeatedly take <code><span class='Value'>m</span> <span class='Value'>^</span> <span class='Paren'>(</span><span class='Value'>m</span><span class='Function'>&lt;&lt;</span><span class='Value'>sh</span><span class='Paren'>)</span></code> with a series of shifts <code><span class='Value'>sh</span></code> that decrease by factors of 2.</p>
