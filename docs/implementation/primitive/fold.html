<head>
  <meta charset="utf-8">
  <link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../../style.css" rel="stylesheet"/>
  <title>BQN: Implementation of Fold and Scan</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../../index.html">BQN</a> / <a href="../index.html">implementation</a> / <a href="index.html">primitive</a></div>
<h1 id="implementation-of-fold-and-scan"><a class="header" href="#implementation-of-fold-and-scan">Implementation of Fold and Scan</a></h1>
<p>Folds and scans with some arithmetic primitives like <code><span class='Function'>+</span></code>, <code><span class='Function'>âŒˆ</span></code>, and boolean <code><span class='Function'>â‰ </span></code> are staples of array programming. Fortunately these cases are also suitable for SIMD implementation. There is also the minor note that it's worth optimizing folds with <code><span class='Function'>âŠ£</span></code> or <code><span class='Function'>âŠ¢</span></code> that give the first and last element (or cell), and the scan <code><span class='Function'>âŠ£</span><span class='Modifier'>`</span></code> broadcasts the first cell to the entire array, which has some uses like <code><span class='Function'>âŠ£</span><span class='Modifier'>`</span><span class='Modifier2'>âŠ¸</span><span class='Function'>â‰¡</span></code> to test if all cells match.</p>
<p>My talk &quot;Implementing Reduction&quot; (<a href="https://dyalog.tv/Dyalog19/?v=TqmpSP8Knvg">video</a>, <a href="https://www.dyalog.com/uploads/conference/dyalog19/presentations/D09_Implementing_Reduction.zip">slides</a>) quickly covers some ideas about folding, particularly on high-rank arrays. The slides have illustrations of some extra algorithms not discussed in the talk.</p>
<h2 id="associative-arithmetic"><a class="header" href="#associative-arithmetic">Associative arithmetic</a></h2>
<p>The arithmetic operations <code><span class='Function'>+Ã—</span></code> on integers, and <code><span class='Function'>âŒˆâŒŠ</span></code> on all types, are associative and commutative (and for <code><span class='Value'>â€¢math.</span><span class='Function'>Sum</span></code>, float addition may be considered commutative for optimization). This allows for folds and scans to be reordered in a way that's suitable for SIMD evaluation, where without some insight into the operand function they would be inherently sequential. Also, <code><span class='Function'>-</span><span class='Modifier'>Â´</span></code> can be performed by negating every other value then summing, and monadic <code><span class='Function'>Â¬</span><span class='Modifier'>Â´</span></code> is <code><span class='Brace'>{</span><span class='Paren'>(</span><span class='Function'>Â¬</span><span class='Number'>2</span><span class='Function'>|â‰ </span><span class='Value'>ğ•©</span><span class='Paren'>)</span><span class='Function'>+-</span><span class='Modifier'>Â´</span><span class='Value'>ğ•©</span><span class='Brace'>}</span></code>.</p>
<p>For these operands, a fold can be done simply by combining two vector registers at a time, with a final pairwise reduction at the end. An overflowing operation like <code><span class='Function'>+</span></code> needs to be performed at double width (or possibly 32-bit for 8-bit values), and moved to a full-width accumulator once that's exhausted.</p>
<p>The technique for a fast prefix sum is described in Singeli's <a href="https://github.com/mlochbaum/Singeli/blob/master/doc/minfilter.md">min-filter tutorial</a> beginning at &quot;we have some vector scan code already&quot;. There's also a treatment <a href="https://en.algorithmica.org/hpc/algorithms/prefix/">here</a>, but the blocking method seems overcomplicated given that incorporating the carry after summing a register is enough to get rid of dependency chains.</p>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>Boolean folds <code><span class='Function'>â‰ =+-</span></code> can be optimized with associative methods. <code><span class='Function'>â‰ </span></code> is the associative xor function, and <code><span class='Function'>=</span><span class='Modifier'>Â´</span><span class='Value'>ğ•©</span></code> is <code><span class='Paren'>(</span><span class='Number'>2</span><span class='Function'>|â‰ </span><span class='Value'>ğ•©</span><span class='Paren'>)</span><span class='Function'>=â‰ </span><span class='Modifier'>Â´</span><span class='Value'>ğ•©</span></code>. For <code><span class='Function'>+</span><span class='Modifier'>Â´</span></code> there's a dedicated popcount instruction, but also <a href="https://arxiv.org/abs/1611.07612">Faster Population Counts Using AVX2 Instructions</a> are possible. This method is well-known enough that clang produces the AVX2 code given a loop that sums popcounts. For <code><span class='Function'>-</span><span class='Modifier'>Â´</span></code>, flip every other bit beforehand and subtract half the length, that is, <code><span class='Paren'>(</span><span class='Function'>+</span><span class='Modifier'>Â´</span><span class='Value'>ğ•©</span><span class='Function'>â‰ </span><span class='Number'>2</span><span class='Function'>|â†•â‰ </span><span class='Value'>ğ•©</span><span class='Paren'>)</span><span class='Function'>-âŒŠ</span><span class='Number'>2</span><span class='Function'>Ã·</span><span class='Modifier'>Ëœ</span><span class='Function'>â‰ </span><span class='Value'>ğ•©</span></code>. Another case that's been studied is <code><span class='Function'>+</span><span class='Modifier'>Ë</span></code> on an array with cells of 8, 16, 32, or 64 bits, called <a href="https://github.com/mklarqvist/positional-popcount">positional popcount</a>.</p>
<p>Other folds <code><span class='Function'>âˆ§âˆ¨&lt;&gt;â‰¤â‰¥</span></code> can be shortcut: they depend only on the first instance of a 0 (for <code><span class='Function'>âˆ§&lt;&gt;</span></code>) or 1 (for <code><span class='Function'>âˆ¨â‰¤â‰¥</span></code>). Specifically we have the following on a boolean list, omitting <code><span class='Function'>âŠ‘</span></code> in the right column:</p>
<table>
<thead>
<tr>
<th align="center">Fold</th>
<th align="right">Equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code><span class='Function'>âˆ§</span><span class='Modifier'>Â´</span></code></td>
<td align="right"><code><span class='Function'>Â¬</span><span class='Number'>0</span><span class='Function'>âˆŠ</span><span class='Value'>ğ•©</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>âˆ¨</span><span class='Modifier'>Â´</span></code></td>
<td align="right"><code><span class='Number'>1</span><span class='Function'>âˆŠ</span><span class='Value'>ğ•©</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>â‰¤</span><span class='Modifier'>Â´</span></code></td>
<td align="right"><code><span class='Paren'>(</span><span class='Number'>1</span><span class='Function'>-</span><span class='Modifier'>Ëœ</span><span class='Function'>â‰ </span><span class='Value'>ğ•©</span><span class='Paren'>)</span><span class='Function'>â‰ </span><span class='Value'>ğ•©</span><span class='Function'>âŠ</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>&lt;</span><span class='Modifier'>Â´</span></code></td>
<td align="right"><code><span class='Paren'>(</span><span class='Number'>1</span><span class='Function'>-</span><span class='Modifier'>Ëœ</span><span class='Function'>â‰ </span><span class='Value'>ğ•©</span><span class='Paren'>)</span><span class='Function'>=</span><span class='Value'>ğ•©</span><span class='Function'>âŠ</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>&gt;</span><span class='Modifier'>Â´</span></code></td>
<td align="right"><code><span class='Number'>2</span><span class='Function'>|</span><span class='Value'>ğ•©</span><span class='Function'>âŠ</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>â‰¥</span><span class='Modifier'>Â´</span></code></td>
<td align="right"><code><span class='Function'>Â¬</span><span class='Number'>2</span><span class='Function'>|</span><span class='Value'>ğ•©</span><span class='Function'>âŠ</span><span class='Number'>1</span></code></td>
</tr>
</tbody>
</table>
<p>Boolean scans are more varied. For <code><span class='Function'>âˆ¨</span></code>, the result switches from all <code><span class='Number'>0</span></code> to all <code><span class='Number'>1</span></code> after the first <code><span class='Number'>1</span></code>, and the other way around for <code><span class='Function'>âˆ§</span></code>. For <code><span class='Function'>â‰ </span></code>, the associative optimization gives a word-at-a-time algorithm with power-of-two shifts, and other possibilities with architecture support are <a href="#xor-scan">discussed below</a>. The scan <code><span class='Function'>&lt;</span><span class='Modifier'>`</span></code> turns off every other 1 in groups of 1s. It's used in simdjson for backslash escaping, and they <a href="https://github.com/simdjson/simdjson/blob/ac78c62/src/generic/stage1/json_escape_scanner.h#L96">describe in detail</a> a method that uses subtraction for carrying. And <code><span class='Function'>&gt;</span><span class='Modifier'>`</span></code> flips to all 0 at the first bit if it's a 0 or the <em>second</em> 1 bit otherwise. <code><span class='Function'>â‰¤</span><span class='Modifier'>`</span></code> is <code><span class='Function'>&lt;</span><span class='Modifier'>`</span><span class='Modifier2'>âŒ¾</span><span class='Function'>Â¬</span></code>, and <code><span class='Function'>â‰¥</span><span class='Modifier'>`</span></code> is <code><span class='Function'>&gt;</span><span class='Modifier'>`</span><span class='Modifier2'>âŒ¾</span><span class='Function'>Â¬</span></code>.</p>
<h3 id="xor-scan"><a class="header" href="#xor-scan">Xor scan</a></h3>
<p>The scan <code><span class='Function'>â‰ </span><span class='Modifier'>`</span></code> has the ordinary implementation using power-of-two shifts, covered in Hacker's Delight section 5-2, &quot;Parity&quot;. Broadcast the carry to the entire word with a signed shift and xor into the next word after scanning it.</p>
<p>If available, carry-less multiply (clmul) can also be used to scan a word, by multiplying by the all-1s word, a trick explained <a href="https://branchfree.org/2019/03/06/code-fragment-finding-quote-pairs-with-carry-less-multiply-pclmulqdq">here</a>. The 128-bit result has an inclusive scan in the low 64 bits and a reverse exclusive scan in the high 64 bits (the top bit is always 0). This is useful because xor-ing high with low gives a word of all carry bits. And the clmul method also works for high-rank <code><span class='Function'>â‰ </span><span class='Modifier'>`</span></code> if the row length <code><span class='Value'>l</span></code> is a divisor of 64, by choosing a mask where every <code><span class='Value'>l</span></code>-th bit is set. Then the high-low trick is much more important because shifting doesn't give a valid carry! For strides of 8 or more, this method might not be faster than AVX2 using element-level operations, but hey, it's free.</p>
<p>In AVX-512, there's a clmul instruction on four 64-bit words, albeit in an inconvenient configuration. There's also the GFNI instruction gf2p8affineqb, which can be used for an inclusive or exclusive xor-scan on groups of 8 bits (or 4, or 2). There's <a href="https://twitter.com/InstLatX64/status/1148247870887419904">a way</a> to combine this with a single 64-bit clmul to do a full 512-bit scan, although it's not all that much faster than doing single clmul instructions.</p>
<h2 id="high-rank-arrays"><a class="header" href="#high-rank-arrays">High-rank arrays</a></h2>
<p>Insert on large cells can be done simply by combining a cell at a time. However, it's fastest to split things up in columns, so that the accumulators can be kept in vector registers instead of written to memory. For small cells, the virtual rows technique described in my reduction talk means that most of the work can be performed as a larger-cell reduction. The speed of the final combination matters when there aren't a large number of rows, and doing it quickly can be tricky.</p>
<p>For long cells, scan on a high-rank array can be done by initializing the first cell and then calling a single vector-vector arithmetic function. For cell length (or stride) <code><span class='Value'>m</span></code>, the function will write to <code><span class='Value'>dst</span><span class='Function'>+</span><span class='Value'>m</span></code> where <code><span class='Value'>dst</span></code> is a pointer to the result, and get its arguments from <code><span class='Value'>dst</span></code> and <code><span class='Value'>src</span><span class='Function'>+</span><span class='Value'>m</span></code> where <code><span class='Value'>src</span></code> points to <code><span class='Value'>ğ•©</span></code>. If the function works in order on <code><span class='Value'>k</span><span class='Function'>â‰¤</span><span class='Value'>m</span></code> elements at a time, then the <code><span class='Value'>k</span></code> elements it reads from <code><span class='Value'>dst</span></code> have already been written, so this gives the correct result.</p>
<p>If the cell size is a power of two and fits in a vector register, then the parallel strategy for scans on lists still works (the operation that combines cells is still associative and commutative, it's just wider). For odd widths there's some trouble with alignment.</p>
<h3 id="boolean-fold-cells"><a class="header" href="#boolean-fold-cells">Boolean fold-cells</a></h3>
<p>Boolean folds on short rows can be implemented as a segmented scan, or windowed reduction, followed by extracting the appropriate bit from each row. The extraction is the hard part. While it's a special case of <a href="take.html#bit-interleaving-and-uninterleaving">bit uninterleaving</a>, it's better to implement it with a more specialized method. <a href="https://orlp.net/blog/extracting-depositing-bits/">Here's a post</a> on how you might do this extraction on a single word. Believe it or not, for multiple words even the pext-based method is beaten soundly by some generic code! Okay, for even widths it requires a little cheating with SSE2 auto-vectorization. For an odd width, say <code><span class='Value'>f</span></code>, there's a complicated but powerful method relying on the fact that in the first <code><span class='Value'>f</span></code> input words, the row boundaries cover each position within a word exactly once (this follows from the Chinese remainder theorem, since an odd number is relatively prime to each power of two). So the idea is to mask out these bits and combine them into a single word, then un-permute to put them in the right order in the result. There are a lot of complications, so it's described in <a href="#the-modular-bit-permutation">its own section</a>.</p>
<h2 id="the-modular-bit-permutation"><a class="header" href="#the-modular-bit-permutation">The modular bit permutation</a></h2>
<p>This section describes how to perform and use the permutation sending the bit at position <code><span class='Value'>n</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span></code> to position <code><span class='Value'>i</span></code> within each group of <code><span class='Value'>n</span><span class='Gets'>â†</span><span class='Number'>2</span><span class='Function'>â‹†</span><span class='Value'>k</span></code> bits, where <code><span class='Value'>f</span></code> is odd. It's done by a series of swaps, conditionally exchanging pairs of bits separated by a power of two, starting at <code><span class='Value'>n</span><span class='Function'>Ã·</span><span class='Number'>2</span></code> and ending at 2. Each swap is a self-inverse, so doing them in the opposite order results in the opposite permutation taking position <code><span class='Value'>i</span></code> to <code><span class='Value'>n</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span></code>.</p>
<p>The direction we focus on here can extract one bit from every <code><span class='Value'>f</span></code>, so it's useful for boolean fold-cells and select-cells picking out a single column. In the other direction, it can spread bits out in the same way, which can be used for take-cells but is most powerful in <a href="replicate.html#constant-replicate">Replicate by constant</a> since this also applies to broadcasting as used in Table and leading axis extension.</p>
<h3 id="decomposing-into-swaps"><a class="header" href="#decomposing-into-swaps">Decomposing into swaps</a></h3>
<p>First we'll prove that a modular permutation does actually decompose into swap operations. Here's the intuitive case: consider the permutation where index <code><span class='Value'>i</span></code> has value <code><span class='Number'>16</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>Ã—</span><span class='Value'>i</span></code> (meaning, that's the original index of the bit that ends up at <code><span class='Value'>i</span></code>). At positions <code><span class='Value'>i</span></code> and <code><span class='Number'>8</span><span class='Function'>+</span><span class='Value'>i</span></code>, <code><span class='Value'>i</span><span class='Function'>&lt;</span><span class='Number'>8</span></code>, we have <code><span class='Number'>16</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>Ã—</span><span class='Value'>i</span></code> and <code><span class='Number'>16</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>Ã—</span><span class='Paren'>(</span><span class='Number'>8</span><span class='Function'>+</span><span class='Value'>i</span><span class='Paren'>)</span></code> or <code><span class='Number'>16</span><span class='Function'>|</span><span class='Number'>8</span><span class='Function'>+</span><span class='Number'>5</span><span class='Function'>Ã—</span><span class='Value'>i</span></code>. These values are different, but both are congruent to <code><span class='Number'>5</span><span class='Function'>Ã—</span><span class='Value'>i</span></code> (mod 8), so one of them is <code><span class='Number'>8</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>Ã—</span><span class='Value'>i</span></code> and the other is <code><span class='Number'>8</span><span class='Function'>+</span><span class='Number'>8</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>Ã—</span><span class='Value'>i</span></code>. These are the values at positions <code><span class='Value'>i</span></code> and <code><span class='Number'>8</span><span class='Function'>+</span><span class='Value'>i</span></code> in the permutation that applies <code><span class='Number'>8</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>Ã—</span><span class='Value'>i</span></code> within each byte, so to extend that permutation from size 8 to size 16 what we need to do is swap these bits if <code><span class='Number'>16</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>Ã—</span><span class='Value'>i</span></code> isn't equal to <code><span class='Number'>8</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>Ã—</span><span class='Value'>i</span></code>.</p>
<p>To handle it more rigorously, suppose we have performed our permutation of size <code><span class='Value'>h</span></code> so the value at <code><span class='Value'>i</span></code> is <code><span class='Paren'>(</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span></code> and want to extend this to size <code><span class='Value'>l</span> <span class='Gets'>â†</span> <span class='Number'>2</span><span class='Function'>Ã—</span><span class='Value'>h</span></code>. Define <code><span class='Function'>B</span> <span class='Gets'>â†</span> <span class='Brace'>{</span><span class='Paren'>(</span><span class='Value'>l</span><span class='Function'>|</span><span class='Value'>ğ•©</span><span class='Paren'>)</span> <span class='Function'>-</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>ğ•©</span><span class='Brace'>}</span></code>, noting that <code><span class='Value'>h</span><span class='Function'>|B</span><span class='Value'>ğ•©</span></code> is always 0. We will show that the value to be moved to <code><span class='Value'>i</span></code> appears at <code><span class='Value'>j</span> <span class='Gets'>â†</span> <span class='Paren'>(</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Paren'>(</span><span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span><span class='Paren'>)</span></code>. Since <code><span class='Value'>h</span><span class='Function'>|</span><span class='Value'>j</span></code> is <code><span class='Value'>h</span><span class='Function'>|</span><span class='Value'>i</span></code> after dropping <code><span class='Function'>B</span></code> terms, we have:</p>
<pre>   <span class='Paren'>(</span><span class='Value'>j</span> <span class='Function'>-</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>j</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>j</span>
<span class='Gets'>â†â†’</span> <span class='Paren'>(</span><span class='Value'>j</span> <span class='Function'>-</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span>
<span class='Gets'>â†â†’</span> <span class='Paren'>(((</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Paren'>(</span><span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span><span class='Paren'>))</span> <span class='Function'>-</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span>
<span class='Gets'>â†â†’</span> <span class='Paren'>(</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Paren'>((</span><span class='Function'>B</span> <span class='Value'>i</span><span class='Paren'>)</span><span class='Function'>+</span><span class='Value'>h</span><span class='Function'>|</span><span class='Value'>i</span><span class='Paren'>))</span> <span class='Function'>+</span> <span class='Paren'>((</span><span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span><span class='Paren'>)</span><span class='Function'>+</span><span class='Value'>h</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span><span class='Paren'>)</span>
<span class='Gets'>â†â†’</span> <span class='Paren'>(</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Value'>l</span><span class='Function'>|</span><span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Value'>l</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span>
</pre>
<p>as desired. Now, what does this extending mapping do? In C terminology <code><span class='Function'>B</span> <span class='Value'>i</span></code> is the bit mask <code><span class='Value'>i</span> <span class='Value'>&amp;</span> <span class='Value'>h</span></code>, so <code><span class='Value'>j</span></code> is <code><span class='Value'>i</span></code> with this bit replaced with the one from <code><span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span></code>. With a lot of algebra it's possible to prove that our transformation is a self-inverse: to give a sketch, <code><span class='Function'>B</span> <span class='Value'>j</span></code> is <code><span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span></code> which means <code><span class='Value'>j</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>j</span></code> is <code><span class='Value'>i</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>i</span></code>, and <code><span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>j</span></code> works out to <code><span class='Function'>B</span> <span class='Value'>i</span></code> using the facts that <code><span class='Value'>l</span><span class='Function'>|B</span><span class='Value'>ğ•©</span></code> and <code><span class='Value'>l</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>Ã—B</span><span class='Value'>ğ•©</span></code> are <code><span class='Function'>B</span><span class='Value'>ğ•©</span></code> and <code><span class='Value'>l</span><span class='Function'>|</span><span class='Number'>2</span><span class='Function'>Ã—B</span><span class='Value'>ğ•©</span></code> is 0 (with <code><span class='Value'>ğ•©</span><span class='Function'>=</span><span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span></code> for that last one). Then <code><span class='Paren'>(</span><span class='Value'>j</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>j</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Paren'>(</span><span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>j</span><span class='Paren'>)</span></code> is <code><span class='Paren'>(</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Paren'>(</span><span class='Function'>B</span> <span class='Value'>i</span><span class='Paren'>)</span></code>, giving back <code><span class='Value'>i</span></code>! We can conclude that it either swaps positions <code><span class='Value'>i</span></code> and <code><span class='Value'>i</span> <span class='Value'>^</span> <span class='Value'>h</span></code>, where <code><span class='Value'>^</span></code> is bitwise xor, or leaves them alone.</p>
<p>The example below shows the steps for the modular permutation with factor 3 on size 16. The first one is the identity: this is always true because <code><span class='Value'>f</span></code> is odd, so <code><span class='Number'>1</span><span class='Function'>=</span><span class='Number'>2</span><span class='Function'>|</span><span class='Value'>f</span></code> and <code><span class='Number'>2</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span></code> is <code><span class='Number'>2</span><span class='Function'>|</span><span class='Value'>i</span></code>.</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=ZiDihpAgMwpTdGVwIOKGkCB7IGjwnZWKaToKICBsIOKGkCAyw5doCiAgQiDihpAgeyhsfPCdlakpIC0gaHzwnZWpfQogIChpIC0gQiBpKSArIEIgZsOXaQp9Cgo+IHMxNiDihpAgMeKAvzLigL804oC/OCBTdGVwwqggPOKGlTE2Cj4g4oqPy5xgIHMxNiAgIyBTdWNjZXNzaXZlbHkgYXBwbHkgc3RlcHMKMTYgfCBmIMOXIOKGlTE2ICAjIEl0IG1hdGNoZXMh">â†—ï¸</a><pre>    <span class='Value'>f</span> <span class='Gets'>â†</span> <span class='Number'>3</span>
    <span class='Function'>Step</span> <span class='Gets'>â†</span> <span class='Brace'>{</span> <span class='Value'>h</span><span class='Function'>ğ•Š</span><span class='Value'>i</span><span class='Head'>:</span>
      <span class='Value'>l</span> <span class='Gets'>â†</span> <span class='Number'>2</span><span class='Function'>Ã—</span><span class='Value'>h</span>
      <span class='Function'>B</span> <span class='Gets'>â†</span> <span class='Brace'>{</span><span class='Paren'>(</span><span class='Value'>l</span><span class='Function'>|</span><span class='Value'>ğ•©</span><span class='Paren'>)</span> <span class='Function'>-</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>ğ•©</span><span class='Brace'>}</span>
      <span class='Paren'>(</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span>
    <span class='Brace'>}</span>

    <span class='Function'>&gt;</span> <span class='Value'>s16</span> <span class='Gets'>â†</span> <span class='Number'>1</span><span class='Ligature'>â€¿</span><span class='Number'>2</span><span class='Ligature'>â€¿</span><span class='Number'>4</span><span class='Ligature'>â€¿</span><span class='Number'>8</span> <span class='Function'>Step</span><span class='Modifier'>Â¨</span> <span class='Function'>&lt;â†•</span><span class='Number'>16</span>
â”Œâ”€                                           
â•µ 0 1 2  3  4  5 6 7 8  9 10 11 12 13 14 15  
  0 3 2  1  4  7 6 5 8 11 10  9 12 15 14 13  
  0 1 6  3  4  5 2 7 8  9 14 11 12 13 10 15  
  0 1 2 11 12 13 6 7 8  9 10  3  4  5 14 15  
                                            â”˜
    <span class='Function'>&gt;</span> <span class='Function'>âŠ</span><span class='Modifier'>Ëœ`</span> <span class='Value'>s16</span>  <span class='Comment'># Successively apply steps
</span>â”Œâ”€                                          
â•µ 0 1 2 3  4  5 6 7 8  9 10 11 12 13 14 15  
  0 3 2 1  4  7 6 5 8 11 10  9 12 15 14 13  
  0 3 6 1  4  7 2 5 8 11 14  9 12 15 10 13  
  0 3 6 9 12 15 2 5 8 11 14  1  4  7 10 13  
                                           â”˜
    <span class='Number'>16</span> <span class='Function'>|</span> <span class='Value'>f</span> <span class='Function'>Ã—</span> <span class='Function'>â†•</span><span class='Number'>16</span>  <span class='Comment'># It matches!
</span>âŸ¨ 0 3 6 9 12 15 2 5 8 11 14 1 4 7 10 13 âŸ©
</pre>
<p>Applying the steps backwards gives the inverse, where index 1 goes to position 3, 2 to 6, and so on. This is also the original direction with factor 11, which is the inverse of 3 modulo 16.</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=ZiDihpAgMwpTdGVwIOKGkCB7IGjwnZWKaToKICBsIOKGkCAyw5doCiAgQiDihpAgeyhsfPCdlakpIC0gaHzwnZWpfQogIChpIC0gQiBpKSArIEIgZsOXaQp9Cj4gczE2IOKGkCAx4oC/MuKAvzTigL84IFN0ZXDCqCA84oaVMTYK4oqPwrQgczE2CgoxNiB8IDExIMOXIOKGlTE2CgoxNiB8IDMgw5cgMTE=">â†—ï¸</a><pre>    <span class='Function'>âŠ</span><span class='Modifier'>Â´</span> <span class='Value'>s16</span>
âŸ¨ 0 11 6 1 12 7 2 13 8 3 14 9 4 15 10 5 âŸ©

    <span class='Number'>16</span> <span class='Function'>|</span> <span class='Number'>11</span> <span class='Function'>Ã—</span> <span class='Function'>â†•</span><span class='Number'>16</span>
âŸ¨ 0 11 6 1 12 7 2 13 8 3 14 9 4 15 10 5 âŸ©

    <span class='Number'>16</span> <span class='Function'>|</span> <span class='Number'>3</span> <span class='Function'>Ã—</span> <span class='Number'>11</span>
1
</pre>
<h3 id="evaluating-swaps"><a class="header" href="#evaluating-swaps">Evaluating swaps</a></h3>
<p>So we know that step that widens permutation units from <code><span class='Value'>h</span></code> to <code><span class='Number'>2</span><span class='Function'>Ã—</span><span class='Value'>h</span></code> swaps bit <code><span class='Value'>i</span></code> with bit <code><span class='Value'>i</span> <span class='Value'>^</span> <span class='Value'>h</span></code> whenever <code><span class='Value'>i</span> <span class='Value'>&amp;</span> <span class='Value'>h</span></code> isn't equal to <code><span class='Paren'>(</span><span class='Value'>f</span><span class='Function'>Ã—</span><span class='Value'>i</span><span class='Paren'>)</span> <span class='Value'>&amp;</span> <span class='Value'>h</span></code>. There are various ways to compute this given a bitmask of which values to swap, which depends on <code><span class='Value'>f</span></code>. The data needed is just the bits for <code><span class='Value'>i</span></code> in <code><span class='Function'>â†•</span><span class='Value'>h</span></code>, that is, <code><span class='Value'>h</span><span class='Function'>â‰¤</span><span class='Paren'>(</span><span class='Number'>2</span><span class='Function'>Ã—</span><span class='Value'>h</span><span class='Paren'>)</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>Ã—â†•</span><span class='Value'>h</span></code>, as the remaining bits <code><span class='Value'>h</span><span class='Function'>â†“â†•</span><span class='Number'>2</span><span class='Function'>Ã—</span><span class='Value'>h</span></code> are the same. I know of two good ways to apply it, and a shortcut:</p>
<ul>
<li>Using xor, <code><span class='Value'>d</span> <span class='Function'>=</span> <span class='Paren'>(</span><span class='Value'>x</span> <span class='Value'>^</span> <span class='Value'>x</span><span class='Function'>&lt;&lt;</span><span class='Value'>h</span><span class='Paren'>)</span> <span class='Value'>&amp;</span> <span class='Value'>hi</span></code>, <code><span class='Value'>x</span> <span class='Value'>^</span> <span class='Paren'>(</span><span class='Value'>d</span> <span class='Function'>|</span> <span class='Value'>d</span><span class='Function'>&gt;&gt;</span><span class='Value'>h</span><span class='Paren'>)</span></code> with high-bits mask <code><span class='Value'>hi</span></code>.</li>
<li>With a swap-halves function, <code><span class='Paren'>(</span><span class='Value'>x</span> <span class='Value'>&amp;~</span> <span class='Value'>m</span><span class='Paren'>)</span> <span class='Function'>|</span> <span class='Paren'>(</span><span class='Value'>swap</span><span class='Paren'>(</span><span class='Value'>x</span><span class='Paren'>)</span> <span class='Value'>&amp;</span> <span class='Value'>m</span><span class='Paren'>)</span></code> with full mask <code><span class='Value'>m</span></code>.</li>
<li>Also, any permutation on each byte can be done with two shuffle instructions.</li>
</ul>
<p>A swap-halves function can be a rotate instruction on elements of width <code><span class='Number'>2</span><span class='Function'>Ã—</span><span class='Value'>h</span></code>, or can be done with a shuffle on elements of width <code><span class='Value'>h</span></code> or smaller.</p>
<p>The total data to permute width <code><span class='Value'>l</span></code> is 2+4+â€¦<code><span class='Value'>l</span><span class='Function'>Ã·</span><span class='Number'>2</span></code> bits, or <code><span class='Value'>l</span><span class='Function'>-</span><span class='Number'>2</span></code>. It can be precomputed for each odd factor <code><span class='Value'>f</span><span class='Function'>&lt;</span><span class='Value'>l</span></code> (which covers larger factors too, since <code><span class='Value'>f</span><span class='Function'>+</span><span class='Value'>k</span><span class='Function'>Ã—</span><span class='Value'>l</span></code> permutes as <code><span class='Value'>f</span></code>). Then it just needs to be read from a table and unpacked into individual mask vectors. These mask vectors could also be computed directly with multiplication and some bit shuffling; I'm not sure how this would compare in speed.</p>
