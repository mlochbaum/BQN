<head>
  <link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../../style.css" rel="stylesheet"/>
  <title>BQN: Implementation of Fold and Scan</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../../index.html">BQN</a> / <a href="../index.html">implementation</a> / <a href="index.html">primitive</a></div>
<h1 id="implementation-of-fold-and-scan"><a class="header" href="#implementation-of-fold-and-scan">Implementation of Fold and Scan</a></h1>
<p>Folds and scans with some arithmetic primitives like <code><span class='Function'>+</span></code>, <code><span class='Function'>⌈</span></code>, and boolean <code><span class='Function'>≠</span></code> are staples of array programming. Fortunately these cases are also suitable for SIMD implementation. There is also the minor note that it's worth optimizing folds with <code><span class='Function'>⊣</span></code> or <code><span class='Function'>⊢</span></code> that give the first and last element (or cell), and the scan <code><span class='Function'>⊣</span><span class='Modifier'>`</span></code> broadcasts the first cell to the entire array, which has some uses like <code><span class='Function'>⊣</span><span class='Modifier'>`</span><span class='Modifier2'>⊸</span><span class='Function'>≢</span></code> to test if all cells match.</p>
<p>My talk &quot;Implementing Reduction&quot; (<a href="https://dyalog.tv/Dyalog19/?v=TqmpSP8Knvg">video</a>, <a href="https://www.dyalog.com/uploads/conference/dyalog19/presentations/D09_Implementing_Reduction.zip">slides</a>) quickly covers some ideas about folding, particularly on high-rank arrays. The slides have illustrations of some extra algorithms not discussed in the talk.</p>
<h2 id="associative-arithmetic"><a class="header" href="#associative-arithmetic">Associative arithmetic</a></h2>
<p>The arithmetic operations <code><span class='Function'>+×</span></code> on integers, and <code><span class='Function'>⌈⌊</span></code> on all types, are associative and commutative (and for <code><span class='Value'>•math.</span><span class='Function'>Sum</span></code>, float addition may be considered commutative for optimization). This allows for folds and scans to be reordered in a way that's suitable for SIMD evaluation, where without some insight into the operand function they would be inherently sequential. Also, <code><span class='Function'>-</span><span class='Modifier'>´</span></code> can be performed by negating every other value then summing, and monadic <code><span class='Function'>¬</span><span class='Modifier'>´</span></code> is <code><span class='Brace'>{</span><span class='Paren'>(</span><span class='Function'>¬</span><span class='Number'>2</span><span class='Function'>|≠</span><span class='Value'>𝕩</span><span class='Paren'>)</span><span class='Function'>+-</span><span class='Modifier'>´</span><span class='Value'>𝕩</span><span class='Brace'>}</span></code>.</p>
<p>For these operands, a fold can be done simply by combining two vector registers at a time, with a final pairwise reduction at the end. An overflowing operation like <code><span class='Function'>+</span></code> needs to be performed at double width (or possibly 32-bit for 8-bit values), and moved to a full-width accumulator once that's exhausted.</p>
<p>The technique for a fast prefix sum is described in Singeli's <a href="https://github.com/mlochbaum/Singeli/blob/master/doc/minfilter.md">min-filter tutorial</a> beginning at &quot;we have some vector scan code already&quot;. There's also a treatment <a href="https://en.algorithmica.org/hpc/algorithms/prefix/">here</a>, but the blocking method seems overcomplicated given that incorporating the carry after summing a register is enough to get rid of dependency chains.</p>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>Boolean folds <code><span class='Function'>≠=+-</span></code> can be optimized with associative methods. <code><span class='Function'>≠</span></code> is the associative xor function, and <code><span class='Function'>=</span><span class='Modifier'>´</span><span class='Value'>𝕩</span></code> is <code><span class='Paren'>(</span><span class='Number'>2</span><span class='Function'>|≠</span><span class='Value'>𝕩</span><span class='Paren'>)</span><span class='Function'>=≠</span><span class='Modifier'>´</span><span class='Value'>𝕩</span></code>. For <code><span class='Function'>+</span><span class='Modifier'>´</span></code> there's a dedicated popcount instruction, but also <a href="https://arxiv.org/abs/1611.07612">Faster Population Counts Using AVX2 Instructions</a> are possible. This method is well-known enough that clang produces the AVX2 code given a loop that sums popcounts. For <code><span class='Function'>-</span><span class='Modifier'>´</span></code>, flip every other bit beforehand and subtract half the length, that is, <code><span class='Paren'>(</span><span class='Function'>+</span><span class='Modifier'>´</span><span class='Value'>𝕩</span><span class='Function'>≠</span><span class='Number'>2</span><span class='Function'>|↕≠</span><span class='Value'>𝕩</span><span class='Paren'>)</span><span class='Function'>-⌊</span><span class='Number'>2</span><span class='Function'>÷</span><span class='Modifier'>˜</span><span class='Function'>≠</span><span class='Value'>𝕩</span></code>. Another case that's been studied is <code><span class='Function'>+</span><span class='Modifier'>˝</span></code> on an array with cells of 8, 16, 32, or 64 bits, called <a href="https://github.com/mklarqvist/positional-popcount">positional popcount</a>.</p>
<p>Other folds <code><span class='Function'>∧∨&lt;&gt;≤≥</span></code> can be shortcut: they depend only on the first instance of a 0 (for <code><span class='Function'>∧&lt;&gt;</span></code>) or 1 (for <code><span class='Function'>∨≤≥</span></code>). Specifically we have the following on a boolean list, omitting <code><span class='Function'>⊑</span></code> on the right:</p>
<table>
<thead>
<tr>
<th align="center">Fold</th>
<th align="right">Equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code><span class='Function'>∧</span><span class='Modifier'>´</span></code></td>
<td align="right"><code><span class='Function'>¬</span><span class='Number'>0</span><span class='Function'>∊</span><span class='Value'>𝕩</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>∨</span><span class='Modifier'>´</span></code></td>
<td align="right"><code><span class='Number'>1</span><span class='Function'>∊</span><span class='Value'>𝕩</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>≤</span><span class='Modifier'>´</span></code></td>
<td align="right"><code><span class='Paren'>(</span><span class='Number'>1</span><span class='Function'>-</span><span class='Modifier'>˜</span><span class='Function'>≠</span><span class='Value'>𝕩</span><span class='Paren'>)</span><span class='Function'>≠</span><span class='Value'>𝕩</span><span class='Function'>⊐</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>&lt;</span><span class='Modifier'>´</span></code></td>
<td align="right"><code><span class='Paren'>(</span><span class='Number'>1</span><span class='Function'>-</span><span class='Modifier'>˜</span><span class='Function'>≠</span><span class='Value'>𝕩</span><span class='Paren'>)</span><span class='Function'>=</span><span class='Value'>𝕩</span><span class='Function'>⊐</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>&gt;</span><span class='Modifier'>´</span></code></td>
<td align="right"><code> <span class='Number'>2</span><span class='Function'>|</span><span class='Value'>𝕩</span><span class='Function'>⊐</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>≥</span><span class='Modifier'>´</span></code></td>
<td align="right"><code><span class='Function'>¬</span><span class='Number'>2</span><span class='Function'>|</span><span class='Value'>𝕩</span><span class='Function'>⊐</span><span class='Number'>1</span></code></td>
</tr>
</tbody>
</table>
<p>Boolean scans are more varied. For <code><span class='Function'>∨</span></code>, the result switches from all <code><span class='Number'>0</span></code> to all <code><span class='Number'>1</span></code> after the first <code><span class='Number'>1</span></code>, and the other way around for <code><span class='Function'>∧</span></code>. For <code><span class='Function'>≠</span></code>, the associative optimization gives a word-at-a-time algorithm with power-of-two shifts, and other possibilities with architecture support are <a href="#xor-scan">discussed below</a>. The scan <code><span class='Function'>&lt;</span><span class='Modifier'>`</span></code> turns off every other 1 in groups of 1s. It's used in simdjson for backslash escaping, and they <a href="https://github.com/simdjson/simdjson/blob/ac78c62/src/generic/stage1/json_escape_scanner.h#L96">describe in detail</a> a method that uses subtraction for carrying. And <code><span class='Function'>&gt;</span><span class='Modifier'>`</span></code> flips to all 0 at the first bit if it's a 0 or the <em>second</em> 1 bit otherwise. <code><span class='Function'>≤</span><span class='Modifier'>`</span></code> is <code><span class='Function'>&lt;</span><span class='Modifier'>`</span><span class='Modifier2'>⌾</span><span class='Function'>¬</span></code>, and <code><span class='Function'>≥</span><span class='Modifier'>`</span></code> is <code><span class='Function'>&gt;</span><span class='Modifier'>`</span><span class='Modifier2'>⌾</span><span class='Function'>¬</span></code>.</p>
<h3 id="xor-scan"><a class="header" href="#xor-scan">Xor scan</a></h3>
<p>The scan <code><span class='Function'>≠</span><span class='Modifier'>`</span></code> has the ordinary implementation using power-of-two shifts, covered in Hacker’s Delight section 5-2, &quot;Parity&quot;. Broadcast the carry to the entire word with a signed shift and xor into the next word after scanning it.</p>
<p>If available, carry-less multiply (clmul) can also be used to scan a word, by multiplying by the all-1s word, a trick explained <a href="https://branchfree.org/2019/03/06/code-fragment-finding-quote-pairs-with-carry-less-multiply-pclmulqdq">here</a>. The 128-bit result has an inclusive scan in the low 64 bits and a reverse exclusive scan in the high 64 bits (the top bit is always 0). This is useful because xor-ing high with low gives a word of all carry bits. And the clmul method also works for high-rank <code><span class='Function'>≠</span><span class='Modifier'>`</span></code> if the row length <code><span class='Value'>l</span></code> is a divisor of 64, by choosing a mask where every <code><span class='Value'>l</span></code>-th bit is set. Then the high-low trick is much more important because shifting doesn't gives a valid carry! For strides of 8 or more, this method might not be faster than AVX2 using element-level operations, but hey, it's free.</p>
<p>In AVX-512, there's a clmul instruction on four 64-bit words, albeit in an inconvenient configuration. There's also the GFNI instruction gf2p8affineqb, which can be used for an inclusive or exclusive xor-scan on groups of 8 bits (or 4, or 2). There's <a href="https://twitter.com/InstLatX64/status/1148247870887419904">a way</a> to combine this with a single 64-bit clmul to do a full 512-bit scan, although it's not all that much faster than doing single clmul instructions.</p>
<h2 id="high-rank-arrays"><a class="header" href="#high-rank-arrays">High-rank arrays</a></h2>
<p>Insert on large cells can be done simply by combining a cell at a time. However, it's fastest to split things up in columns, so that the accumulators can be kept in vector registers instead of written to memory. For small cells, the virtual rows technique described in my reduction talk means that most of the work can be performed as a larger-cell reduction. However, doing the final combination quickly can be tricky.</p>
<p>For long cells, scan on a high-rank array can be done by initializing the first cell and then calling a single vector-vector arithmetic function. For cell length (or stride) <code><span class='Value'>m</span></code>, the function will write to <code><span class='Value'>dst</span><span class='Function'>+</span><span class='Value'>m</span></code> where <code><span class='Value'>dst</span></code> is a pointer to the result, and get its arguments from <code><span class='Value'>dst</span></code> and <code><span class='Value'>src</span><span class='Function'>+</span><span class='Value'>m</span></code> where <code><span class='Value'>src</span></code> points to <code><span class='Value'>𝕩</span></code>. If the function works in order on <code><span class='Value'>k</span><span class='Function'>≤</span><span class='Value'>m</span></code> elements at a time, then the <code><span class='Value'>k</span></code> elements it reads from <code><span class='Value'>dst</span></code> have already been written, so this gives the correct result.</p>
<p>If the cell size is a power of two and fits in a vector register, then the parallel strategy for scans on lists still works (the operation that combines cells is still associative and commutative, it's just wider). For odd widths there's some trouble with alignment.</p>
