<head>
  <meta charset="utf-8">
  <link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../../style.css" rel="stylesheet"/>
  <title>BQN: Implementation of Fold and Scan</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../../index.html">BQN</a> / <a href="../index.html">implementation</a> / <a href="index.html">primitive</a></div>
<h1 id="implementation-of-fold-and-scan"><a class="header" href="#implementation-of-fold-and-scan">Implementation of Fold and Scan</a></h1>
<p>Folds and scans with some arithmetic primitives like <code><span class='Function'>+</span></code>, <code><span class='Function'>‚åà</span></code>, and boolean <code><span class='Function'>‚â†</span></code> are staples of array programming. Fortunately these cases are also suitable for SIMD implementation. There is also the minor note that it's worth optimizing folds with <code><span class='Function'>‚ä£</span></code> or <code><span class='Function'>‚ä¢</span></code> that give the first and last element (or cell), and the scan <code><span class='Function'>‚ä£</span><span class='Modifier'>`</span></code> broadcasts the first cell to the entire array, which has some uses like <code><span class='Function'>‚ä£</span><span class='Modifier'>`</span><span class='Modifier2'>‚ä∏</span><span class='Function'>‚â°</span></code> to test if all cells match.</p>
<p>When implementing SIMD scans, it's crucial to allow processing of a word or vector to begin before the previous one is completed, to benefit from instruction-level parallelism. Generally a good way to do this is to perform a scan just on that unit, and only then fix it up with a carry. For example, for <code><span class='Function'>+</span><span class='Modifier'>`</span></code>, scan within a vector, then broadcast the last element of the previous vector of sums and add it to the scan.</p>
<p>My talk &quot;Implementing Reduction&quot; (<a href="https://dyalog.tv/Dyalog19/?v=TqmpSP8Knvg">video</a>, <a href="https://www.dyalog.com/uploads/conference/dyalog19/presentations/D09_Implementing_Reduction.zip">slides</a>) quickly covers some ideas about folding, particularly on high-rank arrays. The slides have illustrations of some extra algorithms not discussed in the talk.</p>
<h2 id="associative-arithmetic"><a class="header" href="#associative-arithmetic">Associative arithmetic</a></h2>
<p>The arithmetic operations <code><span class='Function'>+√ó</span></code> on integers, and <code><span class='Function'>‚åà‚åä</span></code> on all types, are associative and commutative (and for <code><span class='Value'>‚Ä¢math.</span><span class='Function'>Sum</span></code>, float addition may be considered commutative for optimization). This allows for folds and scans to be reordered in a way that's suitable for SIMD evaluation, where without some insight into the operand function they would be inherently sequential. Also, <code><span class='Function'>-</span><span class='Modifier'>¬¥</span></code> can be performed by negating every other value then summing, and monadic <code><span class='Function'>¬¨</span><span class='Modifier'>¬¥</span></code> is <code><span class='Brace'>{</span><span class='Paren'>(</span><span class='Function'>¬¨</span><span class='Number'>2</span><span class='Function'>|‚â†</span><span class='Value'>ùï©</span><span class='Paren'>)</span><span class='Function'>+-</span><span class='Modifier'>¬¥</span><span class='Value'>ùï©</span><span class='Brace'>}</span></code>.</p>
<p>For these operands, a fold can be done simply by combining two vector registers at a time, with a final pairwise reduction at the end. An overflowing operation like <code><span class='Function'>+</span></code> needs to be performed at double width (or possibly 32-bit for 8-bit values), and moved to a full-width accumulator once that's exhausted.</p>
<h3 id="scan-architecture"><a class="header" href="#scan-architecture">Scan architecture</a></h3>
<p>There's lots of research on <a href="https://en.wikipedia.org/wiki/Prefix_sum#Parallel_algorithms">parallel scan</a> with broadly useful ideas. Relevant ideas also show up in ALU design, where the shifting, broadcasting, and sequential algorithms below correspond to <a href="https://en.wikipedia.org/wiki/Kogge%E2%80%93Stone_adder">Kogge-Stone</a>, Sklansky, and ripple-carry adders. A fast CPU prefix sum is described in Singeli's <a href="https://github.com/mlochbaum/Singeli/blob/master/doc/minfilter.md">min-filter tutorial</a> beginning at &quot;we have some vector scan code already&quot;. There's also a treatment <a href="https://en.algorithmica.org/hpc/algorithms/prefix/">here</a>, but the blocking method seems overcomplicated when incorporating the carry after summing a register is enough to take care of dependency chains.</p>
<p>Three associative scan algorithms make for useful components on a CPU core. The red paths show how, in each, an output involves every input up to its position exactly once.</p>
<svg viewBox='-47.2 -8 684.8 259'>
  <g fill='currentColor' stroke-linecap='round' text-anchor='middle' font-family='BQN,monospace'>
    <rect class='code' stroke-width='1.5' rx='12' x='-31.2' y='0' width='652.8' height='243'/>
    <g class='bluegreen' opacity='0.4' stroke-width='1'>
      <rect x='202.8' y='63' width='88.8' height='99'/>
      <rect x='298.8' y='63' width='88.8' height='99'/>
    </g>
    <g stroke-width='2'>
      <g stroke='currentColor'>
        <line x1='0' x2='0' y1='54' y2='216'/>
        <line x1='24' x2='24' y1='54' y2='216'/>
        <line x1='48' x2='48' y1='54' y2='216'/>
        <line x1='72' x2='72' y1='54' y2='216'/>
        <line x1='96' x2='96' y1='54' y2='216'/>
        <line x1='120' x2='120' y1='54' y2='216'/>
        <line x1='144' x2='144' y1='54' y2='216'/>
        <line x1='168' x2='168' y1='54' y2='216'/>
        <line x1='211.2' x2='211.2' y1='54' y2='216'/>
        <line x1='235.2' x2='235.2' y1='54' y2='216'/>
        <line x1='259.2' x2='259.2' y1='54' y2='216'/>
        <line x1='283.2' x2='283.2' y1='54' y2='216'/>
        <line x1='307.2' x2='307.2' y1='54' y2='216'/>
        <line x1='331.2' x2='331.2' y1='54' y2='216'/>
        <line x1='355.2' x2='355.2' y1='54' y2='216'/>
        <line x1='379.2' x2='379.2' y1='54' y2='216'/>
        <line x1='422.4' x2='422.4' y1='54' y2='216'/>
        <line x1='446.4' x2='446.4' y1='54' y2='216'/>
        <line x1='470.4' x2='470.4' y1='54' y2='216'/>
        <line x1='494.4' x2='494.4' y1='54' y2='216'/>
        <line x1='518.4' x2='518.4' y1='54' y2='216'/>
        <line x1='542.4' x2='542.4' y1='54' y2='216'/>
        <line x1='566.4' x2='566.4' y1='54' y2='216'/>
        <line x1='590.4' x2='590.4' y1='54' y2='216'/>
        <line x1='24' x2='48' y1='69.8' y2='102'/>
        <line x1='72' x2='96' y1='69.8' y2='102'/>
        <line x1='120' x2='144' y1='69.8' y2='102'/>
        <line x1='144' x2='168' y1='69.8' y2='102'/>
        <line x1='0' x2='48' y1='117.8' y2='150'/>
        <line x1='24' x2='72' y1='117.8' y2='150'/>
        <line x1='48' x2='96' y1='117.8' y2='150'/>
        <line x1='96' x2='144' y1='117.8' y2='150'/>
        <line x1='120' x2='168' y1='117.8' y2='150'/>
        <line x1='0' x2='96' y1='165.8' y2='198'/>
        <line x1='48' x2='144' y1='165.8' y2='198'/>
        <line x1='72' x2='168' y1='165.8' y2='198'/>
        <line x1='355.2' x2='379.2' y1='69.8' y2='102'/>
        <line x1='235.2' x2='259.2' y1='117.8' y2='150'/>
        <line x1='331.2' x2='355.2' y1='117.8' y2='150'/>
        <line x1='331.2' x2='379.2' y1='117.8' y2='150'/>
        <line x1='283.2' x2='307.2' y1='165.8' y2='198'/>
        <line x1='283.2' x2='355.2' y1='165.8' y2='198'/>
        <line x1='283.2' x2='379.2' y1='165.8' y2='198'/>
        <line x1='542.4' x2='566.4' y1='169.914' y2='177.429'/>
        <line x1='566.4' x2='590.4' y1='190.486' y2='198'/>
      </g>
      <g class='red' stroke-width='3'>
        <line x1='0' x2='0' y1='54' y2='69.8'/>
        <line x1='24' x2='24' y1='54' y2='165.8'/>
        <line x1='48' x2='48' y1='54' y2='69.8'/>
        <line x1='72' x2='72' y1='54' y2='117.8'/>
        <line x1='96' x2='96' y1='54' y2='69.8'/>
        <line x1='120' x2='120' y1='54' y2='216'/>
        <line x1='211.2' x2='211.2' y1='54' y2='69.8'/>
        <line x1='235.2' x2='235.2' y1='54' y2='117.8'/>
        <line x1='259.2' x2='259.2' y1='54' y2='69.8'/>
        <line x1='283.2' x2='283.2' y1='54' y2='165.8'/>
        <line x1='307.2' x2='307.2' y1='54' y2='69.8'/>
        <line x1='331.2' x2='331.2' y1='54' y2='216'/>
        <line x1='422.4' x2='422.4' y1='54' y2='67.057'/>
        <line x1='446.4' x2='446.4' y1='54' y2='87.629'/>
        <line x1='470.4' x2='470.4' y1='54' y2='108.2'/>
        <line x1='494.4' x2='494.4' y1='54' y2='128.771'/>
        <line x1='518.4' x2='518.4' y1='54' y2='149.343'/>
        <line x1='542.4' x2='542.4' y1='54' y2='216'/>
        <line x1='0' x2='24' y1='69.8' y2='102'/>
        <line x1='48' x2='72' y1='69.8' y2='102'/>
        <line x1='96' x2='120' y1='69.8' y2='102'/>
        <line x1='72' x2='120' y1='117.8' y2='150'/>
        <line x1='24' x2='120' y1='165.8' y2='198'/>
        <line x1='211.2' x2='235.2' y1='69.8' y2='102'/>
        <line x1='259.2' x2='283.2' y1='69.8' y2='102'/>
        <line x1='307.2' x2='331.2' y1='69.8' y2='102'/>
        <line x1='235.2' x2='283.2' y1='117.8' y2='150'/>
        <line x1='283.2' x2='331.2' y1='165.8' y2='198'/>
        <line x1='422.4' x2='446.4' y1='67.057' y2='74.571'/>
        <line x1='446.4' x2='470.4' y1='87.629' y2='95.143'/>
        <line x1='470.4' x2='494.4' y1='108.2' y2='115.714'/>
        <line x1='494.4' x2='518.4' y1='128.771' y2='136.286'/>
        <line x1='518.4' x2='542.4' y1='149.343' y2='156.857'/>
      </g>
      <g class='code' style='stroke:currentColor' stroke-width='2'>
        <circle cx='24' cy='102' r='5'/>
        <circle cx='48' cy='102' r='5'/>
        <circle cx='72' cy='102' r='5'/>
        <circle cx='96' cy='102' r='5'/>
        <circle cx='120' cy='102' r='5'/>
        <circle cx='144' cy='102' r='5'/>
        <circle cx='168' cy='102' r='5'/>
        <circle cx='48' cy='150' r='5'/>
        <circle cx='72' cy='150' r='5'/>
        <circle cx='96' cy='150' r='5'/>
        <circle cx='120' cy='150' r='5'/>
        <circle cx='144' cy='150' r='5'/>
        <circle cx='168' cy='150' r='5'/>
        <circle cx='96' cy='198' r='5'/>
        <circle cx='120' cy='198' r='5'/>
        <circle cx='144' cy='198' r='5'/>
        <circle cx='168' cy='198' r='5'/>
        <circle cx='235.2' cy='102' r='5'/>
        <circle cx='283.2' cy='102' r='5'/>
        <circle cx='331.2' cy='102' r='5'/>
        <circle cx='379.2' cy='102' r='5'/>
        <circle cx='259.2' cy='150' r='5'/>
        <circle cx='283.2' cy='150' r='5'/>
        <circle cx='355.2' cy='150' r='5'/>
        <circle cx='379.2' cy='150' r='5'/>
        <circle cx='307.2' cy='198' r='5'/>
        <circle cx='331.2' cy='198' r='5'/>
        <circle cx='355.2' cy='198' r='5'/>
        <circle cx='379.2' cy='198' r='5'/>
        <circle cx='446.4' cy='74.571' r='5'/>
        <circle cx='470.4' cy='95.143' r='5'/>
        <circle cx='494.4' cy='115.714' r='5'/>
        <circle cx='518.4' cy='136.286' r='5'/>
        <circle cx='542.4' cy='156.857' r='5'/>
        <circle cx='566.4' cy='177.429' r='5'/>
        <circle cx='590.4' cy='198' r='5'/>
      </g>
      <g class='bluegreen' opacity='0.4' style='stroke:currentColor'>
        <circle cx='235.2' cy='102' r='5'/>
        <circle cx='283.2' cy='102' r='5'/>
        <circle cx='331.2' cy='102' r='5'/>
        <circle cx='379.2' cy='102' r='5'/>
        <circle cx='259.2' cy='150' r='5'/>
        <circle cx='283.2' cy='150' r='5'/>
        <circle cx='355.2' cy='150' r='5'/>
        <circle cx='379.2' cy='150' r='5'/>
      </g>
    </g>
    <g font-size='18px'>
      <text dy='0.32em' x='84' y='29'>Shifting</text>
      <text dy='0.32em' x='295.2' y='29'>Broadcasting</text>
      <text dy='0.32em' x='506.4' y='29'>Sequential</text>
    </g>
  </g>
</svg>

<p>Shifting by powers of two is useful on units small enough that a shift is a single instruction (a curiosity is that the different shifts can be done in any order). When there are boundaries such as vector lanes, an alternative is to scan two halves separately and then correct the later one with broadcasted &quot;carries&quot;, crossing the boundary only once. With no associative reordering, the sequential method minimizes total operations. CPU algorithms should be sequential at the top (per-core) level but lower levels need to make use of the processor's parallelism to be fast.</p>
<p>The recursive step in broadcasting hints at a way to tie together any lower-level and higher-level scan algorithm. This step makes up the &quot;Bottom-Up Parallel Scan&quot; in <a href="https://ashinkarov.github.io/pubs/2022-scan.html">Parallel Scan as a Multidimensional Array Problem</a>. Divide the input into chunks of length <code><span class='Value'>k</span></code> (rather than necessarily halves), and perform a scan on each. Then take the last element of each scanned chunk, propagate carries with an <em>exclusive</em> scan, and broadcast each result to combine it with the chunk it came from. It's typical to have one-register chunks and use a basic sequential scan for the carries: an entire register operation to combine two carries may be wasteful but packing and unpacking carries would be slower.</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=ayDihpAgNCAgICAgICAgIyBVbml0IHNpemUK4oqiIHZlYyDihpAg4oaVMTAgICMgQXJndW1lbnQKCuKKoiBzIOKGkCArYMuYIOKGkeKAv2sg4qWKIHZlYyAgIyBTY2FuIGVhY2ggdW5pdAoK4oqiIGMg4oaQIMK7ICtgIOKKosudy5ggcyAgIyBTY2FuIGNhcnJpZXMgZnJvbSBsYXN0IHJvdwoKKOKJoHZlYykg4qWKIGMgKyBz">‚ÜóÔ∏è</a><pre>    <span class='Value'>k</span> <span class='Gets'>‚Üê</span> <span class='Number'>4</span>        <span class='Comment'># Unit size
</span>    <span class='Function'>‚ä¢</span> <span class='Value'>vec</span> <span class='Gets'>‚Üê</span> <span class='Function'>‚Üï</span><span class='Number'>10</span>  <span class='Comment'># Argument
</span>‚ü® 0 1 2 3 4 5 6 7 8 9 ‚ü©

    <span class='Function'>‚ä¢</span> <span class='Value'>s</span> <span class='Gets'>‚Üê</span> <span class='Function'>+</span><span class='Modifier'>`Àò</span> <span class='Function'>‚Üë</span><span class='Ligature'>‚Äø</span><span class='Value'>k</span> <span class='Function'>‚•ä</span> <span class='Value'>vec</span>  <span class='Comment'># Scan each unit
</span>‚îå‚îÄ            
‚ïµ 0  1  3  6  
  4  9 15 22  
  8 17 17 17  
             ‚îò

    <span class='Function'>‚ä¢</span> <span class='Value'>c</span> <span class='Gets'>‚Üê</span> <span class='Function'>¬ª</span> <span class='Function'>+</span><span class='Modifier'>`</span> <span class='Function'>‚ä¢</span><span class='Modifier'>ÀùÀò</span> <span class='Value'>s</span>  <span class='Comment'># Scan carries from last row
</span>‚ü® 0 6 28 ‚ü©

    <span class='Paren'>(</span><span class='Function'>‚â†</span><span class='Value'>vec</span><span class='Paren'>)</span> <span class='Function'>‚•ä</span> <span class='Value'>c</span> <span class='Function'>+</span> <span class='Value'>s</span>
‚ü® 0 1 3 6 10 15 21 28 36 45 ‚ü©
</pre>
<p>The dependency-cutting property of broadcasting can be demonstrated even in a scalar context, scanning both elements in a group and carries sequentially. With a group size of 4, the number of operations jumps from 4 to 7 per group, but the critical path is reduced from 4 to 1.</p>
<svg viewBox='-97.8 -8 585.6 288'>
  <g fill='currentColor' stroke-linecap='round' text-anchor='middle' font-family='BQN,monospace'>
    <rect class='code' stroke-width='1.5' rx='12' x='-33.8' y='0' width='457.6' height='272'/>
    <g class='bluegreen' opacity='0.4' stroke-width='1'>
      <rect x='-9.1' y='52.7' width='96.2' height='68.68'/>
      <rect x='94.9' y='52.7' width='96.2' height='68.68'/>
      <rect x='198.9' y='52.7' width='96.2' height='68.68'/>
      <rect x='302.9' y='52.7' width='96.2' height='68.68'/>
    </g>
    <g stroke-width='2'>
      <g stroke='currentColor'>
        <line x1='0' x2='0' y1='47.6' y2='255'/>
        <line x1='26' x2='26' y1='47.6' y2='255'/>
        <line x1='52' x2='52' y1='47.6' y2='255'/>
        <line x1='78' x2='78' y1='47.6' y2='255'/>
        <line x1='104' x2='104' y1='47.6' y2='255'/>
        <line x1='130' x2='130' y1='47.6' y2='255'/>
        <line x1='156' x2='156' y1='47.6' y2='255'/>
        <line x1='182' x2='182' y1='47.6' y2='255'/>
        <line x1='208' x2='208' y1='47.6' y2='255'/>
        <line x1='234' x2='234' y1='47.6' y2='255'/>
        <line x1='260' x2='260' y1='47.6' y2='255'/>
        <line x1='286' x2='286' y1='47.6' y2='255'/>
        <line x1='312' x2='312' y1='47.6' y2='255'/>
        <line x1='338' x2='338' y1='47.6' y2='255'/>
        <line x1='364' x2='364' y1='47.6' y2='255'/>
        <line x1='390' x2='390' y1='47.6' y2='255'/>
        <line x1='312' x2='338' y1='57.734' y2='68.944'/>
        <line x1='234' x2='260' y1='79.079' y2='90.289'/>
        <line x1='338' x2='364' y1='79.079' y2='90.289'/>
        <line x1='260' x2='286' y1='100.423' y2='111.633'/>
        <line x1='364' x2='390' y1='100.423' y2='111.633'/>
        <line x1='78' x2='104' y1='123.902' y2='154.322'/>
        <line x1='78' x2='130' y1='123.902' y2='154.322'/>
        <line x1='78' x2='156' y1='123.902' y2='154.322'/>
        <line x1='182' x2='208' y1='166.591' y2='197.011'/>
        <line x1='182' x2='260' y1='166.591' y2='197.011'/>
        <line x1='182' x2='286' y1='166.591' y2='197.011'/>
        <line x1='286' x2='312' y1='209.28' y2='239.7'/>
        <line x1='286' x2='338' y1='209.28' y2='239.7'/>
        <line x1='286' x2='364' y1='209.28' y2='239.7'/>
        <line x1='286' x2='390' y1='209.28' y2='239.7'/>
      </g>
      <g class='red' stroke-width='3'>
        <line x1='0' x2='0' y1='47.6' y2='57.734'/>
        <line x1='26' x2='26' y1='47.6' y2='79.079'/>
        <line x1='52' x2='52' y1='47.6' y2='100.423'/>
        <line x1='78' x2='78' y1='47.6' y2='123.902'/>
        <line x1='104' x2='104' y1='47.6' y2='57.734'/>
        <line x1='130' x2='130' y1='47.6' y2='79.079'/>
        <line x1='156' x2='156' y1='47.6' y2='100.423'/>
        <line x1='182' x2='182' y1='47.6' y2='166.591'/>
        <line x1='208' x2='208' y1='47.6' y2='57.734'/>
        <line x1='234' x2='234' y1='47.6' y2='255'/>
        <line x1='0' x2='26' y1='57.734' y2='68.944'/>
        <line x1='104' x2='130' y1='57.734' y2='68.944'/>
        <line x1='208' x2='234' y1='57.734' y2='68.944'/>
        <line x1='26' x2='52' y1='79.079' y2='90.289'/>
        <line x1='130' x2='156' y1='79.079' y2='90.289'/>
        <line x1='52' x2='78' y1='100.423' y2='111.633'/>
        <line x1='156' x2='182' y1='100.423' y2='111.633'/>
        <line x1='78' x2='182' y1='123.902' y2='154.322'/>
        <line x1='182' x2='234' y1='166.591' y2='197.011'/>
      </g>
      <g class='code' style='stroke:currentColor' stroke-width='2'>
        <circle cx='26' cy='68.944' r='5'/>
        <circle cx='130' cy='68.944' r='5'/>
        <circle cx='234' cy='68.944' r='5'/>
        <circle cx='338' cy='68.944' r='5'/>
        <circle cx='52' cy='90.289' r='5'/>
        <circle cx='156' cy='90.289' r='5'/>
        <circle cx='260' cy='90.289' r='5'/>
        <circle cx='364' cy='90.289' r='5'/>
        <circle cx='78' cy='111.633' r='5'/>
        <circle cx='182' cy='111.633' r='5'/>
        <circle cx='286' cy='111.633' r='5'/>
        <circle cx='390' cy='111.633' r='5'/>
        <circle cx='104' cy='154.322' r='5'/>
        <circle cx='130' cy='154.322' r='5'/>
        <circle cx='156' cy='154.322' r='5'/>
        <circle cx='182' cy='154.322' r='5'/>
        <circle cx='208' cy='197.011' r='5'/>
        <circle cx='234' cy='197.011' r='5'/>
        <circle cx='260' cy='197.011' r='5'/>
        <circle cx='286' cy='197.011' r='5'/>
        <circle cx='312' cy='239.7' r='5'/>
        <circle cx='338' cy='239.7' r='5'/>
        <circle cx='364' cy='239.7' r='5'/>
        <circle cx='390' cy='239.7' r='5'/>
      </g>
      <g class='bluegreen' opacity='0.4' style='stroke:currentColor'>
        <circle cx='26' cy='68.944' r='5'/>
        <circle cx='130' cy='68.944' r='5'/>
        <circle cx='234' cy='68.944' r='5'/>
        <circle cx='338' cy='68.944' r='5'/>
        <circle cx='52' cy='90.289' r='5'/>
        <circle cx='156' cy='90.289' r='5'/>
        <circle cx='260' cy='90.289' r='5'/>
        <circle cx='364' cy='90.289' r='5'/>
        <circle cx='78' cy='111.633' r='5'/>
        <circle cx='182' cy='111.633' r='5'/>
        <circle cx='286' cy='111.633' r='5'/>
        <circle cx='390' cy='111.633' r='5'/>
      </g>
    </g>
    <g font-size='18px'>
      <text dy='0.32em' x='195' y='22.6'>Sequential broadcasting</text>
    </g>
  </g>
</svg>

<p>One way to express this is to replace the sequential loop body <code><span class='Value'>dst</span><span class='Bracket'>[</span><span class='Value'>i</span><span class='Bracket'>]</span> <span class='Function'>=</span> <span class='Value'>c</span> <span class='Function'>+=</span> <span class='Value'>src</span><span class='Bracket'>[</span><span class='Value'>i</span><span class='Bracket'>]</span><span class='Head'>;</span> <span class='Function'>++</span><span class='Value'>i</span><span class='Head'>;</span></code> with the following using a sub-accumulator <code><span class='Value'>t</span></code>:</p>
<pre><span class='Value'>t</span> <span class='Function'>+=</span> <span class='Value'>src</span><span class='Bracket'>[</span><span class='Value'>i</span><span class='Bracket'>]</span><span class='Head'>;</span>
<span class='Value'>int</span> <span class='Value'>r</span> <span class='Function'>=</span> <span class='Value'>dst</span><span class='Bracket'>[</span><span class='Value'>i</span><span class='Bracket'>]</span> <span class='Function'>=</span> <span class='Value'>c</span> <span class='Function'>+</span> <span class='Value'>t</span><span class='Head'>;</span>
<span class='Value'>if</span> <span class='Paren'>(</span><span class='Function'>++</span><span class='Value'>i%k</span> <span class='Function'>==</span> <span class='Number'>0</span><span class='Paren'>)</span> <span class='Brace'>{</span> <span class='Value'>c</span> <span class='Function'>=</span> <span class='Value'>r</span><span class='Head'>;</span> <span class='Value'>t</span> <span class='Function'>=</span> <span class='Number'>0</span><span class='Head'>;</span> <span class='Brace'>}</span>
</pre>
<p>But of course you have to unroll by <code><span class='Value'>k</span></code> for any real speed. I was able to measure about a 40% speedup this way for prefix sums of 4-byte ints in gcc, compiling with <code><span class='Function'>-O3</span> <span class='Function'>-</span><span class='Value'>fno</span><span class='Function'>-</span><span class='Value'>tree</span><span class='Function'>-</span><span class='Value'>vectorize</span></code> to keep it from pessimizing with SIMD. Most of it was from unrolling, as shown by clang which did a standard 4-way unroll to go 25% faster on the sequential version. But when I tried broadcasting, clang undid it, using associativity to reduce the number of additions and the performance.</p>
<table>
<thead>
<tr>
<th>Unrolled by:</th>
<th>1</th>
<th>2</th>
<th>4</th>
<th>8</th>
<th>(clang)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Time (ns/element)</td>
<td>0.34</td>
<td>0.25</td>
<td>0.21</td>
<td>0.22</td>
<td>0.25</td>
</tr>
<tr>
<td>Instructions per cycle</td>
<td>3.5</td>
<td>4.5</td>
<td>4.5</td>
<td>3.9</td>
<td>2.6</td>
</tr>
</tbody>
</table>
<p>Multiple layers can of course be tied together this way. For boolean scans in AVX2 you might combine a SWAR method on 64-bit words with broadcasting for the 4 words of a vector (or is that two sequential layers?) and sequential scan above this level. Framing this in terms of subdividing at the vector level and then the word level is subtly different from subdividing at the word level and then subdividing the scan on carries. What I've done is closer to the latter: scan each word, obtain carries, scan the carries and combine with the previous carry-of-carries, then shift over by one to make it an exclusive scan with the last one going into next step.</p>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>Boolean folds <code><span class='Function'>‚â†=+-</span></code> can be optimized with associative methods. <code><span class='Function'>‚â†</span></code> is the associative xor function, and <code><span class='Function'>=</span><span class='Modifier'>¬¥</span><span class='Value'>ùï©</span></code> is <code><span class='Paren'>(</span><span class='Number'>2</span><span class='Function'>|‚â†</span><span class='Value'>ùï©</span><span class='Paren'>)</span><span class='Function'>=‚â†</span><span class='Modifier'>¬¥</span><span class='Value'>ùï©</span></code>. For <code><span class='Function'>+</span><span class='Modifier'>¬¥</span></code> there's a dedicated popcount instruction, but also <a href="https://arxiv.org/abs/1611.07612">Faster Population Counts Using AVX2 Instructions</a> are possible. This method is well-known enough that clang produces the AVX2 code given a loop that sums popcounts. For <code><span class='Function'>-</span><span class='Modifier'>¬¥</span></code>, flip every other bit beforehand and subtract half the length, that is, <code><span class='Paren'>(</span><span class='Function'>+</span><span class='Modifier'>¬¥</span><span class='Value'>ùï©</span><span class='Function'>‚â†</span><span class='Number'>2</span><span class='Function'>|‚Üï‚â†</span><span class='Value'>ùï©</span><span class='Paren'>)</span><span class='Function'>-‚åä</span><span class='Number'>2</span><span class='Function'>√∑</span><span class='Modifier'>Àú</span><span class='Function'>‚â†</span><span class='Value'>ùï©</span></code>. Another case that's been studied is <code><span class='Function'>+</span><span class='Modifier'>Àù</span></code> on an array with cells of 8, 16, 32, or 64 bits, called <a href="https://github.com/mklarqvist/positional-popcount">positional popcount</a>.</p>
<p>Other folds <code><span class='Function'>‚àß‚à®&lt;&gt;‚â§‚â•</span></code> can be shortcut: they depend only on the first instance of a 0 (for <code><span class='Function'>‚àß&lt;&gt;</span></code>) or 1 (for <code><span class='Function'>‚à®‚â§‚â•</span></code>). Specifically we have the following on a boolean list, omitting <code><span class='Function'>‚äë</span></code> in the right column:</p>
<table>
<thead>
<tr>
<th align="center">Fold</th>
<th align="right">Equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code><span class='Function'>‚àß</span><span class='Modifier'>¬¥</span></code></td>
<td align="right"><code><span class='Function'>¬¨</span><span class='Number'>0</span><span class='Function'>‚àä</span><span class='Value'>ùï©</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>‚à®</span><span class='Modifier'>¬¥</span></code></td>
<td align="right"><code><span class='Number'>1</span><span class='Function'>‚àä</span><span class='Value'>ùï©</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>‚â§</span><span class='Modifier'>¬¥</span></code></td>
<td align="right"><code><span class='Paren'>(</span><span class='Number'>1</span><span class='Function'>-</span><span class='Modifier'>Àú</span><span class='Function'>‚â†</span><span class='Value'>ùï©</span><span class='Paren'>)</span><span class='Function'>‚â†</span><span class='Value'>ùï©</span><span class='Function'>‚äê</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>&lt;</span><span class='Modifier'>¬¥</span></code></td>
<td align="right"><code><span class='Paren'>(</span><span class='Number'>1</span><span class='Function'>-</span><span class='Modifier'>Àú</span><span class='Function'>‚â†</span><span class='Value'>ùï©</span><span class='Paren'>)</span><span class='Function'>=</span><span class='Value'>ùï©</span><span class='Function'>‚äê</span><span class='Number'>1</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>&gt;</span><span class='Modifier'>¬¥</span></code></td>
<td align="right"><code><span class='Number'>2</span><span class='Function'>|</span><span class='Value'>ùï©</span><span class='Function'>‚äê</span><span class='Number'>0</span></code></td>
</tr>
<tr>
<td align="center"><code><span class='Function'>‚â•</span><span class='Modifier'>¬¥</span></code></td>
<td align="right"><code><span class='Function'>¬¨</span><span class='Number'>2</span><span class='Function'>|</span><span class='Value'>ùï©</span><span class='Function'>‚äê</span><span class='Number'>1</span></code></td>
</tr>
</tbody>
</table>
<p>Boolean scans are more varied. For <code><span class='Function'>‚à®</span></code>, the result switches from all <code><span class='Number'>0</span></code> to all <code><span class='Number'>1</span></code> after the first <code><span class='Number'>1</span></code>, and the other way around for <code><span class='Function'>‚àß</span></code>. For <code><span class='Function'>‚â†</span></code>, the associative optimization gives a word-at-a-time algorithm with power-of-two shifts, and other possibilities with architecture support are <a href="#xor-scan">discussed below</a>. The scan <code><span class='Function'>&lt;</span><span class='Modifier'>`</span></code> turns off every other 1 in groups of 1s. It's used in simdjson for backslash escaping, and they <a href="https://github.com/simdjson/simdjson/blob/ac78c62/src/generic/stage1/json_escape_scanner.h#L96">describe in detail</a> a method that uses subtraction for carrying. And <code><span class='Function'>&gt;</span><span class='Modifier'>`</span></code> flips to all 0 at the first bit if it's a 0 or the <em>second</em> 1 bit otherwise; <code><span class='Function'>‚àß</span><span class='Modifier'>`</span><span class='Function'>¬¨</span><span class='Modifier2'>‚åæ</span><span class='Paren'>(</span><span class='Number'>1</span><span class='Modifier2'>‚ä∏</span><span class='Function'>‚Üì</span><span class='Paren'>)</span></code> is one implementation. <code><span class='Function'>‚â§</span><span class='Modifier'>`</span></code> is <code><span class='Function'>&lt;</span><span class='Modifier'>`</span><span class='Modifier2'>‚åæ</span><span class='Function'>¬¨</span></code>, and <code><span class='Function'>‚â•</span><span class='Modifier'>`</span></code> is <code><span class='Function'>&gt;</span><span class='Modifier'>`</span><span class='Modifier2'>‚åæ</span><span class='Function'>¬¨</span></code>.</p>
<p>Simple sequences for a few scans are given below. <code><span class='Function'>‚àß</span><span class='Modifier'>`</span></code> and <code><span class='Function'>‚à®</span><span class='Modifier'>`</span></code> on lists only call for one evaluation where the first 0 or 1 bit is found, but also have nice segmented forms that can be used for a row-scan like <code><span class='Function'>‚àß</span><span class='Modifier'>`Àò</span></code>. Here <code><span class='Value'>even</span></code> is the even bits <code><span class='Number'>0x555</span><span class='Value'>‚Ä¶</span></code>, and <code><span class='Value'>odd</span></code> is the odd bits <code><span class='Value'>even</span><span class='Function'>&lt;&lt;</span><span class='Number'>1</span></code> or <code><span class='Number'>0xAAA</span><span class='Value'>‚Ä¶</span></code>.</p>
<table>
<tr><th>Scan</th><th>C code (word)</th><th>C code (segment starts <code><span class='Value'>m</span></code>)</th></tr>
<tr><td align="center"><code><span class='Function'>‚àß</span><span class='Modifier'>`</span></code></td><td><code><span class='Value'>x</span> <span class='Function'>|</span> <span class='Function'>-</span><span class='Value'>x</span></code>    </td><td><code><span class='Value'>t</span> <span class='Function'>=</span> <span class='Paren'>(</span><span class='Value'>x</span> <span class='Value'>&~</span> <span class='Value'>m</span><span class='Paren'>)</span> <span class='Function'>>></span> <span class='Number'>1</span><span class='Head'>;</span> <span class='Paren'>(</span><span class='Value'>x</span> <span class='Function'>-</span> <span class='Value'>t</span><span class='Paren'>)</span> <span class='Value'>^</span> <span class='Value'>t</span></code></td></tr>
<tr><td align="center"><code><span class='Function'>‚à®</span><span class='Modifier'>`</span></code></td><td><code><span class='Value'>x</span> <span class='Value'>&~</span> <span class='Paren'>(</span><span class='Value'>x</span><span class='Function'>+</span><span class='Number'>1</span><span class='Paren'>)</span></code></td><td><code><span class='Value'>t</span> <span class='Function'>=</span> <span class='Paren'>(</span><span class='Value'>x</span> <span class='Function'>|</span>  <span class='Value'>m</span><span class='Paren'>)</span> <span class='Function'>>></span> <span class='Number'>1</span><span class='Head'>;</span> <span class='Paren'>(</span><span class='Value'>t</span> <span class='Function'>-</span> <span class='Value'>x</span><span class='Paren'>)</span> <span class='Value'>^</span> <span class='Value'>t</span></code></td></tr>
<tr><td align="center"><code><span class='Function'><</span><span class='Modifier'>`</span></code></td><td colspan=2><code><span class='Value'>t</span> <span class='Function'>=</span> <span class='Value'>odd</span>  <span class='Function'>|</span> <span class='Paren'>(</span><span class='Value'>x</span><span class='Function'><<</span><span class='Number'>1</span><span class='Paren'>)</span><span class='Head'>;</span> <span class='Value'>x</span> <span class='Value'>&</span> <span class='Paren'>(</span><span class='Value'>odd</span> <span class='Value'>^</span> <span class='Paren'>(</span><span class='Value'>t</span> <span class='Function'>-</span> <span class='Value'>x</span><span class='Paren'>))</span></code></td></tr>
<tr><td align="center"><code><span class='Function'>‚â§</span><span class='Modifier'>`</span></code></td><td colspan=2><code><span class='Value'>t</span> <span class='Function'>=</span> <span class='Value'>even</span> <span class='Value'>&</span> <span class='Paren'>(</span><span class='Value'>x</span><span class='Function'><<</span><span class='Number'>1</span><span class='Paren'>)</span><span class='Head'>;</span> <span class='Value'>x</span> <span class='Function'>|</span> <span class='Paren'>(</span><span class='Value'>odd</span> <span class='Value'>^</span> <span class='Paren'>(</span><span class='Value'>t</span> <span class='Function'>-</span> <span class='Value'>x</span><span class='Paren'>))</span></code></td></tr>
</table>

<p>Handling carries in lists for <code><span class='Function'>&lt;</span><span class='Modifier'>`</span></code> and <code><span class='Function'>‚â§</span><span class='Modifier'>`</span></code> is possible by modifying <code><span class='Value'>x</span><span class='Function'>&lt;&lt;</span><span class='Number'>1</span></code>, but for shorter dependency chains you modify the result. For example, for <code><span class='Function'>&lt;</span><span class='Modifier'>`</span></code>, a carry of 1 means all the result bits corresponding to trailing 1s in <code><span class='Value'>x</span></code> need to be flipped. If the result from the previous word is <code><span class='Value'>c</span></code> with type <code><span class='Value'>u64</span></code>, the result should by xor-ed with <code><span class='Function'>-</span><span class='Paren'>(</span><span class='Value'>c</span><span class='Function'>&gt;&gt;</span><span class='Number'>63</span><span class='Paren'>)</span> <span class='Value'>&amp;</span> <span class='Value'>x</span> <span class='Value'>&amp;~</span> <span class='Paren'>(</span><span class='Value'>x</span><span class='Function'>+</span><span class='Number'>1</span><span class='Paren'>)</span></code>, where the shared <code><span class='Value'>x</span> <span class='Value'>&amp;</span></code> can be factored out. Note that for <code><span class='Function'>‚â§</span><span class='Modifier'>`</span></code>, the &quot;passive&quot; bit is 1 and so -1 is the right initial carry.</p>
<h3 id="xor-scan"><a class="header" href="#xor-scan">Xor scan</a></h3>
<p>The scan <code><span class='Function'>‚â†</span><span class='Modifier'>`</span></code> has the ordinary implementation using power-of-two shifts, covered in Hacker's Delight section 5-2, &quot;Parity&quot;. Broadcast the carry to the entire word with a signed shift and xor into the next word after scanning it.</p>
<p>If available, carry-less multiply (clmul) can also be used to scan a word, by multiplying by the all-1s word, a trick explained <a href="https://branchfree.org/2019/03/06/code-fragment-finding-quote-pairs-with-carry-less-multiply-pclmulqdq">here</a>. The 128-bit result has an inclusive scan in the low 64 bits and a reverse exclusive scan in the high 64 bits (the top bit is always 0). This is useful because xor-ing high with low gives a word of all carry bits. And the clmul method also works for high-rank <code><span class='Function'>‚â†</span><span class='Modifier'>`</span></code> if the row length <code><span class='Value'>l</span></code> is a divisor of 64, by choosing a mask where every <code><span class='Value'>l</span></code>-th bit is set. Then the high-low trick is much more important because shifting doesn't give a valid carry! For strides of 8 or more, this method might not be faster than AVX2 using element-level operations, but hey, it's free.</p>
<p>In AVX-512, there's a clmul instruction on four 64-bit words, albeit in an inconvenient configuration. There's also the GFNI instruction gf2p8affineqb, which can be used for an inclusive or exclusive xor-scan on groups of 8 bits (or 4, or 2). There's <a href="https://twitter.com/InstLatX64/status/1148247870887419904">a way</a> to combine this with a single 64-bit clmul to do a full 512-bit scan, although it's not all that much faster than doing single clmul instructions.</p>
<h2 id="high-rank-arrays"><a class="header" href="#high-rank-arrays">High-rank arrays</a></h2>
<p>Insert on large cells can be done simply by combining a cell at a time. However, it's fastest to split things up in columns, so that the accumulators can be kept in vector registers instead of written to memory. For small cells, the virtual rows technique described in my reduction talk means that most of the work can be performed as a larger-cell reduction. The speed of the final combination matters when there aren't a large number of rows, and doing it quickly can be tricky.</p>
<p>For long cells, scan on a high-rank array can be done by initializing the first cell and then calling a single vector-vector arithmetic function. For cell length (or stride) <code><span class='Value'>m</span></code>, the function will write to <code><span class='Value'>dst</span><span class='Function'>+</span><span class='Value'>m</span></code> where <code><span class='Value'>dst</span></code> is a pointer to the result, and get its arguments from <code><span class='Value'>dst</span></code> and <code><span class='Value'>src</span><span class='Function'>+</span><span class='Value'>m</span></code> where <code><span class='Value'>src</span></code> points to <code><span class='Value'>ùï©</span></code>. If the function works in order on <code><span class='Value'>k</span><span class='Function'>‚â§</span><span class='Value'>m</span></code> elements at a time, then the <code><span class='Value'>k</span></code> elements it reads from <code><span class='Value'>dst</span></code> have already been written, so this gives the correct result.</p>
<p>If the cell size is a power of two and fits in a vector register, then the parallel strategy for scans on lists still works (the operation that combines cells is still associative and commutative, it's just wider). For odd widths there's some trouble with alignment.</p>
<h3 id="boolean-fold-cells"><a class="header" href="#boolean-fold-cells">Boolean fold-cells</a></h3>
<p>Boolean folds on short rows can be implemented as a segmented scan, or windowed reduction, followed by extracting the appropriate bit from each row. The extraction is the hard part. While it's a special case of <a href="take.html#bit-interleaving-and-uninterleaving">bit uninterleaving</a>, it's better to implement it with a more specialized method. <a href="https://orlp.net/blog/extracting-depositing-bits/">Here's a post</a> on how you might do this extraction on a single word. Believe it or not, for multiple words even the pext-based method is beaten soundly by some generic code! Okay, for even widths it requires a little cheating with SSE2 auto-vectorization. For an odd width, say <code><span class='Value'>f</span></code>, there's a complicated but powerful method relying on the fact that in the first <code><span class='Value'>f</span></code> input words, the row boundaries cover each position within a word exactly once (this follows from the Chinese remainder theorem, since an odd number is relatively prime to each power of two). So the idea is to mask out these bits and combine them into a single word, then un-permute to put them in the right order in the result. There are a lot of complications, so it's described in <a href="#the-modular-bit-permutation">its own section</a>.</p>
<h2 id="the-modular-bit-permutation"><a class="header" href="#the-modular-bit-permutation">The modular bit permutation</a></h2>
<p>This section describes how to perform and use the permutation sending the bit at position <code><span class='Value'>n</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span></code> to position <code><span class='Value'>i</span></code> within each group of <code><span class='Value'>n</span><span class='Gets'>‚Üê</span><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Value'>k</span></code> bits, where <code><span class='Value'>f</span></code> is odd. It's done by a series of swaps, conditionally exchanging pairs of bits separated by a power of two, starting at <code><span class='Value'>n</span><span class='Function'>√∑</span><span class='Number'>2</span></code> and ending at 2. Each swap is a self-inverse, so doing them in the opposite order results in the opposite permutation taking position <code><span class='Value'>i</span></code> to <code><span class='Value'>n</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span></code>.</p>
<p>The direction we focus on here can extract one bit from every <code><span class='Value'>f</span></code>, so it's useful for boolean fold-cells and select-cells picking out a single column. In the other direction, it can spread bits out in the same way: this most directly applies to <a href="take.html#bit-interleaving-and-uninterleaving">take-cells</a> but also works for <a href="replicate.html#constant-replicate">Replicate by constant</a>, and thus broadcasting for Table and leading axis extension.</p>
<h3 id="decomposing-into-swaps"><a class="header" href="#decomposing-into-swaps">Decomposing into swaps</a></h3>
<svg viewBox='-105.4 -44.2 712.8 311.842'>
  <g fill='currentColor' stroke-linecap='round' text-anchor='middle' font-family='BQN,monospace'>
    <rect class='code' stroke-width='1.5' rx='12' x='-41.4' y='-36.2' width='584.8' height='295.842'/>
    <g class='yellow' text-anchor='end' font-size='14'>
      <g opacity='0.25' stroke-width='4'>
        <line x1='51' x2='51' y1='-21.28' y2='23.52'/>
        <line x1='119' x2='119' y1='-21.28' y2='79.52'/>
        <line x1='187' x2='187' y1='-21.28' y2='23.52'/>
        <line x1='255' x2='255' y1='-21.28' y2='150.64'/>
        <line x1='323' x2='323' y1='-21.28' y2='23.52'/>
        <line x1='391' x2='391' y1='-21.28' y2='79.52'/>
        <line x1='459' x2='459' y1='-21.28' y2='23.52'/>
        <line x1='-17' x2='527' y1='23.52' y2='23.52'/>
        <line x1='-17' x2='527' y1='79.52' y2='79.52'/>
        <line x1='-17' x2='527' y1='150.64' y2='150.64'/>
        <line x1='-17' x2='527' y1='240.962' y2='240.962'/>
      </g>
      <text dy='0.32em' x='-16' y='13.5'>2</text>
      <text dy='0.32em' x='-16' y='69.5'>4</text>
      <text dy='0.32em' x='-16' y='140.62'>8</text>
      <text dy='0.32em' x='-16' y='230.942'>16</text>
    </g>
    <g stroke-width='2.5'>
      <g class='purple'>
        <line x1='102' x2='34' y1='11.76' y2='44.24'/>
        <line x1='238' x2='170' y1='11.76' y2='44.24'/>
        <line x1='374' x2='306' y1='11.76' y2='44.24'/>
        <line x1='510' x2='442' y1='11.76' y2='44.24'/>
        <line x1='204' x2='68' y1='67.76' y2='115.36'/>
        <line x1='476' x2='340' y1='67.76' y2='115.36'/>
        <line x1='374' x2='102' y1='138.88' y2='205.682'/>
        <line x1='408' x2='136' y1='138.88' y2='205.682'/>
        <line x1='442' x2='170' y1='138.88' y2='205.682'/>
      </g>
      <g class='red'>
        <line x1='34' x2='102' y1='11.76' y2='44.24'/>
        <line x1='170' x2='238' y1='11.76' y2='44.24'/>
        <line x1='306' x2='374' y1='11.76' y2='44.24'/>
        <line x1='442' x2='510' y1='11.76' y2='44.24'/>
        <line x1='68' x2='204' y1='67.76' y2='115.36'/>
        <line x1='340' x2='476' y1='67.76' y2='115.36'/>
        <line x1='102' x2='374' y1='138.88' y2='205.682'/>
        <line x1='136' x2='408' y1='138.88' y2='205.682'/>
        <line x1='170' x2='442' y1='138.88' y2='205.682'/>
      </g>
    </g>
    <g stroke-width='0.2'>
      <g class='code'>
        <rect x='-9.8' y='-12.8' width='21.6' height='25.6'/>
        <rect x='24.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='58.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='92.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='126.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='160.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='194.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='228.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='262.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='296.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='330.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='364.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='398.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='432.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='466.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='500.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='-9.8' y='43.2' width='21.6' height='25.6'/>
        <rect x='24.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='58.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='92.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='126.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='160.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='194.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='228.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='262.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='296.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='330.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='364.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='398.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='432.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='466.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='500.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='-9.8' y='114.32' width='21.6' height='25.6'/>
        <rect x='24.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='58.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='92.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='126.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='160.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='194.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='228.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='262.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='296.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='330.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='364.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='398.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='432.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='466.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='500.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='-9.8' y='204.642' width='21.6' height='25.6'/>
        <rect x='24.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='58.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='92.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='126.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='160.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='194.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='228.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='262.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='296.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='330.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='364.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='398.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='432.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='466.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='500.2' y='204.642' width='21.6' height='25.6'/>
      </g>
      <g fill='none' stroke='currentColor'>
        <rect x='-9.8' y='-12.8' width='21.6' height='25.6'/>
        <rect x='24.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='58.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='92.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='126.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='160.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='194.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='228.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='262.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='296.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='330.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='364.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='398.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='432.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='466.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='500.2' y='-12.8' width='21.6' height='25.6'/>
        <rect x='-9.8' y='43.2' width='21.6' height='25.6'/>
        <rect x='24.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='58.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='92.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='126.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='160.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='194.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='228.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='262.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='296.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='330.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='364.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='398.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='432.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='466.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='500.2' y='43.2' width='21.6' height='25.6'/>
        <rect x='-9.8' y='114.32' width='21.6' height='25.6'/>
        <rect x='24.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='58.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='92.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='126.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='160.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='194.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='228.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='262.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='296.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='330.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='364.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='398.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='432.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='466.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='500.2' y='114.32' width='21.6' height='25.6'/>
        <rect x='-9.8' y='204.642' width='21.6' height='25.6'/>
        <rect x='24.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='58.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='92.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='126.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='160.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='194.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='228.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='262.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='296.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='330.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='364.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='398.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='432.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='466.2' y='204.642' width='21.6' height='25.6'/>
        <rect x='500.2' y='204.642' width='21.6' height='25.6'/>
      </g>
    </g>
    <g stroke-width='4' stroke='currentColor' stroke-linecap='butt'>
      <line x1='-11' x2='-11' y1='13' y2='11.375'/>
      <line x1='23' x2='23' y1='13' y2='9.75'/>
      <line x1='57' x2='57' y1='13' y2='8.125'/>
      <line x1='91' x2='91' y1='13' y2='6.5'/>
      <line x1='125' x2='125' y1='13' y2='4.875'/>
      <line x1='159' x2='159' y1='13' y2='3.25'/>
      <line x1='193' x2='193' y1='13' y2='1.625'/>
      <line x1='227' x2='227' y1='13' y2='0'/>
      <line x1='261' x2='261' y1='13' y2='-1.625'/>
      <line x1='295' x2='295' y1='13' y2='-3.25'/>
      <line x1='329' x2='329' y1='13' y2='-4.875'/>
      <line x1='363' x2='363' y1='13' y2='-6.5'/>
      <line x1='397' x2='397' y1='13' y2='-8.125'/>
      <line x1='431' x2='431' y1='13' y2='-9.75'/>
      <line x1='465' x2='465' y1='13' y2='-11.375'/>
      <line x1='499' x2='499' y1='13' y2='-13'/>
      <line x1='-11' x2='-11' y1='69' y2='67.375'/>
      <line x1='23' x2='23' y1='69' y2='62.5'/>
      <line x1='57' x2='57' y1='69' y2='64.125'/>
      <line x1='91' x2='91' y1='69' y2='65.75'/>
      <line x1='125' x2='125' y1='69' y2='60.875'/>
      <line x1='159' x2='159' y1='69' y2='56'/>
      <line x1='193' x2='193' y1='69' y2='57.625'/>
      <line x1='227' x2='227' y1='69' y2='59.25'/>
      <line x1='261' x2='261' y1='69' y2='54.375'/>
      <line x1='295' x2='295' y1='69' y2='49.5'/>
      <line x1='329' x2='329' y1='69' y2='51.125'/>
      <line x1='363' x2='363' y1='69' y2='52.75'/>
      <line x1='397' x2='397' y1='69' y2='47.875'/>
      <line x1='431' x2='431' y1='69' y2='43'/>
      <line x1='465' x2='465' y1='69' y2='44.625'/>
      <line x1='499' x2='499' y1='69' y2='46.25'/>
      <line x1='-11' x2='-11' y1='140.12' y2='138.495'/>
      <line x1='23' x2='23' y1='140.12' y2='133.62'/>
      <line x1='57' x2='57' y1='140.12' y2='128.745'/>
      <line x1='91' x2='91' y1='140.12' y2='136.87'/>
      <line x1='125' x2='125' y1='140.12' y2='131.995'/>
      <line x1='159' x2='159' y1='140.12' y2='127.12'/>
      <line x1='193' x2='193' y1='140.12' y2='135.245'/>
      <line x1='227' x2='227' y1='140.12' y2='130.37'/>
      <line x1='261' x2='261' y1='140.12' y2='125.495'/>
      <line x1='295' x2='295' y1='140.12' y2='120.62'/>
      <line x1='329' x2='329' y1='140.12' y2='115.745'/>
      <line x1='363' x2='363' y1='140.12' y2='123.87'/>
      <line x1='397' x2='397' y1='140.12' y2='118.995'/>
      <line x1='431' x2='431' y1='140.12' y2='114.12'/>
      <line x1='465' x2='465' y1='140.12' y2='122.245'/>
      <line x1='499' x2='499' y1='140.12' y2='117.37'/>
      <line x1='-11' x2='-11' y1='230.442' y2='228.817'/>
      <line x1='23' x2='23' y1='230.442' y2='223.942'/>
      <line x1='57' x2='57' y1='230.442' y2='219.067'/>
      <line x1='91' x2='91' y1='230.442' y2='214.192'/>
      <line x1='125' x2='125' y1='230.442' y2='209.317'/>
      <line x1='159' x2='159' y1='230.442' y2='204.442'/>
      <line x1='193' x2='193' y1='230.442' y2='225.567'/>
      <line x1='227' x2='227' y1='230.442' y2='220.692'/>
      <line x1='261' x2='261' y1='230.442' y2='215.817'/>
      <line x1='295' x2='295' y1='230.442' y2='210.942'/>
      <line x1='329' x2='329' y1='230.442' y2='206.067'/>
      <line x1='363' x2='363' y1='230.442' y2='227.192'/>
      <line x1='397' x2='397' y1='230.442' y2='222.317'/>
      <line x1='431' x2='431' y1='230.442' y2='217.442'/>
      <line x1='465' x2='465' y1='230.442' y2='212.567'/>
      <line x1='499' x2='499' y1='230.442' y2='207.692'/>
    </g>
    <text dy='0.32em' x='1' y='0'>0</text>
    <text dy='0.32em' x='35' y='0'>1</text>
    <text dy='0.32em' x='69' y='0'>2</text>
    <text dy='0.32em' x='103' y='0'>3</text>
    <text dy='0.32em' x='137' y='0'>4</text>
    <text dy='0.32em' x='171' y='0'>5</text>
    <text dy='0.32em' x='205' y='0'>6</text>
    <text dy='0.32em' x='239' y='0'>7</text>
    <text dy='0.32em' x='273' y='0'>8</text>
    <text dy='0.32em' x='307' y='0'>9</text>
    <text dy='0.32em' x='341' y='0'>10</text>
    <text dy='0.32em' x='375' y='0'>11</text>
    <text dy='0.32em' x='409' y='0'>12</text>
    <text dy='0.32em' x='443' y='0'>13</text>
    <text dy='0.32em' x='477' y='0'>14</text>
    <text dy='0.32em' x='511' y='0'>15</text>
    <text dy='0.32em' x='1' y='56'>0</text>
    <text dy='0.32em' x='35' y='56'>3</text>
    <text dy='0.32em' x='69' y='56'>2</text>
    <text dy='0.32em' x='103' y='56'>1</text>
    <text dy='0.32em' x='137' y='56'>4</text>
    <text dy='0.32em' x='171' y='56'>7</text>
    <text dy='0.32em' x='205' y='56'>6</text>
    <text dy='0.32em' x='239' y='56'>5</text>
    <text dy='0.32em' x='273' y='56'>8</text>
    <text dy='0.32em' x='307' y='56'>11</text>
    <text dy='0.32em' x='341' y='56'>10</text>
    <text dy='0.32em' x='375' y='56'>9</text>
    <text dy='0.32em' x='409' y='56'>12</text>
    <text dy='0.32em' x='443' y='56'>15</text>
    <text dy='0.32em' x='477' y='56'>14</text>
    <text dy='0.32em' x='511' y='56'>13</text>
    <text dy='0.32em' x='1' y='127.12'>0</text>
    <text dy='0.32em' x='35' y='127.12'>3</text>
    <text dy='0.32em' x='69' y='127.12'>6</text>
    <text dy='0.32em' x='103' y='127.12'>1</text>
    <text dy='0.32em' x='137' y='127.12'>4</text>
    <text dy='0.32em' x='171' y='127.12'>7</text>
    <text dy='0.32em' x='205' y='127.12'>2</text>
    <text dy='0.32em' x='239' y='127.12'>5</text>
    <text dy='0.32em' x='273' y='127.12'>8</text>
    <text dy='0.32em' x='307' y='127.12'>11</text>
    <text dy='0.32em' x='341' y='127.12'>14</text>
    <text dy='0.32em' x='375' y='127.12'>9</text>
    <text dy='0.32em' x='409' y='127.12'>12</text>
    <text dy='0.32em' x='443' y='127.12'>15</text>
    <text dy='0.32em' x='477' y='127.12'>10</text>
    <text dy='0.32em' x='511' y='127.12'>13</text>
    <text dy='0.32em' x='1' y='217.442'>0</text>
    <text dy='0.32em' x='35' y='217.442'>3</text>
    <text dy='0.32em' x='69' y='217.442'>6</text>
    <text dy='0.32em' x='103' y='217.442'>9</text>
    <text dy='0.32em' x='137' y='217.442'>12</text>
    <text dy='0.32em' x='171' y='217.442'>15</text>
    <text dy='0.32em' x='205' y='217.442'>2</text>
    <text dy='0.32em' x='239' y='217.442'>5</text>
    <text dy='0.32em' x='273' y='217.442'>8</text>
    <text dy='0.32em' x='307' y='217.442'>11</text>
    <text dy='0.32em' x='341' y='217.442'>14</text>
    <text dy='0.32em' x='375' y='217.442'>1</text>
    <text dy='0.32em' x='409' y='217.442'>4</text>
    <text dy='0.32em' x='443' y='217.442'>7</text>
    <text dy='0.32em' x='477' y='217.442'>10</text>
    <text dy='0.32em' x='511' y='217.442'>13</text>
  </g>
</svg>

<p>First we'll prove that a modular permutation does actually decompose into swap operations. Here's the intuitive case: consider the permutation where index <code><span class='Value'>i</span></code> has value <code><span class='Number'>16</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>√ó</span><span class='Value'>i</span></code> (meaning, that's the original index of the bit that ends up at <code><span class='Value'>i</span></code>). At positions <code><span class='Value'>i</span></code> and <code><span class='Number'>8</span><span class='Function'>+</span><span class='Value'>i</span></code>, <code><span class='Value'>i</span><span class='Function'>&lt;</span><span class='Number'>8</span></code>, we have <code><span class='Number'>16</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>√ó</span><span class='Value'>i</span></code> and <code><span class='Number'>16</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>√ó</span><span class='Paren'>(</span><span class='Number'>8</span><span class='Function'>+</span><span class='Value'>i</span><span class='Paren'>)</span></code> or <code><span class='Number'>16</span><span class='Function'>|</span><span class='Number'>8</span><span class='Function'>+</span><span class='Number'>5</span><span class='Function'>√ó</span><span class='Value'>i</span></code>. These values are different, but both are congruent to <code><span class='Number'>5</span><span class='Function'>√ó</span><span class='Value'>i</span></code> (mod 8), so one of them is <code><span class='Number'>8</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>√ó</span><span class='Value'>i</span></code> and the other is <code><span class='Number'>8</span><span class='Function'>+</span><span class='Number'>8</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>√ó</span><span class='Value'>i</span></code>. These are the values at positions <code><span class='Value'>i</span></code> and <code><span class='Number'>8</span><span class='Function'>+</span><span class='Value'>i</span></code> in the permutation that applies <code><span class='Number'>8</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>√ó</span><span class='Value'>i</span></code> within each byte, so to extend that permutation from size 8 to size 16 what we need to do is swap these bits if <code><span class='Number'>16</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>√ó</span><span class='Value'>i</span></code> isn't equal to <code><span class='Number'>8</span><span class='Function'>|</span><span class='Number'>5</span><span class='Function'>√ó</span><span class='Value'>i</span></code>.</p>
<p>To handle it more rigorously, suppose we have performed our permutation of size <code><span class='Value'>h</span></code> so the value at <code><span class='Value'>i</span></code> is <code><span class='Paren'>(</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span></code> and want to extend this to size <code><span class='Value'>l</span> <span class='Gets'>‚Üê</span> <span class='Number'>2</span><span class='Function'>√ó</span><span class='Value'>h</span></code>. Define <code><span class='Function'>B</span> <span class='Gets'>‚Üê</span> <span class='Brace'>{</span><span class='Paren'>(</span><span class='Value'>l</span><span class='Function'>|</span><span class='Value'>ùï©</span><span class='Paren'>)</span> <span class='Function'>-</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>ùï©</span><span class='Brace'>}</span></code>, noting that <code><span class='Value'>h</span><span class='Function'>|B</span><span class='Value'>ùï©</span></code> is always 0. We will show that the value to be moved to <code><span class='Value'>i</span></code> appears at <code><span class='Value'>j</span> <span class='Gets'>‚Üê</span> <span class='Paren'>(</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Paren'>(</span><span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span><span class='Paren'>)</span></code>. Since <code><span class='Value'>h</span><span class='Function'>|</span><span class='Value'>j</span></code> is <code><span class='Value'>h</span><span class='Function'>|</span><span class='Value'>i</span></code> after dropping <code><span class='Function'>B</span></code> terms, we have:</p>
<pre>   <span class='Paren'>(</span><span class='Value'>j</span> <span class='Function'>-</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>j</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>j</span>
<span class='Gets'>‚Üê‚Üí</span> <span class='Paren'>(</span><span class='Value'>j</span> <span class='Function'>-</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span>
<span class='Gets'>‚Üê‚Üí</span> <span class='Paren'>(((</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Paren'>(</span><span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span><span class='Paren'>))</span> <span class='Function'>-</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span>
<span class='Gets'>‚Üê‚Üí</span> <span class='Paren'>(</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Paren'>((</span><span class='Function'>B</span> <span class='Value'>i</span><span class='Paren'>)</span><span class='Function'>+</span><span class='Value'>h</span><span class='Function'>|</span><span class='Value'>i</span><span class='Paren'>))</span> <span class='Function'>+</span> <span class='Paren'>((</span><span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span><span class='Paren'>)</span><span class='Function'>+</span><span class='Value'>h</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span><span class='Paren'>)</span>
<span class='Gets'>‚Üê‚Üí</span> <span class='Paren'>(</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Value'>l</span><span class='Function'>|</span><span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Value'>l</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span>
</pre>
<p>as desired. Now, what does this extending mapping do? In C terminology <code><span class='Function'>B</span> <span class='Value'>i</span></code> is the bit mask <code><span class='Value'>i</span> <span class='Value'>&amp;</span> <span class='Value'>h</span></code>, so <code><span class='Value'>j</span></code> is <code><span class='Value'>i</span></code> with this bit replaced with the one from <code><span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span></code>. With a lot of algebra it's possible to prove that our transformation is a self-inverse: to give a sketch, <code><span class='Function'>B</span> <span class='Value'>j</span></code> is <code><span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span></code> which means <code><span class='Value'>j</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>j</span></code> is <code><span class='Value'>i</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>i</span></code>, and <code><span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>j</span></code> works out to <code><span class='Function'>B</span> <span class='Value'>i</span></code> using the facts that <code><span class='Value'>l</span><span class='Function'>|B</span><span class='Value'>ùï©</span></code> and <code><span class='Value'>l</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>√óB</span><span class='Value'>ùï©</span></code> are <code><span class='Function'>B</span><span class='Value'>ùï©</span></code> and <code><span class='Value'>l</span><span class='Function'>|</span><span class='Number'>2</span><span class='Function'>√óB</span><span class='Value'>ùï©</span></code> is 0 (with <code><span class='Value'>ùï©</span><span class='Function'>=</span><span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span></code> for that last one). Then <code><span class='Paren'>(</span><span class='Value'>j</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>j</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Paren'>(</span><span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>j</span><span class='Paren'>)</span></code> is <code><span class='Paren'>(</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Paren'>(</span><span class='Function'>B</span> <span class='Value'>i</span><span class='Paren'>)</span></code>, giving back <code><span class='Value'>i</span></code>! We can conclude that it either swaps positions <code><span class='Value'>i</span></code> and <code><span class='Value'>i</span> <span class='Value'>^</span> <span class='Value'>h</span></code>, where <code><span class='Value'>^</span></code> is bitwise xor, or leaves them alone.</p>
<p>The example below shows the steps for the modular permutation with factor 3 on size 16. The first one is the identity: this is always true because <code><span class='Value'>f</span></code> is odd, so <code><span class='Number'>1</span><span class='Function'>=</span><span class='Number'>2</span><span class='Function'>|</span><span class='Value'>f</span></code> and <code><span class='Number'>2</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span></code> is <code><span class='Number'>2</span><span class='Function'>|</span><span class='Value'>i</span></code>.</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=ZiDihpAgMwpTdGVwIOKGkCB7IGjwnZWKaToKICBsIOKGkCAyw5doCiAgQiDihpAgeyhsfPCdlakpIC0gaHzwnZWpfQogIChpIC0gQiBpKSArIEIgZsOXaQp9Cgo+IHMxNiDihpAgMeKAvzLigL804oC/OCBTdGVwwqggPOKGlTE2Cj4g4oqPy5xgIHMxNiAgIyBTdWNjZXNzaXZlbHkgYXBwbHkgc3RlcHMKMTYgfCBmIMOXIOKGlTE2ICAjIEl0IG1hdGNoZXMh">‚ÜóÔ∏è</a><pre>    <span class='Value'>f</span> <span class='Gets'>‚Üê</span> <span class='Number'>3</span>
    <span class='Function'>Step</span> <span class='Gets'>‚Üê</span> <span class='Brace'>{</span> <span class='Value'>h</span><span class='Function'>ùïä</span><span class='Value'>i</span><span class='Head'>:</span>
      <span class='Value'>l</span> <span class='Gets'>‚Üê</span> <span class='Number'>2</span><span class='Function'>√ó</span><span class='Value'>h</span>
      <span class='Function'>B</span> <span class='Gets'>‚Üê</span> <span class='Brace'>{</span><span class='Paren'>(</span><span class='Value'>l</span><span class='Function'>|</span><span class='Value'>ùï©</span><span class='Paren'>)</span> <span class='Function'>-</span> <span class='Value'>h</span><span class='Function'>|</span><span class='Value'>ùï©</span><span class='Brace'>}</span>
      <span class='Paren'>(</span><span class='Value'>i</span> <span class='Function'>-</span> <span class='Function'>B</span> <span class='Value'>i</span><span class='Paren'>)</span> <span class='Function'>+</span> <span class='Function'>B</span> <span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span>
    <span class='Brace'>}</span>

    <span class='Function'>&gt;</span> <span class='Value'>s16</span> <span class='Gets'>‚Üê</span> <span class='Number'>1</span><span class='Ligature'>‚Äø</span><span class='Number'>2</span><span class='Ligature'>‚Äø</span><span class='Number'>4</span><span class='Ligature'>‚Äø</span><span class='Number'>8</span> <span class='Function'>Step</span><span class='Modifier'>¬®</span> <span class='Function'>&lt;‚Üï</span><span class='Number'>16</span>
‚îå‚îÄ                                           
‚ïµ 0 1 2  3  4  5 6 7 8  9 10 11 12 13 14 15  
  0 3 2  1  4  7 6 5 8 11 10  9 12 15 14 13  
  0 1 6  3  4  5 2 7 8  9 14 11 12 13 10 15  
  0 1 2 11 12 13 6 7 8  9 10  3  4  5 14 15  
                                            ‚îò
    <span class='Function'>&gt;</span> <span class='Function'>‚äè</span><span class='Modifier'>Àú`</span> <span class='Value'>s16</span>  <span class='Comment'># Successively apply steps
</span>‚îå‚îÄ                                          
‚ïµ 0 1 2 3  4  5 6 7 8  9 10 11 12 13 14 15  
  0 3 2 1  4  7 6 5 8 11 10  9 12 15 14 13  
  0 3 6 1  4  7 2 5 8 11 14  9 12 15 10 13  
  0 3 6 9 12 15 2 5 8 11 14  1  4  7 10 13  
                                           ‚îò
    <span class='Number'>16</span> <span class='Function'>|</span> <span class='Value'>f</span> <span class='Function'>√ó</span> <span class='Function'>‚Üï</span><span class='Number'>16</span>  <span class='Comment'># It matches!
</span>‚ü® 0 3 6 9 12 15 2 5 8 11 14 1 4 7 10 13 ‚ü©
</pre>
<p>Applying the steps backwards gives the inverse, where index 1 goes to position 3, 2 to 6, and so on. This is also the original direction with factor 11, which is the inverse of 3 modulo 16.</p>
<a class="replLink" title="Open in the REPL" target="_blank" href="https://mlochbaum.github.io/BQN/try.html#code=ZiDihpAgMwpTdGVwIOKGkCB7IGjwnZWKaToKICBsIOKGkCAyw5doCiAgQiDihpAgeyhsfPCdlakpIC0gaHzwnZWpfQogIChpIC0gQiBpKSArIEIgZsOXaQp9Cj4gczE2IOKGkCAx4oC/MuKAvzTigL84IFN0ZXDCqCA84oaVMTYK4oqPwrQgczE2CgoxNiB8IDExIMOXIOKGlTE2CgoxNiB8IDMgw5cgMTE=">‚ÜóÔ∏è</a><pre>    <span class='Function'>‚äè</span><span class='Modifier'>¬¥</span> <span class='Value'>s16</span>
‚ü® 0 11 6 1 12 7 2 13 8 3 14 9 4 15 10 5 ‚ü©

    <span class='Number'>16</span> <span class='Function'>|</span> <span class='Number'>11</span> <span class='Function'>√ó</span> <span class='Function'>‚Üï</span><span class='Number'>16</span>
‚ü® 0 11 6 1 12 7 2 13 8 3 14 9 4 15 10 5 ‚ü©

    <span class='Number'>16</span> <span class='Function'>|</span> <span class='Number'>3</span> <span class='Function'>√ó</span> <span class='Number'>11</span>
1
</pre>
<h3 id="evaluating-swaps"><a class="header" href="#evaluating-swaps">Evaluating swaps</a></h3>
<p>So we know that step that widens permutation units from <code><span class='Value'>h</span></code> to <code><span class='Number'>2</span><span class='Function'>√ó</span><span class='Value'>h</span></code> swaps bit <code><span class='Value'>i</span></code> with bit <code><span class='Value'>i</span> <span class='Value'>^</span> <span class='Value'>h</span></code> whenever <code><span class='Value'>i</span> <span class='Value'>&amp;</span> <span class='Value'>h</span></code> isn't equal to <code><span class='Paren'>(</span><span class='Value'>f</span><span class='Function'>√ó</span><span class='Value'>i</span><span class='Paren'>)</span> <span class='Value'>&amp;</span> <span class='Value'>h</span></code>. There are various ways to compute this given a bitmask of which values to swap, which depends on <code><span class='Value'>f</span></code>. The data needed is just the bits for <code><span class='Value'>i</span></code> in <code><span class='Function'>‚Üï</span><span class='Value'>h</span></code>, that is, <code><span class='Value'>h</span><span class='Function'>‚â§</span><span class='Paren'>(</span><span class='Number'>2</span><span class='Function'>√ó</span><span class='Value'>h</span><span class='Paren'>)</span><span class='Function'>|</span><span class='Value'>f</span><span class='Function'>√ó‚Üï</span><span class='Value'>h</span></code>, as the remaining bits <code><span class='Value'>h</span><span class='Function'>‚Üì‚Üï</span><span class='Number'>2</span><span class='Function'>√ó</span><span class='Value'>h</span></code> are the same. I know of two good ways to apply it, and a shortcut:</p>
<ul>
<li>Using xor, <code><span class='Value'>d</span> <span class='Function'>=</span> <span class='Paren'>(</span><span class='Value'>x</span> <span class='Value'>^</span> <span class='Value'>x</span><span class='Function'>&lt;&lt;</span><span class='Value'>h</span><span class='Paren'>)</span> <span class='Value'>&amp;</span> <span class='Value'>hi</span></code>, <code><span class='Value'>x</span> <span class='Value'>^</span> <span class='Paren'>(</span><span class='Value'>d</span> <span class='Function'>|</span> <span class='Value'>d</span><span class='Function'>&gt;&gt;</span><span class='Value'>h</span><span class='Paren'>)</span></code> with high-bits mask <code><span class='Value'>hi</span></code>.</li>
<li>With a swap-halves function, <code><span class='Paren'>(</span><span class='Value'>x</span> <span class='Value'>&amp;~</span> <span class='Value'>m</span><span class='Paren'>)</span> <span class='Function'>|</span> <span class='Paren'>(</span><span class='Value'>swap</span><span class='Paren'>(</span><span class='Value'>x</span><span class='Paren'>)</span> <span class='Value'>&amp;</span> <span class='Value'>m</span><span class='Paren'>)</span></code> with full mask <code><span class='Value'>m</span></code>.</li>
<li>Also, any permutation on each byte can be done with two shuffle instructions.</li>
</ul>
<p>A swap-halves function can be a rotate instruction on elements of width <code><span class='Number'>2</span><span class='Function'>√ó</span><span class='Value'>h</span></code>, or can be done with a shuffle on elements of width <code><span class='Value'>h</span></code> or smaller.</p>
<p>The total data to permute width <code><span class='Value'>l</span></code> is 2+4+‚Ä¶<code><span class='Value'>l</span><span class='Function'>√∑</span><span class='Number'>2</span></code> bits, or <code><span class='Value'>l</span><span class='Function'>-</span><span class='Number'>2</span></code>. It can be precomputed for each odd factor <code><span class='Value'>f</span><span class='Function'>&lt;</span><span class='Value'>l</span></code> (which covers larger factors too, since <code><span class='Value'>f</span><span class='Function'>+</span><span class='Value'>k</span><span class='Function'>√ó</span><span class='Value'>l</span></code> permutes as <code><span class='Value'>f</span></code>). Then it just needs to be read from a table and unpacked into individual mask vectors. These mask vectors could also be computed directly with multiplication and some bit shuffling; I'm not sure how this would compare in speed.</p>
<h3 id="collecting-bits"><a class="header" href="#collecting-bits">Collecting bits</a></h3>
<p>The bits to be passed into the modular permutation need to be collected from the argument (possibly after some processing), one bit out of each <code><span class='Value'>f</span></code>. Or, in the other direction, they need to be distributed to the result. This can be done by generating a bitmask of the required position in each register. Then an argument register is and-ed with the bitmask and or-ed into a running total. But generating the bitmask is slow. For example, with row size under 64, updating the mask <code><span class='Value'>m</span></code> for the next word is <code><span class='Value'>m</span><span class='Function'>&gt;&gt;</span><span class='Value'>r</span> <span class='Function'>|</span> <span class='Value'>m</span><span class='Function'>&lt;&lt;</span><span class='Value'>l</span></code> for appropriately-chosen shifts <code><span class='Value'>l</span></code> and <code><span class='Value'>r</span></code>: this is a lot of instructions at each step! For small factors, an unrolled loop with saved masks works; for larger factors, it gets to be a lot of code, and eventually you'll run out of registers.</p>
<svg viewBox='-192 -8 816 314.8'>
  <g fill='currentColor' text-anchor='middle' font-family='BQN,monospace'>
    <rect class='code' stroke-width='1.5' rx='12' x='0' y='0' width='432' height='298.8'/>
    <g stroke-width='10' stroke='#521f5e' opacity='0.1'>
      <line x1='18' x2='414' y1='90' y2='90'/>
      <line x1='18' x2='414' y1='126' y2='126'/>
      <line x1='18' x2='414' y1='162' y2='162'/>
      <line x1='18' x2='414' y1='198' y2='198'/>
      <line x1='18' x2='414' y1='234' y2='234'/>
    </g>
    <g stroke-width='10' stroke='#991814' opacity='0.25'>
      <line x1='18' x2='414' y1='270' y2='270'/>
    </g>
    <g stroke-width='10' stroke='#7f651c' opacity='0.1'>
      <line x1='158.4' x2='158.4' y1='8' y2='290.8'/>
      <line x1='230.4' x2='230.4' y1='8' y2='290.8'/>
      <line x1='302.4' x2='302.4' y1='8' y2='290.8'/>
      <line x1='374.4' x2='374.4' y1='8' y2='290.8'/>
    </g>
    <g font-size='28'>
      <text dy='0.32em' x='64.8' y='39.6'>&</text>
    </g>
    <g font-size='18'>
      <text dy='0.32em' x='158.4' y='28.6'>0|4|‚Ä¶|20</text>
      <text dy='0.32em' x='230.4' y='50.6'>1|5|‚Ä¶|17</text>
      <text dy='0.32em' x='302.4' y='28.6'>2|6|‚Ä¶|18</text>
      <text dy='0.32em' x='374.4' y='50.6'>3|7|‚Ä¶|19</text>
      <text dy='0.32em' x='64.8' y='90'>0|‚Ä¶|3</text>
      <text dy='0.32em' x='64.8' y='126'>4|‚Ä¶|7</text>
      <text dy='0.32em' x='64.8' y='162'> 8|‚Ä¶|11</text>
      <text dy='0.32em' x='64.8' y='198'>12|‚Ä¶|15</text>
      <text dy='0.32em' x='64.8' y='234'>16|‚Ä¶|19</text>
      <text dy='0.32em' x='64.8' y='270'>20|‚Ä¶|2 </text>
    </g>
    <g font-size='20'>
      <text dy='0.32em' x='158.4' y='90'>0</text>
      <text dy='0.32em' x='230.4' y='90'>1</text>
      <text dy='0.32em' x='302.4' y='90'>2</text>
      <text dy='0.32em' x='374.4' y='90'>3</text>
      <text dy='0.32em' x='158.4' y='126'>4</text>
      <text dy='0.32em' x='230.4' y='126'>5</text>
      <text dy='0.32em' x='302.4' y='126'>6</text>
      <text dy='0.32em' x='374.4' y='126'>7</text>
      <text dy='0.32em' x='158.4' y='162'>8</text>
      <text dy='0.32em' x='230.4' y='162'>9</text>
      <text dy='0.32em' x='302.4' y='162'>10</text>
      <text dy='0.32em' x='374.4' y='162'>11</text>
      <text dy='0.32em' x='158.4' y='198'>12</text>
      <text dy='0.32em' x='230.4' y='198'>13</text>
      <text dy='0.32em' x='302.4' y='198'>14</text>
      <text dy='0.32em' x='374.4' y='198'>15</text>
      <text dy='0.32em' x='158.4' y='234'>16</text>
      <text dy='0.32em' x='230.4' y='234'>17</text>
      <text dy='0.32em' x='302.4' y='234'>18</text>
      <text dy='0.32em' x='374.4' y='234'>19</text>
      <text dy='0.32em' x='158.4' y='270'>20|0</text>
      <text dy='0.32em' x='230.4' y='270'>1</text>
      <text dy='0.32em' x='302.4' y='270'>2</text>
    </g>
  </g>
</svg>

<p>Since one modular permutation is needed for every <code><span class='Value'>f</span></code> expanded registers, a better approach is to structure it as a loop of length <code><span class='Value'>f</span></code> and unroll this loop. An unrolled iteration handling 4 adjacent registers works with a mask that combines the selected bits from all those registers, and at the end of the iteration it's advanced by 4 steps‚Äîthis is the same operation as advancing once, just with different shifts. So that contains iterations 0|1|2|3, then 4|5|6|7, and so on. In addition to this &quot;horizontal&quot; mask we need 4 pre-computed &quot;vertical&quot; masks to distinguish within an iteration: one mask combines register 0 of each iteration 0|4|8|‚Ä¶, another does 1|5|9|‚Ä¶, and so on. So the intersection of one horizontal and one vertical mask correctly handles a particular register. The unrolled iteration applies the vertical mask to each of the 4 registers, and the horizontal one to them as a whole. So:</p>
<ul>
<li>When extracting, add <code><span class='Value'>h</span> <span class='Value'>&amp;</span> <span class='Paren'>((</span><span class='Value'>i0&amp;v0</span><span class='Paren'>)</span> <span class='Function'>|</span> <span class='Value'>...</span> <span class='Function'>|</span> <span class='Paren'>(</span><span class='Value'>i3&amp;v3</span><span class='Paren'>))</span></code> to the running total.</li>
<li>When depositing, set <code><span class='Value'>c</span> <span class='Function'>=</span> <span class='Value'>h</span> <span class='Value'>&amp;</span> <span class='Value'>p</span></code>, and use <code><span class='Value'>c&amp;v0</span></code>, ... <code><span class='Value'>c&amp;v3</span></code>.</li>
</ul>
<p>where <code><span class='Value'>h</span></code> is the horizontal mask and <code><span class='Value'>v0</span></code>‚Ä¶<code><span class='Value'>v3</span></code> are vertical ones, <code><span class='Value'>i0</span></code>‚Ä¶<code><span class='Value'>i3</span></code> are input registers, and <code><span class='Value'>p</span></code> is a combined output resulting from a permutation.</p>
<p>For the partial iteration at the end, the combined mask stops working! Take <code><span class='Value'>f</span><span class='Gets'>‚Üê</span><span class='Number'>15</span></code> for example. The last iteration starts at register 12, and the mask will combine iterations 12, 13, and 14, but also 15, which is iteration 0 of the <em>next</em> length-<code><span class='Value'>f</span></code> loop. This means <code><span class='Value'>h&amp;v0</span></code> contains iterations 0 and 12, so it will incorrectly pick out extra bits. The last iteration also has a variable length, so a dedicated loop with a single-register mask is a fine approach.</p>
<h3 id="handling-even-factors"><a class="header" href="#handling-even-factors">Handling even factors</a></h3>
<p>When the size of a row is a multiple of two, it's no longer relatively prime to the register size. In general, a given size needs to be split into a power of two times an odd number, and some other method is needed to handle powers to two. Fortunately SIMD architectures usually have some useful instructions for this; generic code may not be so fast.</p>
<p>It's possible to apply these methods in completely separate calls. For example, <code><span class='Number'>28</span><span class='Function'>/</span><span class='Value'>ùï©</span></code> is <code><span class='Number'>4</span><span class='Function'>/</span><span class='Number'>7</span><span class='Function'>/</span><span class='Value'>ùï©</span></code>, and <code><span class='Function'>‚àß</span><span class='Modifier'>ÀùÀò</span><span class='Value'>ùï©</span></code> on rows of length 28 can be implemented as reductions of length 4 then 7, that is, <code><span class='Function'>‚àß</span><span class='Modifier'>ÀùÀò</span><span class='Function'>‚àß</span><span class='Modifier'>Àù</span><span class='Modifier2'>‚éâ</span><span class='Number'>1</span> <span class='Modifier2'>‚àò</span><span class='Ligature'>‚Äø</span><span class='Number'>7</span><span class='Ligature'>‚Äø</span><span class='Number'>4</span><span class='Function'>‚•ä</span><span class='Value'>ùï©</span></code>. This is great with 4 and larger powers of two if they have a solid SIMD implementation; place the power of two on the larger side.</p>
<p>A multiple of 2 or maybe 4 can be fused in as well. To avoid permuting any extra registers, it should be placed just before the permutation (for a fold; after for expansion). That is, condense every <code><span class='Number'>2</span><span class='Function'>√ó</span><span class='Value'>f</span></code> bits from <code><span class='Value'>f</span></code> registers of the argument, and again from the next <code><span class='Value'>f</span></code> registers. Then pack every other bit of these two registers together. This gives a register where each half needs to be permuted, which can be done with the normal permutation code either by skipping the last iteration or zeroing out the mask for it.</p>
