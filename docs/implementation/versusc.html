<head>
  <link href="../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../style.css" rel="stylesheet"/>
  <title>Performance in BQN versus C</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../index.html">BQN</a> / <a href="index.html">implementation</a></div>
<h1 id="performance-in-bqn-versus-c"><a class="header" href="#performance-in-bqn-versus-c">Performance in BQN versus C</a></h1>
<p>The title alone! You know BQN has some fast <a href="perf.html">performance</a> to wave around!</p>
<p>If you think it's paradoxical that programs written for CBQN, a C-based interpreter, might outperform programs written directly in C, it's because you think performance comes from the language implementation. Not so: performance comes from the programmer, taking advantage of the features offered by their language implementation. The difficulty of doing so has two consequences:</p>
<ul>
<li>BQN programs can and do outperform equivalent C programs.</li>
<li>Your BQN programs are unlikely to outperform equivalent C programs.</li>
</ul>
<p>Because once you have a working program, you are probably going to come to the realization that you'd rather do something else with your time than study and optimize until it can beat the C program that you never even wrote in the first place. You wouldn't have made the C program as fast as possible either: that only makes sense for programs that are used over and over in a performance-sensitive context and simple enough to optimize well. Like‚Ä¶ the CBQN interpreter.</p>
<p>Here's a highly authoritative graph on how the effort to speed tradeoff could work, in one case, maybe.</p>
<svg viewBox='-60 -25 376 178'>
  <g stroke-width='1.8' font-size='13px' text-anchor='middle' fill='currentColor'>
    <rect class='code' stroke-width='1' rx='6' x='-20' y='-20' width='296' height='168'/>
    <g class='purple' stroke-width='1' opacity='0.4'>
      <rect x='220.4' y='-10' width='45.6' height='148'/>
      <text transform='rotate(-90)' dy='0.2em' x='-64' y='256'>Non-portable</text>
    </g>
    <text class='bluegreen' x='238.08' y='7.68'>C</text>
    <text class='green' x='186.88' y='25.6'>BQN</text>
    <g opacity='0.8'>
      <text dy='1em' x='128' y='128'>Effort</text>
      <text transform='rotate(-90)' dy='-0.35em' x='-64' y='0'>Speed</text>
    </g>
    <path class='Paren' stroke-width='1.2' stroke='currentColor' fill='none' d='M0 0V128H256'/>
    <path class='bluegreen' style='fill:none' d='M102.4 89.6C115.2 25.6 212.48 57.6 238.08 19.2C248.32 3.84 256 0 256 0'/>
    <path class='green' style='fill:none' d='M0 128C51.2 83.2 128 89.6 153.6 51.2C166.4 32 204.8 32 204.8 32'/>
  </g>
</svg>

<p>I'm considering something basically straightforward (no big algorithmic improvements) and that can be implemented with whole arrays, but not trivially. BQN lets you quickly write a working program, but the easy way usually involves lots of small arrays and slow iteration. C on the other hand is notorious for being hard to write, but once you do it you'll get good performance if you didn't cut corners. Going beyond to get the most out of a CPU takes a lot more work, and often manual use of SIMD or other intrinsics, which isn't portable. CBQN gives you access to some of those methods without as much effort, which is how it can end up beating a basic C program. But evaluating one primitive at a time has overhead, so it's never as good as specialized C.</p>
<p>A major factor that separates low- and high-performance programs in both C and BQN is not actually time spent but experience with the required programming techniques. In portable C this means branchless tricks, bit manipulation, and writing things an auto-vectorizer can handle. In BQN it's a totally different set of skills needed to write in an array-oriented style. Surprisingly, non-portable C often benefits from those array-oriented skills as well: I often find better ways to implement BQN primitives by thinking in terms of other primitives!</p>
<h2 id="case-studies"><a class="header" href="#case-studies">Case studies</a></h2>
<p>All right, how can I so confidently claim that CBQN can‚Äîsometimes‚Äîbe faster than C in practice? First off, there's a certain class of problems where it's routine: BQN primitives. Every one that does anything, really. Scan, Transpose, Indices, Sort, Modulus, Reshape. And so on. We write the ordinary C implementation, and it's just not good enough, so we have to use lookup tables, SIMD, blocked multi-pass techniques, and more. A 10x improvement over ordinary C code is completely normal. But this is the best possible case for BQN; combinations of primitives never do so well.</p>
<p>Small real-world problems can still show a major difference. In my first talk at Dyalog (<a href="https://dyalog.tv/Dyalog17/?v=2KnrDmZov4U">video</a>, <a href="https://www.dyalog.com/uploads/conference/dyalog17/presentations/D08_Moving_Bits_Faster_in_Dyalog_16.zip">zipped slides</a>), as well as a follow-up next year (<a href="https://dyalog.tv/Dyalog18/?v=-6no6N3i9Tg">video</a>, <a href="https://www.dyalog.com/uploads/conference/dyalog18/presentations/D15_The_Interpretive_Advantage.zip">zipped slides</a>), I considered the problem of replacing every CRLF line ending in a file with just the second character LF. BQN nails this one, breaking even with C at a little under 200 bytes and hitting 5x C's speed on inputs of a few thousand bytes or more in my testing. That's with AVX-512 disabled; with it BQN is over 10x faster until cache becomes a bottleneck.</p>
<details><summary>(Benchmark details)</summary>

<p>The benchmark is run with a CRLF every 100 characters on average, placed with a simple LCG for reproducibility. This is just the number I picked in the Dyalog presentation and isn't particularly favorable to BQN, as it only gets an advantage from sparse Replicate at lower densities like 1/1000 and branching C code would be penalized at higher ones like 1/4. C code is also taken from the Dyalog talk. gcc 12.2.1 generates short branching code with the <code><span class='Value'>if</span></code>-based function, while clang 15.0.7 converts both functions to branchless and unrolls by a factor of 4. The two are very close in speed with density 1/100, and gcc is slightly faster at lower densities and much slower at high ones.</p>
<p>lineending.bqn:</p>
<pre><span class='Value'>cr</span><span class='Ligature'>‚Äø</span><span class='Value'>lf</span> <span class='Gets'>‚Üê</span> <span class='String'>@</span><span class='Function'>+</span><span class='Number'>13</span><span class='Ligature'>‚Äø</span><span class='Number'>10</span>
<span class='Function'>CRLF_to_LF</span> <span class='Gets'>‚Üê</span> <span class='Paren'>(</span><span class='Value'>cr</span><span class='Modifier2'>‚ä∏</span><span class='Function'>‚â†</span> <span class='Function'>‚à®</span> <span class='Nothing'>¬∑</span><span class='Function'>¬´</span><span class='Value'>lf</span><span class='Modifier2'>‚ä∏</span><span class='Function'>‚â†</span><span class='Paren'>)</span><span class='Modifier2'>‚ä∏</span><span class='Function'>/</span>

<span class='Value'>n</span> <span class='Gets'>‚Üê</span> <span class='Number'>1e6</span> <span class='Separator'>‚ãÑ</span> <span class='Value'>m</span> <span class='Gets'>‚Üê</span> <span class='Value'>n</span><span class='Function'>√∑</span><span class='Number'>100</span>
<span class='Value'>r</span> <span class='Gets'>‚Üê</span> <span class='Number'>29</span> <span class='Separator'>‚ãÑ</span> <span class='Function'>LCG</span> <span class='Gets'>‚Üê</span> <span class='Brace'>{</span><span class='Paren'>(</span><span class='Number'>1</span><span class='Function'>-</span><span class='Modifier'>Àú</span><span class='Number'>2</span><span class='Function'>‚ãÜ</span><span class='Number'>31</span><span class='Paren'>)</span><span class='Function'>|</span><span class='Number'>16807</span><span class='Function'>√ó</span><span class='Value'>ùï©</span><span class='Brace'>}</span>
<span class='Value'>str</span> <span class='Gets'>‚Üê</span> <span class='Brace'>{</span><span class='Value'>i</span><span class='Gets'>‚Üê</span><span class='Paren'>(</span><span class='Value'>n</span><span class='Function'>-</span><span class='Number'>1</span><span class='Paren'>)</span><span class='Function'>|</span><span class='Value'>r</span> <span class='Separator'>‚ãÑ</span> <span class='Value'>r</span> <span class='Function'>LCG</span><span class='Gets'>‚Ü©</span> <span class='Separator'>‚ãÑ</span> <span class='Value'>cr</span><span class='Modifier2'>‚åæ</span><span class='Paren'>(</span><span class='Value'>i</span><span class='Modifier2'>‚ä∏</span><span class='Function'>‚äë</span><span class='Paren'>)</span><span class='Value'>lf</span><span class='Modifier2'>‚åæ</span><span class='Paren'>((</span><span class='Value'>i</span><span class='Function'>+</span><span class='Number'>1</span><span class='Paren'>)</span><span class='Modifier2'>‚ä∏</span><span class='Function'>‚äë</span><span class='Paren'>)</span><span class='Value'>ùï©</span><span class='Brace'>}</span><span class='Modifier2'>‚çü</span><span class='Value'>m</span> <span class='String'>@</span><span class='Function'>+</span><span class='Number'>100</span><span class='Function'>|‚Üï</span><span class='Value'>n</span>

<span class='Value'>ls</span> <span class='Gets'>‚Üê</span> <span class='Function'>‚â§</span><span class='Modifier2'>‚üú</span><span class='Value'>n</span><span class='Modifier2'>‚ä∏</span><span class='Function'>/</span> <span class='Function'>‚•ä</span><span class='Paren'>(</span><span class='Number'>10</span><span class='Function'>‚ãÜ</span><span class='Number'>2</span><span class='Function'>+‚Üï</span><span class='Number'>5</span><span class='Paren'>)</span><span class='Function'>√ó</span><span class='Modifier'>‚åú</span><span class='Number'>1</span><span class='Ligature'>‚Äø</span><span class='Number'>3</span>
<span class='Function'>Disp</span> <span class='Gets'>‚Üê</span> <span class='Brace'>{</span> <span class='Function'>‚Ä¢Out</span> <span class='String'>&quot;ns/elt&quot;</span> <span class='Function'>‚àæ</span><span class='Modifier'>Àú</span> <span class='Function'>‚àæ</span> <span class='Function'>‚àæ</span><span class='Modifier2'>‚üú</span><span class='String'>&quot; &quot;</span><span class='Modifier'>¬®</span> <span class='Number'>¬Ø7</span><span class='Ligature'>‚Äø</span><span class='Number'>8</span> <span class='Function'>‚Üë</span><span class='Modifier2'>‚üú</span><span class='Function'>‚Ä¢Repr</span><span class='Modifier'>¬®</span> <span class='Value'>ùï©</span> <span class='Brace'>}</span>
<span class='Brace'>{</span><span class='Function'>ùïä</span><span class='Value'>l</span><span class='Head'>:</span> <span class='Function'>Disp</span> <span class='Value'>l</span> <span class='Function'>‚ãà</span> <span class='Number'>1e9</span><span class='Function'>√ó</span><span class='Value'>l</span><span class='Function'>√∑</span><span class='Modifier'>Àú</span> <span class='Paren'>(</span><span class='Function'>‚åä</span><span class='Number'>5e8</span><span class='Function'>√∑</span><span class='Value'>l</span><span class='Paren'>)</span> <span class='Function'>CRLF_to_LF</span><span class='Modifier'>‚Ä¢_timed</span> <span class='Value'>l</span><span class='Function'>‚Üë</span><span class='Value'>str</span><span class='Brace'>}</span><span class='Modifier'>¬®</span> <span class='Value'>ls</span>
</pre>
<p>lineending.c:</p>
<pre><span class='Comment'>#include &quot;stdlib.h&quot;
#include &quot;stdio.h&quot;
#include &quot;time.h&quot;
</span>
<span class='Comment'>#if 0
</span><span class='Function'>//</span> <span class='Function'>Branchless</span>
<span class='Modifier'>__attribute</span><span class='Paren'>((</span><span class='Value'>noinline</span><span class='Paren'>))</span> <span class='Value'>void</span> <span class='Value'>crlf_to_lf</span><span class='Paren'>(</span><span class='Value'>char*</span> <span class='Value'>dst</span><span class='Separator'>,</span> <span class='Value'>char*</span> <span class='Value'>src</span><span class='Separator'>,</span> <span class='Value'>size_t</span> <span class='Value'>n</span><span class='Paren'>)</span> <span class='Brace'>{</span>
  <span class='Value'>int</span> <span class='Value'>was_cr</span> <span class='Function'>=</span> <span class='Number'>0</span><span class='Head'>;</span>
  <span class='Value'>for</span> <span class='Paren'>(</span><span class='Value'>size_t</span> <span class='Value'>i</span><span class='Function'>=</span><span class='Number'>0</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>&lt;</span><span class='Value'>n</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>++</span><span class='Paren'>)</span> <span class='Brace'>{</span>
    <span class='Value'>char</span> <span class='Value'>c</span> <span class='Function'>=</span> <span class='Value'>src</span><span class='Bracket'>[</span><span class='Value'>i</span><span class='Bracket'>]</span><span class='Head'>;</span>
    <span class='Value'>dst</span> <span class='Function'>-=</span> <span class='Paren'>(</span><span class='Value'>was_cr</span> <span class='Value'>&amp;&amp;</span> <span class='Value'>c</span><span class='Function'>==</span><span class='String'>'</span><span class='Value'>\n</span><span class='String'>'</span><span class='Paren'>)</span><span class='Head'>;</span>
    <span class='Value'>dst</span><span class='Bracket'>[</span><span class='Value'>i</span><span class='Bracket'>]</span> <span class='Function'>=</span> <span class='Value'>c</span><span class='Head'>;</span>
    <span class='Value'>was_cr</span> <span class='Function'>=</span> <span class='Paren'>(</span><span class='Value'>c</span><span class='Function'>==</span><span class='String'>'</span><span class='Value'>\r</span><span class='String'>'</span><span class='Paren'>)</span><span class='Head'>;</span>
  <span class='Brace'>}</span>
<span class='Brace'>}</span>
<span class='Comment'>#else
</span><span class='Modifier'>__attribute</span><span class='Paren'>((</span><span class='Value'>noinline</span><span class='Paren'>))</span> <span class='Value'>void</span> <span class='Value'>crlf_to_lf</span><span class='Paren'>(</span><span class='Value'>char*</span> <span class='Value'>dst</span><span class='Separator'>,</span> <span class='Value'>char*</span> <span class='Value'>src</span><span class='Separator'>,</span> <span class='Value'>size_t</span> <span class='Value'>n</span><span class='Paren'>)</span> <span class='Brace'>{</span>
  <span class='Value'>int</span> <span class='Value'>was_cr</span> <span class='Function'>=</span> <span class='Number'>0</span><span class='Head'>;</span>
  <span class='Value'>for</span> <span class='Paren'>(</span><span class='Value'>size_t</span> <span class='Value'>i</span><span class='Function'>=</span><span class='Number'>0</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>&lt;</span><span class='Value'>n</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>++</span><span class='Paren'>)</span> <span class='Brace'>{</span>
    <span class='Value'>char</span> <span class='Value'>c</span> <span class='Function'>=</span> <span class='Value'>src</span><span class='Bracket'>[</span><span class='Value'>i</span><span class='Bracket'>]</span><span class='Head'>;</span>
    <span class='Value'>if</span> <span class='Paren'>(</span><span class='Value'>was_cr</span> <span class='Value'>&amp;&amp;</span> <span class='Value'>c</span><span class='Function'>==</span><span class='String'>'</span><span class='Value'>\n</span><span class='String'>'</span><span class='Paren'>)</span> <span class='Value'>dst</span><span class='Function'>--</span><span class='Head'>;</span>
    <span class='Value'>dst</span><span class='Bracket'>[</span><span class='Value'>i</span><span class='Bracket'>]</span> <span class='Function'>=</span> <span class='Value'>c</span><span class='Head'>;</span>
    <span class='Value'>was_cr</span> <span class='Function'>=</span> <span class='Paren'>(</span><span class='Value'>c</span><span class='Function'>==</span><span class='String'>'</span><span class='Value'>\r</span><span class='String'>'</span><span class='Paren'>)</span><span class='Head'>;</span>
  <span class='Brace'>}</span>
<span class='Brace'>}</span>
<span class='Comment'>#endif
</span>
<span class='Value'>static</span> <span class='Value'>size_t</span> <span class='Value'>monoclock</span><span class='Paren'>(</span><span class='Value'>void</span><span class='Paren'>)</span> <span class='Brace'>{</span>
  <span class='Value'>struct</span> <span class='Value'>timespec</span> <span class='Value'>ts</span><span class='Head'>;</span>
  <span class='Value'>clock_gettime</span><span class='Paren'>(</span><span class='Function'>CLOCK_MONOTONIC</span><span class='Separator'>,</span> <span class='Value'>&amp;ts</span><span class='Paren'>)</span><span class='Head'>;</span>
  <span class='Value'>return</span> <span class='Number'>1000000000</span><span class='Value'>*ts.tv_sec</span> <span class='Function'>+</span> <span class='Value'>ts.tv_nsec</span><span class='Head'>;</span>
<span class='Brace'>}</span>

<span class='Value'>int</span> <span class='Value'>main</span><span class='Paren'>(</span><span class='Value'>int</span> <span class='Value'>argc</span><span class='Separator'>,</span> <span class='Value'>char</span> <span class='Value'>**argv</span><span class='Paren'>)</span> <span class='Brace'>{</span>
  <span class='Value'>int</span> <span class='Value'>n</span> <span class='Function'>=</span> <span class='Number'>1000000</span><span class='Separator'>,</span> <span class='Value'>m</span> <span class='Function'>=</span> <span class='Value'>n</span><span class='Function'>/</span><span class='Number'>100</span><span class='Head'>;</span>
  <span class='Value'>char</span> <span class='Value'>*str</span> <span class='Function'>=</span> <span class='Value'>malloc</span><span class='Paren'>(</span><span class='Value'>n*sizeof</span><span class='Paren'>(</span><span class='Value'>char</span><span class='Paren'>))</span><span class='Separator'>,</span>
       <span class='Value'>*dst</span> <span class='Function'>=</span> <span class='Value'>malloc</span><span class='Paren'>(</span><span class='Value'>n*sizeof</span><span class='Paren'>(</span><span class='Value'>char</span><span class='Paren'>))</span><span class='Head'>;</span>
  <span class='Value'>for</span> <span class='Paren'>(</span><span class='Value'>size_t</span> <span class='Value'>i</span><span class='Function'>=</span><span class='Number'>0</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>&lt;</span><span class='Value'>n</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>++</span><span class='Paren'>)</span> <span class='Value'>str</span><span class='Bracket'>[</span><span class='Value'>i</span><span class='Bracket'>]</span> <span class='Function'>=</span> <span class='Paren'>(</span><span class='Value'>char</span><span class='Paren'>)(</span><span class='Value'>i%</span><span class='Number'>100</span><span class='Paren'>)</span><span class='Head'>;</span>
  <span class='Value'>for</span> <span class='Paren'>(</span><span class='Value'>size_t</span> <span class='Value'>i</span><span class='Function'>=</span><span class='Number'>0</span><span class='Separator'>,</span> <span class='Value'>r</span><span class='Function'>=</span><span class='Number'>29</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>&lt;</span><span class='Value'>m</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>++</span><span class='Paren'>)</span> <span class='Brace'>{</span>
    <span class='Value'>size_t</span> <span class='Value'>j</span> <span class='Function'>=</span> <span class='Value'>r%</span><span class='Paren'>(</span><span class='Value'>n</span><span class='Function'>-</span><span class='Number'>1</span><span class='Paren'>)</span><span class='Head'>;</span> <span class='Value'>str</span><span class='Bracket'>[</span><span class='Value'>j</span><span class='Bracket'>]</span> <span class='Function'>=</span> <span class='String'>'</span><span class='Value'>\r</span><span class='String'>'</span><span class='Head'>;</span> <span class='Value'>str</span><span class='Bracket'>[</span><span class='Value'>j</span><span class='Function'>+</span><span class='Number'>1</span><span class='Bracket'>]</span> <span class='Function'>=</span> <span class='String'>'</span><span class='Value'>\n</span><span class='String'>'</span><span class='Head'>;</span>
    <span class='Value'>r</span> <span class='Function'>=</span> <span class='Paren'>(</span><span class='Number'>16807</span><span class='Value'>*r</span><span class='Paren'>)</span> <span class='Value'>%</span> <span class='Paren'>((</span><span class='Number'>1ull</span><span class='Function'>&lt;&lt;</span><span class='Number'>31</span><span class='Paren'>)</span><span class='Function'>-</span><span class='Number'>1</span><span class='Paren'>)</span><span class='Head'>;</span>
  <span class='Brace'>}</span>
  <span class='Value'>for</span> <span class='Paren'>(</span><span class='Value'>size_t</span> <span class='Value'>l</span><span class='Function'>=</span><span class='Number'>100</span><span class='Separator'>,</span> <span class='Value'>l0</span><span class='Function'>=</span><span class='Value'>l</span><span class='Head'>;</span> <span class='Value'>l</span><span class='Function'>&lt;=</span><span class='Value'>n</span><span class='Head'>;</span> <span class='Value'>l</span><span class='Function'>=</span><span class='Value'>l</span><span class='Function'>==</span><span class='Value'>l0</span><span class='Head'>?</span><span class='Number'>3</span><span class='Value'>*l</span><span class='Head'>:</span><span class='Paren'>(</span><span class='Value'>l0*</span><span class='Function'>=</span><span class='Number'>10</span><span class='Paren'>))</span> <span class='Brace'>{</span>
    <span class='Value'>size_t</span> <span class='Value'>k</span> <span class='Function'>=</span> <span class='Number'>500000000</span><span class='Function'>/</span><span class='Value'>l</span><span class='Head'>;</span>
    <span class='Value'>size_t</span> <span class='Value'>t</span> <span class='Function'>=</span> <span class='Value'>monoclock</span><span class='Paren'>()</span><span class='Head'>;</span>
    <span class='Value'>for</span> <span class='Paren'>(</span><span class='Value'>size_t</span> <span class='Value'>i</span><span class='Function'>=</span><span class='Number'>0</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>&lt;</span><span class='Value'>k</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>++</span><span class='Paren'>)</span> <span class='Value'>crlf_to_lf</span><span class='Paren'>(</span><span class='Value'>dst</span><span class='Separator'>,</span> <span class='Value'>str</span><span class='Separator'>,</span> <span class='Value'>l</span><span class='Paren'>)</span><span class='Head'>;</span>
    <span class='Value'>t</span> <span class='Function'>=</span> <span class='Value'>monoclock</span><span class='Paren'>()</span><span class='Function'>-</span><span class='Value'>t</span><span class='Head'>;</span>
    <span class='Value'>printf</span><span class='Paren'>(</span><span class='String'>&quot;%7ld %f ns/elt\n&quot;</span><span class='Separator'>,</span> <span class='Value'>l</span><span class='Separator'>,</span> <span class='Paren'>(</span><span class='Value'>double</span><span class='Paren'>)</span><span class='Value'>t</span> <span class='Function'>/</span> <span class='Paren'>(</span><span class='Value'>l*k</span><span class='Paren'>))</span><span class='Head'>;</span>
  <span class='Brace'>}</span>
<span class='Brace'>}</span>
</pre>
<p>And the benchmark run, on <a href="https://www.intel.com/content/www/us/en/products/sku/208658/intel-core-i51135g7-processor-8m-cache-up-to-4-20-ghz/specifications.html">Tiger Lake i5-1135G7</a>:</p>
<pre><span class='Value'>$</span> <span class='Value'>clang</span> <span class='Function'>--</span><span class='Value'>version</span>
<span class='Value'>clang</span> <span class='Value'>version</span> <span class='Number'>15.0.7</span>
<span class='Function'>Target</span><span class='Head'>:</span> <span class='Value'>x86_64</span><span class='Function'>-</span><span class='Value'>unknown</span><span class='Function'>-</span><span class='Value'>linux</span><span class='Function'>-</span><span class='Value'>gnu</span>
<span class='Function'>Thread</span> <span class='Value'>model</span><span class='Head'>:</span> <span class='Value'>posix</span>
<span class='Function'>InstalledDir</span><span class='Head'>:</span> <span class='Function'>/</span><span class='Value'>usr</span><span class='Function'>/</span><span class='Value'>bin</span>

<span class='Value'>$</span> <span class='Value'>clang</span> <span class='Function'>-O3</span> <span class='Function'>-</span><span class='Value'>march</span><span class='Function'>=</span><span class='Value'>native</span> <span class='Value'>lineending.c</span> <span class='Value'>&amp;&amp;</span> <span class='Value'>.</span><span class='Function'>/</span><span class='Value'>a.out</span>
    <span class='Number'>100</span> <span class='Number'>0.613074</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
    <span class='Number'>300</span> <span class='Number'>0.574972</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
   <span class='Number'>1000</span> <span class='Number'>0.560992</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
   <span class='Number'>3000</span> <span class='Number'>0.556508</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
  <span class='Number'>10000</span> <span class='Number'>0.555551</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
  <span class='Number'>30000</span> <span class='Number'>0.554987</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
 <span class='Number'>100000</span> <span class='Number'>0.554504</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
 <span class='Number'>300000</span> <span class='Number'>0.554786</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
<span class='Number'>1000000</span> <span class='Number'>0.555487</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>

<span class='Value'>$</span> <span class='Value'>bqn</span> <span class='Function'>--</span><span class='Value'>version</span>
<span class='Function'>CBQN</span> <span class='Value'>on</span> <span class='Value'>commit</span> <span class='Number'>0d2631a2278fab44164f4619a1a8c295fe674fa0</span>
<span class='Value'>built</span> <span class='Value'>with</span> <span class='Function'>FFI</span><span class='Separator'>,</span> <span class='Value'>singeli</span> <span class='Value'>x86</span><span class='Function'>-</span><span class='Number'>64</span> <span class='Value'>avx2</span> <span class='Value'>bmi2</span> <span class='Value'>pclmul</span><span class='Separator'>,</span> <span class='Value'>replxx</span>

<span class='Value'>$</span> <span class='Value'>bqn</span> <span class='Value'>lineending.bqn</span> 
    <span class='Number'>100</span> <span class='Number'>0.893145</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
    <span class='Number'>300</span> <span class='Number'>0.396408</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
   <span class='Number'>1000</span> <span class='Number'>0.187448</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
   <span class='Number'>3000</span> <span class='Number'>0.127288</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
  <span class='Number'>10000</span> <span class='Number'>0.106085</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
  <span class='Number'>30000</span> <span class='Number'>0.094272</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
 <span class='Number'>100000</span> <span class='Number'>0.096406</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
 <span class='Number'>300000</span> <span class='Number'>0.095310</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
<span class='Number'>1000000</span> <span class='Number'>0.107455</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>

<span class='Value'>$</span> <span class='Value'>bqn</span> <span class='Function'>--</span><span class='Value'>version</span>
<span class='Function'>CBQN</span> <span class='Value'>on</span> <span class='Value'>commit</span> <span class='Number'>0d2631a2278fab44164f4619a1a8c295fe674fa0</span>
<span class='Value'>built</span> <span class='Value'>with</span> <span class='Function'>FFI</span><span class='Separator'>,</span> <span class='Value'>singeli</span> <span class='Value'>native</span> <span class='Value'>x86</span><span class='Function'>-</span><span class='Number'>64</span><span class='Separator'>,</span> <span class='Value'>replxx</span>

<span class='Value'>$</span> <span class='Value'>bqn</span> <span class='Value'>lineending.bqn</span> 
    <span class='Number'>100</span> <span class='Number'>0.838992</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
    <span class='Number'>300</span> <span class='Number'>0.319644</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
   <span class='Number'>1000</span> <span class='Number'>0.129420</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
   <span class='Number'>3000</span> <span class='Number'>0.072258</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
  <span class='Number'>10000</span> <span class='Number'>0.052556</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
  <span class='Number'>30000</span> <span class='Number'>0.050635</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
 <span class='Number'>100000</span> <span class='Number'>0.053703</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
 <span class='Number'>300000</span> <span class='Number'>0.052985</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
<span class='Number'>1000000</span> <span class='Number'>0.078744</span> <span class='Value'>ns</span><span class='Function'>/</span><span class='Value'>elt</span>
</pre>
</details>

<p>Larger problems are more mixed. Our best real-world comparison on a comparable problem is the <a href="bootbench.html">compiler benchmark</a>, which showed a 35% advantage for the BQN implementation. <a href="codfns.html#is-it-a-good-idea">Here</a> I described compiling as being intermediate in terms of how good it is for array programming. Naturally array-oriented tasks like data crunching can be better, although C can auto-vectorize simpler ones. And as array programming is a limited programming, there's no guarantee a problem will fit. If you have to use sequential code for a significant part of the program, BQN will end up a lot slower.</p>
<p>Another test case is JSON parsing. While I haven't comprehensively benchmarked <a href="https://github.com/mlochbaum/bqn-libs/blob/master/primes.bqn">json.bqn</a>, it runs at 40 to 100 MB/s for typical structures, which is competitive with some C parsers but well short of more optimized efforts like RapidJSON or simdjson.</p>
<p>I spent some time optimizing the prime sieve in <a href="https://github.com/mlochbaum/bqn-libs/blob/master/primes.bqn">primes.bqn</a> for bqn-libs, and ended up with a <code><span class='Function'>PrimesTo</span></code> function that computes the primes under a billion in 1.1 seconds. This is in the ballpark of typical C wheel sieves. It's actually faster than J's <code><span class='Value'>p</span><span class='Head'>:</span></code>, which is implemented in C and takes 3.1 seconds, but is beaten by <a href="https://codeberg.org/ngn/k/src/branch/master/4.c">ngn/k's</a> at 0.7 seconds. The serious sieves like one <a href="https://github.com/kimwalisch/primesieve/">by Kim Walisch</a> with piles of cache-aware code run much faster than any of these.</p>
<h2 id="when-to-use-bqn"><a class="header" href="#when-to-use-bqn">When to use BQN?</a></h2>
<p>Those examples were somewhat favorable to BQN. This page is kinda pro-BQN, yeah? Because if you haven't heard the pro-C arguments a million times already, wow.</p>
<p>Still, it's possible to give more guidance than &quot;BQN good&quot; or &quot;BQN bad&quot;: BQN is relatively better at certain problems and programming models. If you don't care about performance, that's out of scope for this page; maybe you like BQN and maybe you don't. If performance is so important that development time is no object, you will have to go to C eventually, if not CUDA or other specialized tools. However, I find BQN quite useful for testing out high-performance strategies to work out the details or see how they will perform. Since array primitives are so closely related to SIMD instructions, a BQN solution will often match the overall shape of high-performance code better than an initial C one!</p>
<p>The tough decisions are in the intermediate case where there's a high threshold for acceptable performance but only so much developer time to achieve it. I think this mainly happens for large programs. Here I should stress that object-oriented C++ is not the same as C: if your code spends most of its time dispatching methods on small objects then it's in a different and slower performance category that I don't know much about. But a program that deals with plain data like strings and arrays of numbers is a candidate for writing in BQN. Relative to C, BQN will do best if the data structures are homogeneous arrays that are large (at least hundreds and preferably thousands of elements), and have a small element type (particularly 1 or 2 bytes) so more elements can be packed in a SIMD vector. BQN aims to be fast even on multidimensional arrays with a short last axis, where the default in C is to use a slow nested loop, but it's better to keep the last axis long if possible.</p>
<p>Some programs are just not suitable for array programming, making C or similar the best tool for the job. One tell-tale feature for these is a lot of loops where the number of iterations isn't known in advance (assuming a single iteration is too short to get useful array work done). SIMD speedups are all about processing multiple steps at a time, so they can't be done without knowing there are multiple steps left!</p>
<p>On the other end, some programs naturally work in terms of long arrays, and these might end up with C-ish performance without any particular effort to write fast BQN. Between these two extremes anything could happen, as there's no limit on the work that may be needed to distinguish the hard and the impossible. If you're enjoying array programming I think it's a good idea to learn about ways of working with partitioned lists and trees as flattened arrays to extend your reach. However, after using these techniques extensively to make the BQN compiler, <a href="codfns.html#is-it-a-good-idea">I wrote</a> that performance alone isn't a good reason to tackle such a hard problem with array programming.</p>
<h2 id="bqns-advantages"><a class="header" href="#bqns-advantages">BQN's advantages</a></h2>
<p>BQN has definite disadvantages relative to C, because it doesn't have static type information and doesn't do a significant amount of optimization when it compiles‚Äîevery primitive is a function call, except the operands to some modifiers like <code><span class='Function'>+</span><span class='Modifier'>¬¥</span></code>. To make up for this, there are a number of advantages that are perhaps less obvious. Broadly speaking, a C program contains more optimization information than a BQN one, but this information (even if it's well chosen!) can tie the compiler down and prevent optimization as much as it can enable it.</p>
<p>Now, I can't really say it's impossible for some future C compiler to sift out what information is important and what isn't, and build a program that's perfectly suited to what you want to do. It would be fighting its own source language to get there, and may have to do crazy things like guess constraints on program input that you expect but haven't checked for. And if you're hoping for radical implementation improvements, you might bet on the language that's a few years old, not the one that's been around for 50?</p>
<h3 id="high-level-versus-low-level"><a class="header" href="#high-level-versus-low-level">High-level versus low-level</a></h3>
<p>Array programming is a high-level framework for describing algorithms, in that the programmer is saying more &quot;what&quot; than &quot;how&quot;. C does this too, because when you write <code><span class='Value'>a</span><span class='Function'>+</span><span class='Value'>b</span></code> you don't specify the instruction to use, and indeed <code><span class='Value'>a*</span><span class='Number'>4</span></code> is almost certainly going to use a shift instruction instead of multiplication. But in terms of how many &quot;how&quot;s you can leave out, BQN leaves out a lot more. The downside of the implementation filling in the &quot;how&quot; for you is that it might do worse, and the upside is that it might do better.</p>
<p>Unlike BQN, C doesn't just fill in the details of what you told it to do. Auto-vectorization is an attempt to build some high-level understanding and use it to change over to a different low-level implementation. This is much harder than just implementing primitives and I think that's the main reason you won't see a C compiler do something like transposing a matrix with a SIMD kernel. C also has limitations on how it can rearrange memory accesses. A common one is that it can't read extra memory because this might segfault, so if you write a scalar search to find the first 0 in an array it's actually not legal to rewrite this to a vector search that might read past that 0.</p>
<p>On the topic of memory, it's a very simple structure‚Äîthe whole world, just a sequence of bytes!‚Äîbut it's also mutinous I mean mutable. If you call an unknown function in C, it could write anywhere, so the compiler no longer knows the value of any part of memory. If you write to an unknown pointer, and pointers are hard to know mind you, it could change any part of memory too. This leads to a whole category of optimization problems known as <a href="https://en.wikipedia.org/wiki/Pointer_aliasing#Conflicts_with_optimization">pointer aliasing</a>, where something as simple as adding one to a bunch of values with a source and destination pointer can't be vectorized unless the pointers are known to not overlap.</p>
<h4 id="fusion-versus-fission"><a class="header" href="#fusion-versus-fission">Fusion versus fission</a></h4>
<p>I view getting the balance between <a href="https://en.wikipedia.org/wiki/Loop_fission_and_fusion">loop fusion and fission</a> right as a sort of holy grail of array programming. I so wish I could say &quot;we've already got one!&quot;. Nope, as it stands, C chooses fusion and BQN chooses fission. That is, a C programmer usually writes one loop with lots of stuff in it, but each BQN primitive is like a loop, making a BQN program a series of loops. But the best approaches usually have more complicated shapes. Some loops can be fused at the level of a vector instruction, and this is where C auto-vectorization works great and BQN is worst with lots of extra loads and stores. Loops involving filtering or other data movement might not be tightly fusable; auto-vectorization gives up and CBQN looks great in comparison. But it's still missing out on any instruction-level fusion that <em>can</em> be done (<code><span class='Value'>a</span><span class='Function'>/</span><span class='Value'>b</span><span class='Function'>+</span><span class='Value'>c</span><span class='Function'>√ó</span><span class='Value'>d</span></code> won't fuse <code><span class='Value'>b</span><span class='Function'>+</span><span class='Value'>c</span><span class='Function'>√ó</span><span class='Value'>d</span></code>), and if the arrays are large it's missing out on looser-grained fusion that would make better use of caches. It's a complicated topic; I should probably write a separate page on it.</p>
<h3 id="dynamic-versus-static"><a class="header" href="#dynamic-versus-static">Dynamic versus static</a></h3>
<p>A C compiler decides what it's going to do at compile time, before it's even caught a whiff of the data that'll be processed (all right, profile-guided optimization is a decent sniff in that direction, but no touching). CBQN decides what to do again every time a primitive is called. This has some overhead, but it also means these calls can adapt to conditions as they change.</p>
<p>An example is selection, <code><span class='Function'>‚äè</span></code>. If you select from any old array of 1-byte values, it'll pick one element at a time (okay, call a gather instruction that then loads one at a time) which I measure at 0.2ns per selection. If you select from a <em>small</em> array, say 32 values or less, CBQN will load them into vector registers and do the selection with shuffle instructions, 0.04ns per selection. That includes a range check, that C is supposedly speeding your code up by ignoring! By having the high-level information of a known right argument range, and checking it dynamically, BQN goes much faster in certain cases.</p>
<p>As a SIMD programmer in C you might write code that uses vector shuffles as well, but probably only for an array whose length is known statically. BQN's dynamic checking allows it to take advantage of this case exactly when it comes up. And sure, you could do this sort of check in C, but at that point, you're kind of writing a BQN VM.</p>
<p>We do a lot of dynamic checking in CBQN. Checking array rank and shape is pretty cheap, and we also track element type (see <a href="https://mlochbaum.github.io/BQN/implementation/compile/intro.html#and-which-is-better">this section</a>) and <a href="primitive/flagsort.html">sortedness</a> of arrays. A boolean array is packed 8 bits to the byte, which is way faster for most things but not often done in C.</p>
<p>There's also data-based checking, or <a href="https://en.wikipedia.org/wiki/Adaptive_algorithm">adaptive algorithms</a>‚Äîadaptive sorting being the best-known case. There are simpler examples too. <a href="primitive/replicate.html">Replicate</a> (<code><span class='Function'>/</span></code>) compares the input and output lengths to use either a sparse or dense algorithm, and can also check a boolean argument to see how many times it switches between 0 and 1, so that if it's clumpy it can copy values in chunks. Group (<code><span class='Function'>‚äî</span></code>) checks for clumpiness as well, copying in sections if <code><span class='Value'>ùï®</span></code> changes value infrequently. Sticking to just a single implementation can lead to very poor cases that are dominated by branch misprediction penalties‚Äîwhich is exactly what happens in C when you write a string partitioning function that branches at the boundaries and then get a string where the sections are short.</p>
<h3 id="primitives-versus-c-libraries"><a class="header" href="#primitives-versus-c-libraries">Primitives versus C libraries</a></h3>
<p>BQN can call C code through its FFI, but it has a little call overhead and often requires copying data so it's not the fastest interface. C can also call into CBQN as a library, with similar issues. But isn't it possible to make C library functions for BQN primitives‚Äîin fact, don't many such library functions like sorting and binary searching already exist?</p>
<p>In principle this is a fine strategy; it's something we do a fair amount internally within BQN. Practically speaking, well first I have to admit that I know very little about these libraries. It seems clear enough that stdlib implementations are a joke as far as performance goes, so we are talking about C++ stuff like Abseil, Folly, or Boost. I'm still kind of skeptical, but what little knowledge I have about these is from looking at documentation and not finding functions that seemed useful (for implementing APL) and looking at source code and benchmarks and not seeing anything that seemed impressive. If anyone would, say, use these to implement some BQN primitives faster than CBQN's Singeli versions I'd change my mind real fast.</p>
<p>The advantage of a library is mainly moving from low level to high level. C libraries work within the static type system so they're still mainly static rather than dynamic, but can be dynamic in other ways like adaptive sorting. Beyond this I do have some examples few ways that the expectations for a C/C++ library tend to harm performance.</p>
<ul>
<li>Libraries shy away from too much memory use; for some things like <code><span class='Value'>k</span><span class='Function'>/</span><span class='Value'>l</span></code> for a small constant <code><span class='Value'>k</span></code> CBQN uses precomputed tables of shuffle indices. Since we know exactly how big the BQN language is it's easier to decide on how much memory use is reasonable where this isn't known for a library that might be mixed with any amount of other code.</li>
<li>There's a lot of pressure for <a href="primitive/sort.html">sorting</a> to match the standard library interface which means taking a comparison function. Numeric sorting can sometimes be recognized as a special case, but sort function authors seem to feel that the same algorithm should be used for all types, ruling out much faster distribution sorts for 1- and 2-byte integers.</li>
<li><a href="primitive/search.html">Lookups</a> are performed with persistent hash tables. These have type problems too (a lookup table on 1 byte is a lot faster than a hash table), and additionally inserting and searching one at a time means the table is running blind, without information about how many lookups are needed. Often, all the values are known at a one point in the program, making a single call like BQN's <code><span class='Function'>‚äê</span></code> a better interface because it can optimize on argument lengths. This can be many times faster, and for few lookups can even do a reverse lookup that stops early in the searched values instead of inserting them all. This isn't always the case, so sometimes a hash table object <em>is</em> needed.</li>
</ul>
<p>These problems are noticeably easier to address than BQN's issues with fusing primitives (although the library functions run into those same fusion problems too). I hope I'll see it happen!</p>
<h3 id="why-cant-i-do-these-in-c"><a class="header" href="#why-cant-i-do-these-in-c">Why can't I do these in C?</a></h3>
<p>There are a few things the C compilers of today (2023) don't seem able to generate from portable code. If you know how to do them, please tell me!</p>
<ul>
<li>SIMD scans‚Äîprefix sums and so on. <code><span class='Value'>for</span> <span class='Paren'>(</span><span class='Value'>i</span><span class='Function'>=</span><span class='Number'>1</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>&lt;</span><span class='Value'>n</span><span class='Head'>;</span> <span class='Value'>i</span><span class='Function'>++</span><span class='Paren'>)</span> <span class='Value'>x</span><span class='Bracket'>[</span><span class='Value'>i</span><span class='Bracket'>]</span> <span class='Function'>+=</span> <span class='Value'>x</span><span class='Bracket'>[</span><span class='Value'>i</span><span class='Function'>-</span><span class='Number'>1</span><span class='Bracket'>]</span></code> should vectorize for integers. Or some other variant; I've tried many. The way to do this is well known and I don't think the code size and latency tradeoffs are any worse than for typical auto-vectorizations. This is so baffling to me.</li>
</ul>
<ul>
<li>Multiple comparisons with the result in a bitmask. x86 has the very useful <code><span class='Value'>movmsk</span></code> family of instructions to move a bit from each element of a vector register into a general-purpose register. As far as I know, portable C can't get at the full result of this‚Äîclang can use it to test if any comparison is true, but nothing else. Since C doesn't really treat packed-bit formats as native, recognizing the conditions where <code><span class='Value'>movmsk</span></code> could be used is pretty tough. Still, it closes off optimization opportunities in many places.</li>
</ul>
<ul>
<li>Conditional-move instructions. Various things like binary search and branchless merges turn into a guessing game because compilers have all sorts of <a href="https://kristerw.github.io/2022/05/24/branchless/">weird</a> and sometimes <a href="https://github.com/llvm/llvm-project/issues/39374">buggy</a> (can it really be‚Ä¶ it's finally fixed!) heuristics for determining whether <code><span class='Value'>if</span> <span class='Paren'>(</span><span class='Value'>cond</span><span class='Paren'>)</span> <span class='Value'>a</span><span class='Function'>=</span><span class='Value'>b</span></code> should use a consistently fast branchless instruction or a branch that could be slightly faster or many times slower. Really fixing this would require compiler extension though. I would definitely support an intrinsic that you can apply to a condition that says &quot;don't you dare branch on this&quot; (with an error if it's not possible). A <code><span class='Modifier'>__branchless_choice</span><span class='Paren'>(</span><span class='Value'>cond</span><span class='Separator'>,</span> <span class='Value'>a</span><span class='Separator'>,</span> <span class='Value'>b</span><span class='Paren'>)</span></code> intrinsic also makes a lot of sense to me.</li>
</ul>
