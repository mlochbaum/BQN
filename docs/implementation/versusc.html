<head>
  <link href="../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../style.css" rel="stylesheet"/>
  <title>Performance in BQN versus C</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../index.html">BQN</a> / <a href="index.html">implementation</a></div>
<h1 id="performance-in-bqn-versus-c"><a class="header" href="#performance-in-bqn-versus-c">Performance in BQN versus C</a></h1>
<p>The title alone! You know BQN has some fast <a href="perf.html">performance</a> to wave around!</p>
<p>If you think it's paradoxical that programs written for CBQN, a C-based interpreter, might outperform programs written directly in C, it's because you think performance comes from the language implementation. Not so: performance comes from the programmer, taking advantage of the features offered by their language implementation. The difficulty of doing so has two consequences:</p>
<ul>
<li>BQN programs can and do outperform equivalent C programs.</li>
<li>Your BQN programs are unlikely to outperform equivalent C programs.</li>
</ul>
<p>Because once you have a working program, you are probably going to come to the realization that you'd rather do something else with your time than study and optimize until it can beat the C program that you never even wrote in the first place. You wouldn't have made the C program as fast as possible either: that only makes sense for programs that are used over and over in a performance-sensitive context and simple enough to optimize well. Like… the CBQN interpreter.</p>
<p>Here's a highly authoritative graph on how the effort to speed tradeoff could work, in one case, maybe.</p>
<svg viewBox='-60 -25 376 178'>
  <g stroke-width='1.8' font-size='13px' text-anchor='middle' fill='currentColor'>
    <rect class='code' stroke-width='1' rx='6' x='-20' y='-20' width='296' height='168'/>
    <g class='purple' stroke-width='1' opacity='0.4'>
      <rect x='220.4' y='-10' width='45.6' height='148'/>
      <text transform='rotate(-90)' dy='0.2em' x='-64' y='256'>Non-portable</text>
    </g>
    <text class='bluegreen' x='238.08' y='7.68'>C</text>
    <text class='green' x='186.88' y='25.6'>BQN</text>
    <g opacity='0.8'>
      <text dy='1em' x='128' y='128'>Effort</text>
      <text transform='rotate(-90)' dy='-0.35em' x='-64' y='0'>Speed</text>
    </g>
    <path class='Paren' stroke-width='1.2' stroke='currentColor' fill='none' d='M0 0V128H256'/>
    <path class='bluegreen' style='fill:none' d='M102.4 89.6C115.2 25.6 212.48 57.6 238.08 19.2C248.32 3.84 256 0 256 0'/>
    <path class='green' style='fill:none' d='M0 128C51.2 83.2 128 89.6 153.6 51.2C166.4 32 204.8 32 204.8 32'/>
  </g>
</svg>

<p>I'm considering something basically straightforward (no big algorithmic improvements) and that can be implemented with whole arrays, but not trivially. BQN lets you quickly write a working program, but the easy way usually involves lots of small arrays and slow iteration. C on the other hand is notorious for being hard to write, but once you do it you'll get good performance if you didn't cut corners. Going beyond to get the most out of a CPU takes a lot more work, and often manual use of SIMD or other intrinsics, which isn't portable. CBQN gives you access to some of those methods without as much effort, which is how it can end up beating a basic C program. But evaluating one primitive at a time has overhead, so it's never as good as specialized C.</p>
<p>A major factor that separates low- and high-performance programs in both C and BQN is not actually time spent but experience with the required programming techniques. In portable C this means branchless tricks, bit manipulation, and writing things an auto-vectorizer can handle. In BQN it's a totally different set of skills needed to write in an array-oriented style. Surprisingly, non-portable C often benefits from those array-oriented skills as well: I often find better ways to implement BQN primitives by thinking in terms of other primitives!</p>
<h2 id="case-studies"><a class="header" href="#case-studies">Case studies</a></h2>
<p>All right, how can I so confidently claim that CBQN can—sometimes—be faster than C in practice? First off, there's a certain class of problems where it's routine: BQN primitives. Every one that does anything, really. Scan, Transpose, Indices, Sort, Modulus, Reshape. And so on. We write the ordinary C implementation, and it's just not good enough, so we have to use lookup tables, SIMD, blocked multi-pass techniques, and more. A 10x improvement over ordinary C code is completely normal. But this is the best possible case for BQN; combinations of primitives never do so well.</p>
<p>Small real-world problems can still show a major difference. In my first talk at Dyalog (<a href="https://dyalog.tv/Dyalog17/?v=2KnrDmZov4U">video</a>, <a href="https://www.dyalog.com/uploads/conference/dyalog17/presentations/D08_Moving_Bits_Faster_in_Dyalog_16.zip">zipped slides</a>), as well as a follow-up next year (<a href="https://dyalog.tv/Dyalog18/?v=-6no6N3i9Tg">video</a>, <a href="https://www.dyalog.com/user-meetings/uploads/conference/dyalog18/presentations/D15_The_Interpretive_Advantage.zip">zipped slides</a>), I considered the problem of replacing every CRLF line ending in a file with just the second character LF. BQN nails this one, breaking even with C at a little under 200 bytes and hitting 4x C's speed on inputs of a few thousand bytes or more in my testing.</p>
<p>Larger problems are more mixed. Our best real-world comparison on a comparable problem is the <a href="bootbench.html">compiler benchmark</a>, which showed a 35% advantage for the BQN implementation. <a href="codfns.html#is-it-a-good-idea">Here</a> I described compiling as being intermediate in terms of how good it is for array programming. Naturally array-oriented tasks like data crunching can be better, although C can auto-vectorize simpler ones. And as array programming is a limited programming, there's no guarantee a problem will fit. If you have to use sequential code for a significant part of the program, BQN will end up a lot slower.</p>
<p>Another test case is JSON parsing. While I haven't comprehensively benchmarked <a href="https://github.com/mlochbaum/bqn-libs/blob/master/primes.bqn">json.bqn</a>, it runs at 20 to 50 MB/s for typical structures, which is competitive with some C parsers but well short of more optimized efforts like RapidJSON or simdjson.</p>
<p>I spent some time optimizing the prime sieve in <a href="https://github.com/mlochbaum/bqn-libs/blob/master/primes.bqn">primes.bqn</a> for bqn-libs, and ended up with a <code><span class='Function'>PrimesTo</span></code> function that computes the primes under a billion in 2.2 seconds. This is in the ballpark of typical C wheel sieves. It's actually faster than J's <code><span class='Value'>p</span><span class='Head'>:</span></code>, which is implemented in C and takes 7.1 seconds, but is beaten by <a href="https://codeberg.org/ngn/k/src/branch/master/4.c">ngn/k's</a> at 1.2 seconds. The serious sieves like one <a href="https://github.com/kimwalisch/primesieve/">by Kim Walisch</a> with tons of cache-aware code run much faster than any of these.</p>
