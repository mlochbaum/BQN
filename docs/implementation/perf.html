<head>
  <link href="../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../style.css" rel="stylesheet"/>
  <title>How does BQN perform?</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../index.html">BQN</a> / <a href="index.html">implementation</a></div>
<h1 id="how-does-bqn-perform"><a class="header" href="#how-does-bqn-perform">How does BQN perform?</a></h1>
<p>How fast is the performance-oriented BQN implementation, <a href="https://github.com/dzaima/CBQN">CBQN</a>? I must ask, why do you care? People are out there looking for the fastest array language before they've tried any one to see if it works for them. Fact is, most programs have a point where they are just fast enough, and CPUs have gotten pretty good at reaching that point. Or maybe there's a concentrated slow part that's easily handed off to a specialized tool like LAPACK. No matter what, a laser focus on performance from the beginning will cause you to miss the fast solutions you'd find if you really understood the problem. So, start with clean code in the most expressive language to work out strategy, and move to tactics once you know when and how the performance falls short. Without this understanding, benchmarks are just a dick measuring contest. It's not even your own dick. It's public, you're just using it.</p>
<p>Anyway, BQN's dick is pretty fast. Compiles its own compiler in 2ms. Builds this whole site‚Äîa megabyte or so of markdown‚Äîin a second and a half. Lists the primes under a billion in two seconds. That sort of thing. For CBQN right now, performance splits into three major cases:</p>
<ul>
<li>Scalar code, mostly using atoms. CBQN is faster than other array languages and on par with lightweight interpreters (not JIT compilers).</li>
<li>Flat lists, particularly integers and characters. CBQN rarely loses to other array languages, and can beat idiomatic C.</li>
<li>Multidimensional arrays. CBQN has less optimization, and sometimes falls back to the self-hosted runtime which has implementations using a lot of scalar code. These can be slow, but not pathologically so.</li>
</ul>
<p>Currently we aim for high performance on a single CPU core, and are focusing on 64-bit x86 and ARM. These both have vector extensions that are always present (SSE2 and NEON respectively); the Singeli build uses these, as well as x86 extensions AVX2 and BMI2 if the architecture specified at compile time includes them. Singeli is assumed for the discussion here, as without it there are some slow cases, particularly comparisons. CBQN doesn't use additional cores or a GPU for acceleration.</p>
<h2 id="performance-resources"><a class="header" href="#performance-resources">Performance resources</a></h2>
<p>It's more accurate to say CBQN can be fast, not that it will be fast: it's all about how you use it. Definitely ask on the forum if you're having performance troubles so you can improve your technique.</p>
<p>There are two measurement tools in the <a href="../spec/system.html#time">time</a> system values. <code><span class='Function'>‚Ä¢MonoTime</span></code> is a high-precision timer for performance measurements; you can take a time before and after some operation or section of a program and subtract them to get a time in seconds (a profiling tool to do this automatically would be nice, but we don't have one). More convenient for small snippets, <code><span class='Modifier'>‚Ä¢_timed</span></code> returns the time to evaluate <code><span class='Function'>ùîΩ</span><span class='Value'>ùï©</span></code>, averaging over <code><span class='Value'>ùï®</span></code> runs if given. For two-argument functions you can write <code><span class='Value'>w</span><span class='Modifier2'>‚ä∏</span><span class='Function'>F</span><span class='Modifier'>‚Ä¢_timed</span> <span class='Value'>x</span></code> or <code><span class='Function'>F</span><span class='Modifier'>¬¥‚Ä¢_timed</span> <span class='Value'>w</span><span class='Ligature'>‚Äø</span><span class='Value'>x</span></code>.</p>
<pre><span class='Number'>100</span> <span class='Function'>+</span><span class='Modifier'>¬¥‚Ä¢_timed</span> <span class='Function'>‚Üï</span><span class='Number'>1e6</span>  <span class='Comment'># Time +¬¥ only
</span><span class='Paren'>)</span><span class='Value'>time</span><span class='Head'>:</span><span class='Number'>100</span> <span class='Function'>+</span><span class='Modifier'>¬¥</span><span class='Function'>‚Üï</span><span class='Number'>1e6</span>    <span class='Comment'># Time entire expression
</span></pre>
<p>CBQN also has a <code><span class='Paren'>)</span><span class='Value'>time</span></code> command that prints the time taken by an entire expression, not counting compilation time. And a <code><span class='Paren'>)</span><span class='Value'>profile</span></code> command that samples where time was spent by the line‚Äîexecution naturally has to be spread over several lines for this to be useful, and should take at least a few milliseconds too.</p>
<p>The <a href="https://mlochbaum.github.io/bencharray/pages/summary.html">bencharray</a> tool has a page showing primitive benchmarks with some explanations.</p>
<p>If BQN isn't meeting your needs, there's always option to hook up with C by FFI: see the <a href="../spec/system.html#foreign-function-interface">spec</a>. Also the <a href="https://github.com/dzaima/CBQN/blob/master/docs/system.md#ffi">CBQN docs</a>, which say how much of that is actually implemented now. FFI calls have low overhead (tens of nanoseconds), but may require copying as data goes in or out.</p>
<h2 id="versus-other-array-languages"><a class="header" href="#versus-other-array-languages">Versus other array languages</a></h2>
<p>Things get hard when you try to put array languages up next to each other. You can get completely different results depending on what sort of problems you want to solve and how you write code, and all those different results are valid. Because people ask for it, I'll try to give some description for the implementations I'm familiar with. I'm of course biased towards the languages I've worked on, Dyalog and BQN; if nothing else, these tend to prioritize just the features I find important! Note also that the situation can change over time; these comments are from 2023.</p>
<p>The implementations I use for comparison are Dyalog APL, ngn/k, and J. I don't benchmark against proprietary K implementations because the anti-benchmarking clauses in their licenses would prevent me from sharing the results (discussed <a href="kclaims.html">here</a>).</p>
<p>Array operations are the way to get the most value out of an array language (<a href="https://aplwiki.com/wiki/Performance">background reading</a>), so these languages tend to focus on them. But BQN tries to be usable in less array-oriented situations as well, and is faster for scalar code in the simple cases I've measured‚Äîthings like naive Fibonacci or folding with a function that does some arithmetic. Dyalog is uniformly slow on such things, 5‚Äì10x worse than BQN. J is a bit better with tacit code and worse with explicit, 3‚Äì15x worse than BQN. And I measure ngn/k around 2x worse than BQN. For context, BQN is just slower than LuaJIT with the JIT off (which is still a fast interpreter), and I usually expect it to be about 10x slower than C in cases where C operations are compiling to single instructions (e.g. excluding auto-vectorization).</p>
<p>I publish BQN benchmarks of array operations in <a href="https://mlochbaum.github.io/bencharray/pages/summary.html">bencharray</a>, and also use it to compare against J and Dyalog. I find that in all cases, if BQN is better it's because of fundamental superiority, and if it's worse it's just a case that we're meaning to improve but haven't gotten to yet. Mostly BQN is ahead, even by 2x or more in many cases. Now, I do tend to benchmark things that dzaima or I are actively working on speeding up, but at this point I've gotten to all the list operations that are important for performance. The slow cases remaining are almost all searching and sorting on larger types, 4-byte integers and floats.</p>
<p>We're beginning to work on multi-dimensional operations, and have ended up substantially faster than Dyalog at a few things. However, Dyalog's coverage is much broader so it most likely will be faster overall if a lot of arrays of rank 2 or more are used. Similar with J, although I believe it doesn't have quite as many optimizations. K stores all arrays as nested lists, so it can't be as fast on high-rank arrays unless the last axis is long.</p>
<h2 id="faster-than-c"><a class="header" href="#faster-than-c">Faster than C?</a></h2>
<p>It's inappropriate to say a language is faster than C. Public indecency kind of stuff. On the other hand, suppose a programmer who can handle both C and BQN solves the same problem in each, and runs the C program with clang or gcc and the BQN one with CBQN. BQN might just finish first.</p>
<p>I don't mean that it's common! Just, it's not that weird, and could happen to anyone.</p>
<p>CBQN is in fact written in C, and, uh, BQN and Singeli that compiles to C. But it's not the kind of C you'd generally write unless the performance stakes are very high. Here are the major factors that make it fast:</p>
<ul>
<li>Dynamically-chosen number and character types, and packed bit-booleans</li>
<li>Multiple algorithms with selection by inspecting arguments</li>
<li>Code using SIMD and other instruction sets</li>
</ul>
<p>Each of these can have a huge impact, and takes more thinking, writing, and debugging (if you think auto-vectorization can save you from writing SIMD code, you're sadly mistaken. I am exactly the one to know). The reason CBQN can take on this level of optimization is that it's actually a pretty small program. An average primitive <em>could</em> be implemented in 20 or so lines of C. By convincing the BQN programmer to concentrate their code into a fairly small number of primitives, we can expend a lot of effort writing hundreds of lines, and speed up BQN programs.</p>
<p>You expected more discussion? Well, now I'm kinda tired‚Ä¶ just kidding, there's a <a href="versusc.html">whole page on this</a>.</p>
