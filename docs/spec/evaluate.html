<head>
  <link href="../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../style.css" rel="stylesheet"/>
  <title>Specification: BQN evaluation</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../index.html">BQN</a> / <a href="index.html">spec</a></div>
<h1 id="specification-bqn-evaluation"><a class="header" href="#specification-bqn-evaluation">Specification: BQN evaluation</a></h1>
<p>This page describes the semantics of the code constructs whose grammar is given in <a href="grammar.html">grammar.md</a>. The formation rules there are not named, and here they are identified by either the name of the term or by copying the rule entirely if there are several alternative productions.</p>
<p>Here we assume that the referent of each identifier, or equivalently the connections between identifiers, have been identified according to the <a href="scope.html">scoping rules</a>.</p>
<p>Evaluation is an ordered process, and any actions required to evaluate a node always have a specified order unless performing them in any order would have the same effect. Side effects that are relevant to ordering are setting and getting the value of a variable, and causing an error. Errors described in this page are &quot;evaluation errors&quot; and can be caught by the Catch (<code><span class='Modifier2'>⎊</span></code>) modifier. If caught, evaluation halts without attempting to complete any in-progress node, and is restarted by Catch.</p>
<p>As specified, BQN programs can involve an arbitrary amount of information, but when run there will be memory and possibly other limitations. To accommodate this, any part of evaluation can cause an error, if a resource such as memory, stack memory, or limited execution time is exhausted.</p>
<h3 id="programs-and-blocks"><a class="header" href="#programs-and-blocks">Programs and blocks</a></h3>
<p>The result of parsing a valid BQN program is a <code><span class='Function'>PROGRAM</span></code>, and the program is run by evaluating this term.</p>
<p>A <code><span class='Function'>PROGRAM</span></code> or <code><span class='Function'>BODY</span></code> is a list of <code><span class='Function'>STMT</span></code>s, which are evaluated in program order. A <code><span class='Function'>BODY</span></code> also allows an <code><span class='Function'>EXPR</span></code> followed by <code><span class='String'>&quot;?&quot;</span></code> in place of an <code><span class='Function'>STMT</span></code>: then the expression is evaluated as usual but its result is checked as discussed below. A result is always required for <code><span class='Function'>BODY</span></code> nodes, and sometimes for <code><span class='Function'>PROGRAM</span></code> nodes (for example, when loaded with <code><span class='Function'>•Import</span></code>). If any identifiers in the node's scope are exported, or any of its statements is an <code><span class='Function'>EXPORT</span></code>, then the result is the namespace created in order to evaluate the node. If a result is required but the namespace case doesn't apply, then the last <code><span class='Function'>STMT</span></code> node must be an <code><span class='Function'>EXPR</span></code> and its result is used. The statement <code><span class='Function'>EXPR</span></code> evaluates some BQN code and possibly assigns the results, while <code><span class='Value'>nothing</span></code> evaluates any <code><span class='Value'>subject</span></code> or <code><span class='Function'>Derv</span></code> terms it contains but discards the results. An <code><span class='Function'>EXPORT</span></code> statement performs no action.</p>
<p>A block consists of several <code><span class='Function'>BODY</span></code> terms, some of which may have an accompanying header describing accepted inputs and how they are processed. An immediate block <code><span class='Value'>blSub</span></code> is evaluated when reached. Other types of blocks don't evaluate any <code><span class='Function'>BODY</span></code> immediately, but instead return a function or modifier that obtains its result by evaluating a particular <code><span class='Function'>BODY</span></code>. The <code><span class='Function'>BODY</span></code> is identified and evaluated once the block has received enough inputs (operands or arguments), which for modifiers takes one call for an <code><span class='Function'>IMM_BLK</span></code> and two for an <code><span class='Function'>ARG_BLK</span></code>. If two calls are required, then on the first call the operands are simply stored and no code is evaluated yet. The stored values can be accessed by equality checking, or <code><span class='Function'>•Decompose</span></code> if defined.</p>
<p>To evaluate a block when enough inputs have been received, each case (<code><span class='Function'>I_CASE</span></code>, <code><span class='Function'>A_CASE</span></code>, or <code><span class='Function'>S_CASE</span></code>), excluding <code><span class='Function'>A_CASE</span></code> nodes whose <code><span class='Function'>ARG_HEAD</span></code> contains <code><span class='String'>&quot;⁼&quot;</span></code>, is tried in order. If any case completes, the block returns the result of that evaluation, and if all cases are tried but none finishes, an error results. A case might not complete because of an incompatible header or failed predicate, as described below. A general case (one with no header or predicates, as defined in the grammar) is always compatible, unless it is the first of two general cases in an <code><span class='Function'>ARG_BLK</span></code> block and a left argument is given—this will be handled by the second case.</p>
<p>If a case has a header, then it must structurally match the inputs to begin evaluation. That is, if <code><span class='Value'>headX</span></code> is an <code><span class='Value'>lhs</span></code>, the right argument must match that structure, and similarly for <code><span class='Function'>HeadF</span></code> with a left operand and <code><span class='Function'>HeadG</span></code> with a right operand. If <code><span class='Value'>headW</span></code> is an <code><span class='Value'>lhs</span></code>, there must be a left argument matching that structure. This means that <code><span class='Value'>𝕨</span></code> not only matches any left argument but also no argument. The test for compatibility is the same as for destructuring assignment described below, except that the header may contain constants, which must match the corresponding part of the given argument. For a compatible header, inputs and other names are bound when evaluation of a <code><span class='Function'>BODY</span></code> is begun. Special names are always bound when applicable: <code><span class='Value'>𝕨𝕩𝕤</span></code> if arguments are used, <code><span class='Value'>𝕨</span></code> if there is a left argument, <code><span class='Value'>𝕗𝕘</span></code> if operands are used, and <code><span class='Modifier'>_𝕣</span></code> and <code><span class='Modifier2'>_𝕣_</span></code> for modifiers and combinators, respectively. Any names in the header are also bound, allowing multiple assignment for arguments.</p>
<p>When a predicate <code><span class='String'>&quot;?&quot;</span></code> is evaluated, the associated <code><span class='Function'>EXPR</span></code> is evaluated and its result is checked. If it's not one of the numbers <code><span class='Number'>0</span></code> or <code><span class='Number'>1</span></code>, an error results. If it's <code><span class='Number'>1</span></code>, evaluation of the <code><span class='Function'>BODY</span></code> continues as usual. If it's <code><span class='Number'>0</span></code>, evaluation is stopped and the next compatible <code><span class='Function'>BODY</span></code> term is evaluated using the block's original inputs.</p>
<p>If there is no left argument, but the <code><span class='Function'>BODY</span></code> contains <code><span class='Value'>𝕨</span></code> or <code><span class='Function'>𝕎</span></code> at the top level, then it is conceptually re-parsed with <code><span class='Value'>𝕨</span></code> replaced by <code><span class='Nothing'>·</span></code> to give a monadic version before application; this modifies the syntax tree by replacing some instances of <code><span class='Value'>subject</span></code>, <code><span class='Value'>arg</span></code>, or <code><span class='Function'>Operand</span></code> with <code><span class='Value'>nothing</span></code>. The token <code><span class='Function'>𝕎</span></code> is not allowed in this case and causes an error. Re-parsing <code><span class='Value'>𝕨</span></code> can also cause an error if it's used as an operand or list element, where <code><span class='Value'>nothing</span></code> is not allowed by the grammar. Note that these errors must not appear if the block is always called with two arguments. True re-parsing is not required, as the same effect can also be achieved dynamically by treating <code><span class='Nothing'>·</span></code> as a value and checking for it during execution. If it's used as a left argument, then the function should instead be called with no left argument (and similarly in trains); if it's used as a right argument, then the function and its left argument are evaluated but rather than calling the function <code><span class='Nothing'>·</span></code> is &quot;returned&quot; immediately; and if it's used in another context then it causes an error.</p>
<h3 id="assignment"><a class="header" href="#assignment">Assignment</a></h3>
<p>An <em>assignment</em> is one of the four rules containing <code><span class='Function'>ASGN</span></code>. It is evaluated by first evaluating the right-hand-side <code><span class='Value'>subExpr</span></code>, <code><span class='Function'>FuncExpr</span></code>, <code><span class='Modifier'>_m1Expr</span></code>, or <code><span class='Modifier2'>_m2Exp_</span></code> expression, and then storing the result in the left-hand-side identifier or identifiers. The result of the assignment expression is the result of its right-hand side. Except for subjects, only a lone identifier is allowed on the left-hand side and storage sets it equal to the result. For subjects, <em>destructuring assignment</em> is performed when an <code><span class='Value'>lhs</span></code> is <code><span class='Value'>lhsList</span></code>, <code><span class='Value'>lhsStr</span></code>, or <code><span class='Value'>lhsArray</span></code>. Destructuring assignment is performed recursively by assigning right-hand-side values to the left-hand-side targets, with single-identifier assignment as the base case. The target <code><span class='String'>&quot;·&quot;</span></code> is also possible in place of a <code><span class='Function'>NAME</span></code>, and performs no assignment.</p>
<p>In assignment to <code><span class='Value'>lhsList</span></code> or <code><span class='Value'>lhsStr</span></code>, the right-hand-side value, here called <code><span class='Value'>v</span></code>, must be a list (rank 1 array) or namespace. If it's a list, then each <code><span class='Function'>LHS_ENTRY</span></code> node must be an <code><span class='Function'>LHS_ELT</span></code>. The left-hand side is treated as a list of <code><span class='Value'>lhs</span></code> targets, and matched to <code><span class='Value'>v</span></code> element-wise, with an error if the two lists differ in length. If <code><span class='Value'>v</span></code> is a namespace, then the left-hand side must be an <code><span class='Value'>lhsStr</span></code> where every <code><span class='Function'>LHS_ATOM</span></code> is an <code><span class='Function'>NAME</span></code>, or an <code><span class='Value'>lhsList</span></code> where every <code><span class='Function'>LHS_ENTRY</span></code> is an <code><span class='Function'>NAME</span></code> or <code><span class='Value'>lhs</span> <span class='String'>&quot;⇐&quot;</span> <span class='Function'>NAME</span></code>, so that it can be considered a list of <code><span class='Function'>NAME</span></code> nodes some of which are also associated with <code><span class='Value'>lhs</span></code> nodes. To perform the assignment, the value of each name is obtained from the namespace <code><span class='Value'>v</span></code>, giving an error if <code><span class='Value'>v</span></code> does not define that name. The value is assigned to the <code><span class='Value'>lhs</span></code> node if present (which may be a destructuring assignment or simple subject assignment), and otherwise assigned to the same <code><span class='Function'>NAME</span></code> node used to get it from <code><span class='Value'>v</span></code>.</p>
<p>Assignment to <code><span class='Value'>lhsArray</span></code> destructures the major cells of right-hand-side value <code><span class='Value'>v</span></code>, which must be an array of rank at least 1. The number of cells in <code><span class='Value'>v</span></code> is its length <code><span class='Value'>l</span></code>, that is, the first element of its shape. The shape of each is the shape of <code><span class='Value'>v</span></code> without its first element, and the cell ravels are formed by splitting <code><span class='Value'>v</span></code>'s ravel evenly into <code><span class='Value'>l</span></code> sections. Besides this difference in how <code><span class='Value'>v</span></code> is divided, assignment behaves the same way as assignment of a list <code><span class='Value'>v</span></code> to <code><span class='Value'>lhsList</span></code>.</p>
<p>A destructuring assignment is performed in program order, or equivalently index order, with each sub-assignment fully completed before beginning the next (a depth-first order). Thus if an assignment with <code><span class='Gets'>↩</span></code> encounters an error but it's caught with <code><span class='Modifier2'>⎊</span></code>, some of the assignment may have already been performed, changing variable values.</p>
<p><em>Modified assignment</em> is the subject assignment rule <code><span class='Value'>lhs</span> <span class='Function'>Derv</span> <span class='String'>&quot;↩&quot;</span> <span class='Value'>subExpr</span><span class='Head'>?</span></code>. This case results in an error if <code><span class='Value'>lhs</span></code> contains <code><span class='String'>&quot;·&quot;</span></code>, <code><span class='String'>&quot;⇐&quot;</span></code>, or an empty <code><span class='Value'>lhsArray</span></code> node (one with no <code><span class='Function'>LHS_ELT</span></code> components). With these conditions, the grammar for <code><span class='Value'>lhs</span></code> is a subset of <code><span class='Value'>subExpr</span></code>; the node is evaluated as if it were a <code><span class='Value'>subExpr</span></code>, and passed as an argument to <code><span class='Function'>Derv</span></code>. The full application is <code><span class='Value'>lhs</span> <span class='Function'>Derv</span> <span class='Value'>subExpr</span></code>, if <code><span class='Value'>subExpr</span></code> is given, and <code><span class='Function'>Derv</span> <span class='Value'>lhs</span></code> otherwise. Its value is assigned to <code><span class='Value'>lhs</span></code>, and is also the result of the modified assignment expression.</p>
<h3 id="expressions"><a class="header" href="#expressions">Expressions</a></h3>
<p>We now give rules for evaluating an <code><span class='Value'>atom</span></code>, <code><span class='Function'>Func</span></code>, <code><span class='Modifier'>_mod1</span></code> or <code><span class='Modifier2'>_mod2_</span></code> expression (the possible options for <code><span class='Function'>ANY</span></code>). A literal or primitive <code><span class='Value'>sl</span></code>, <code><span class='Function'>Fl</span></code>, <code><span class='Modifier'>_ml</span></code>, or <code><span class='Modifier2'>_cl_</span></code> has a fixed value defined by the specification (<a href="literal.html">literals</a> and <a href="primitive.html">built-ins</a>). An identifier <code><span class='Value'>s</span></code>, <code><span class='Function'>F</span></code>, <code><span class='Modifier'>_m</span></code>, or <code><span class='Modifier2'>_c_</span></code>, if not preceded by <code><span class='Value'>atom</span> <span class='String'>&quot;.&quot;</span></code>, must have an associated variable due to the scoping rules, and returns this variable's value, or causes an error if it has not yet been set. If it is preceded by <code><span class='Value'>atom</span> <span class='String'>&quot;.&quot;</span></code>, then the <code><span class='Value'>atom</span></code> node is evaluated first; its value must be a namespace, and the result is the value of the identifier's name in the namespace, or an error if the name is undefined. A parenthesized expression such as <code><span class='String'>&quot;(&quot;</span> <span class='Modifier'>_modExpr</span> <span class='String'>&quot;)&quot;</span></code> simply returns the result of the interior expression. A block is defined by the evaluation of the statements it contains after all parameters are accepted, as described above.</p>
<p>A list <code><span class='String'>&quot;⟨&quot;</span> <span class='Separator'>⋄</span><span class='Head'>?</span> <span class='Paren'>(</span> <span class='Paren'>(</span> <span class='Function'>EXPR</span> <span class='Separator'>⋄</span> <span class='Paren'>)</span><span class='Value'>*</span> <span class='Function'>EXPR</span> <span class='Separator'>⋄</span><span class='Head'>?</span> <span class='Paren'>)</span><span class='Head'>?</span> <span class='String'>&quot;⟩&quot;</span></code> or <code><span class='Function'>ANY</span> <span class='Paren'>(</span> <span class='String'>&quot;‿&quot;</span> <span class='Function'>ANY</span> <span class='Paren'>)</span><span class='Function'>+</span></code> consists grammatically of a list of expressions. To evaluate it, each expression is evaluated in source order and their results are placed as elements of a rank-1 array. The two forms have identical semantics but different punctuation. The square bracket notation <code><span class='String'>&quot;[&quot;</span> <span class='Separator'>⋄</span><span class='Head'>?</span>   <span class='Paren'>(</span> <span class='Function'>EXPR</span> <span class='Separator'>⋄</span> <span class='Paren'>)</span><span class='Value'>*</span> <span class='Function'>EXPR</span> <span class='Separator'>⋄</span><span class='Head'>?</span>    <span class='String'>&quot;]&quot;</span></code> evaluates expressions in the same way, but makes them into major cells of an array instead of elements. The result is identical to applying the <a href="primitive.html">primitive</a> function Merge (<code><span class='Function'>&gt;</span></code>) to a list of the expression results.</p>
<p>Rules in the table below are function and modifier evaluation.</p>
<table>
<thead>
<tr>
<th>L</th>
<th>Left</th>
<th>Called</th>
<th>Right</th>
<th>R</th>
<th>Types</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span class='Value'>𝕨</span></code></td>
<td><code><span class='Paren'>(</span> <span class='Value'>subject</span> <span class='Function'>|</span> <span class='Value'>nothing</span> <span class='Paren'>)</span><span class='Head'>?</span></code></td>
<td><code><span class='Function'>Derv</span></code></td>
<td><code><span class='Value'>arg</span></code></td>
<td><code><span class='Value'>𝕩</span></code></td>
<td>Function, subject</td>
</tr>
<tr>
<td><code><span class='Value'>𝕗</span></code></td>
<td><code><span class='Function'>Operand</span></code></td>
<td><code><span class='Modifier'>_mod1</span></code></td>
<td></td>
<td></td>
<td>1-Modifier</td>
</tr>
<tr>
<td><code><span class='Value'>𝕗</span></code></td>
<td><code><span class='Function'>Operand</span></code></td>
<td><code><span class='Modifier2'>_mod2_</span></code></td>
<td><code><span class='Paren'>(</span> <span class='Value'>subject</span> <span class='Function'>|</span> <span class='Function'>Func</span> <span class='Paren'>)</span></code></td>
<td><code><span class='Value'>𝕘</span></code></td>
<td>2-Modifier</td>
</tr>
</tbody>
</table>
<p>In each case the constituent expressions are evaluated in reverse source order: Right, then Called, then Left. Then the expression's result is obtained by calling the Called value on its parameters. A left argument of <code><span class='Value'>nothing</span></code> is not used as a parameter, leaving only a right argument in that case. The type of the Called value must be appropriate to the expression type, as indicated in the &quot;Types&quot; column. For function application, a data type (number, character, or array) is allowed. It is called simply by returning itself. Although the arguments are ignored in this case, they are still evaluated. A block is evaluated by binding the parameter names given in columns L and R to the corresponding values. Then if all parameter levels present have been bound, its body is evaluated to give the result of application.</p>
<p>Modifiers that are evaluated when they receive operands are called <em>immediate</em>. Other modifiers, including primitives and some kinds of block, simply record the operands and are called <em>deferred</em>. The result of applying a deferred modifier once is called a <em>derived function</em>, and is one kind of <em>compound function</em>.</p>
<p>The rules for trains create another kind of compound function. A compound function is identified by the rule that created it, and the values of its parts.</p>
<table>
<thead>
<tr>
<th>Left</th>
<th>Center</th>
<th>Right</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span class='Function'>Operand</span></code></td>
<td><code><span class='Function'>Derv</span></code></td>
<td><code><span class='Function'>Fork</span></code></td>
<td><code><span class='Brace'>{</span><span class='Paren'>(</span><span class='Value'>𝕨</span><span class='Function'>L</span><span class='Value'>𝕩</span><span class='Paren'>)</span><span class='Function'>C</span><span class='Paren'>(</span><span class='Value'>𝕨</span><span class='Function'>R</span><span class='Value'>𝕩</span><span class='Paren'>)</span><span class='Brace'>}</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>nothing</span><span class='Head'>?</span></code></td>
<td><code><span class='Function'>Derv</span></code></td>
<td><code><span class='Function'>Fork</span></code></td>
<td><code><span class='Brace'>{</span>     <span class='Function'>C</span><span class='Paren'>(</span><span class='Value'>𝕨</span><span class='Function'>R</span><span class='Value'>𝕩</span><span class='Paren'>)</span><span class='Brace'>}</span></code></td>
</tr>
</tbody>
</table>
<p>A <em>train</em> is a function that, when called, calls the right-hand function on all arguments, then the left-hand function, and calls the center function with these results as arguments. As with applications, all expressions are evaluated in reverse source order before doing anything else. Then a result is formed without calling the center value. Its behavior as a function is described in the rightmost column, using <code><span class='Function'>L</span></code>, <code><span class='Function'>C</span></code>, and <code><span class='Function'>R</span></code> for the results of the expressions in the left, center, and right columns, respectively.</p>
