<head>
  <link href="../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../style.css" rel="stylesheet"/>
  <title>Specification: BQN grammar</title>
</head>
<div class="nav"><a href="https://github.com/mlochbaum/BQN">BQN</a> / <a href="../index.html">main</a> / <a href="index.html">spec</a></div>
<h1 id="specification-bqn-grammar">Specification: BQN grammar</h1>
<p>BQN's grammar is given below. Terms are defined in a <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a> variant. However, handling special names properly is possible but difficult in BNF, so they are explained in text along with the braced block grammar.</p>
<p>The symbols <code><span class='Value'>s</span></code>, <code><span class='Function'>F</span></code>, <code><span class='Modifier'>_m</span></code>, and <code><span class='Modifier2'>_c_</span></code> are identifier tokens with subject, function, 1-modifier, and 2-modifier classes respectively. Similarly, <code><span class='Value'>sl</span></code>, <code><span class='Function'>Fl</span></code>, <code><span class='Modifier'>_ml</span></code>, and <code><span class='Modifier2'>_cl_</span></code> refer to literals and primitives of those classes. While names in the BNF here follow the identifier naming scheme, this is informative only: syntactic classes are no longer used after parsing and cannot be inspected in a running program.</p>
<p>A program is a list of statements. Almost all statements are expressions. Valueless results stemming from <code><span class='Nothing'>¬∑</span></code>, or <code><span class='Value'>ùï®</span></code> in a monadic brace function, can be used as statements but not expressions. &quot;Namespace statements&quot;, which import multiple values from a namespace block (immediate block containing <code><span class='Gets'>‚áê</span></code>), also cannot be expressions. An extension to BQN to allow first-class namespaces would extend ordinary expressions so that <code><span class='Function'>NS_STMT</span></code> would no longer be needed, as it would be a subset of <code><span class='Function'>EXPR</span></code>.</p>
<pre><span class='Function'>PROGRAM</span>  <span class='Function'>=</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Paren'>(</span> <span class='Paren'>(</span> <span class='Function'>STMT</span> <span class='Separator'>‚ãÑ</span> <span class='Paren'>)</span><span class='Value'>*</span> <span class='Function'>STMT</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Paren'>)</span><span class='Value'>?</span>
<span class='Function'>STMT</span>     <span class='Function'>=</span> <span class='Function'>BSTMT</span> <span class='Function'>|</span> <span class='Function'>EXPORT</span>
<span class='Function'>BSTMT</span>    <span class='Function'>=</span> <span class='Function'>EXPR</span> <span class='Function'>|</span> <span class='Value'>nothing</span> <span class='Function'>|</span> <span class='Function'>NS_STMT</span>
<span class='Separator'>‚ãÑ</span>        <span class='Function'>=</span> <span class='Paren'>(</span> <span class='String'>&quot;‚ãÑ&quot;</span> <span class='Function'>|</span> <span class='String'>&quot;,&quot;</span> <span class='Function'>|</span> <span class='Value'>\n</span> <span class='Paren'>)</span><span class='Function'>+</span>
<span class='Function'>EXPR</span>     <span class='Function'>=</span> <span class='Value'>subExpr</span> <span class='Function'>|</span> <span class='Function'>FuncExpr</span> <span class='Function'>|</span> <span class='Modifier'>_m1Expr</span> <span class='Function'>|</span> <span class='Modifier2'>_m2Expr_</span>
</pre>
<p>Here we define the &quot;atomic&quot; forms of functions and modifiers, which are either single tokens or enclosed in paired symbols. Stranded vectors with <code><span class='Ligature'>‚Äø</span></code>, which binds more tightly than any form of execution, are also included.</p>
<pre><span class='Function'>ANY</span>      <span class='Function'>=</span> <span class='Value'>atom</span>    <span class='Function'>|</span> <span class='Function'>Func</span>     <span class='Function'>|</span> <span class='Modifier'>_mod1</span>    <span class='Function'>|</span> <span class='Modifier2'>_mod2_</span>
<span class='Modifier2'>_mod2_</span>   <span class='Function'>=</span> <span class='Modifier2'>_c_</span> <span class='Function'>|</span> <span class='Modifier2'>_cl_</span> <span class='Function'>|</span> <span class='String'>&quot;(&quot;</span> <span class='Modifier2'>_m1Expr_</span> <span class='String'>&quot;)&quot;</span> <span class='Function'>|</span> <span class='Modifier2'>_brMod2_</span>
<span class='Modifier'>_mod1</span>    <span class='Function'>=</span> <span class='Modifier'>_m</span>  <span class='Function'>|</span> <span class='Modifier'>_ml</span>  <span class='Function'>|</span> <span class='String'>&quot;(&quot;</span> <span class='Modifier'>_m2Expr</span>  <span class='String'>&quot;)&quot;</span> <span class='Function'>|</span> <span class='Modifier'>_brMod1</span>
<span class='Function'>Func</span>     <span class='Function'>=</span>  <span class='Function'>F</span>  <span class='Function'>|</span>  <span class='Function'>Fl</span>  <span class='Function'>|</span> <span class='String'>&quot;(&quot;</span> <span class='Function'>FuncExpr</span> <span class='String'>&quot;)&quot;</span> <span class='Function'>|</span>  <span class='Function'>BrFunc</span>
<span class='Value'>atom</span>     <span class='Function'>=</span>  <span class='Value'>s</span>  <span class='Function'>|</span>  <span class='Value'>sl</span>  <span class='Function'>|</span> <span class='String'>&quot;(&quot;</span> <span class='Value'>subExpr</span>  <span class='String'>&quot;)&quot;</span> <span class='Function'>|</span>  <span class='Value'>brSub</span> <span class='Function'>|</span> <span class='Value'>list</span>
<span class='Value'>list</span>     <span class='Function'>=</span> <span class='String'>&quot;‚ü®&quot;</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Paren'>(</span> <span class='Paren'>(</span> <span class='Function'>EXPR</span> <span class='Separator'>‚ãÑ</span> <span class='Paren'>)</span><span class='Value'>*</span> <span class='Function'>EXPR</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='String'>&quot;‚ü©&quot;</span>
<span class='Value'>subject</span>  <span class='Function'>=</span> <span class='Value'>atom</span> <span class='Function'>|</span> <span class='Function'>ANY</span> <span class='Paren'>(</span> <span class='String'>&quot;‚Äø&quot;</span> <span class='Function'>ANY</span> <span class='Paren'>)</span><span class='Function'>+</span>
</pre>
<p>Starting at the highest-order objects, modifiers have fairly simple syntax. In most cases the syntax for <code><span class='Gets'>‚Üê</span></code> and <code><span class='Gets'>‚Ü©</span></code> is the same, but only <code><span class='Gets'>‚Ü©</span></code> can be used for modified assignment. The export arrow <code><span class='Gets'>‚áê</span></code> can only be used in namespace blocks <code><span class='Value'>brNS</span></code>, and the top-level <code><span class='Function'>PROGRAM</span></code>. There it can be used in the same ways as <code><span class='Gets'>‚Üê</span></code>, but it can also be used in a <code><span class='Value'>brNS</span></code> header, or with no expression on the right in an <code><span class='Function'>EXPORT</span></code> statement.</p>
<pre><span class='Function'>ASGN</span>     <span class='Function'>=</span> <span class='String'>&quot;‚Üê&quot;</span> <span class='Function'>|</span> <span class='String'>&quot;‚áê&quot;</span> <span class='Function'>|</span> <span class='String'>&quot;‚Ü©&quot;</span>
<span class='Modifier2'>_m2Expr_</span> <span class='Function'>=</span> <span class='Modifier2'>_mod2_</span>
         <span class='Function'>|</span> <span class='Modifier2'>_c_</span> <span class='Function'>ASGN</span> <span class='Modifier2'>_m2Expr_</span>
<span class='Modifier'>_m1Expr</span>  <span class='Function'>=</span> <span class='Modifier'>_mod1</span>
         <span class='Function'>|</span> <span class='Modifier2'>_mod2_</span> <span class='Paren'>(</span> <span class='Value'>subject</span> <span class='Function'>|</span> <span class='Function'>Func</span> <span class='Paren'>)</span>  <span class='Comment'># Right partial application
</span>         <span class='Function'>|</span> <span class='Function'>Operand</span> <span class='Modifier2'>_mod2_</span>             <span class='Comment'># Left partial application
</span>         <span class='Function'>|</span> <span class='Modifier'>_m</span>  <span class='Function'>ASGN</span> <span class='Modifier'>_m1Expr</span>
</pre>
<p>Functions can be formed by fully applying modifiers or as trains. modifiers are left-associative, so that the left operand (<code><span class='Function'>Operand</span></code>) can include modifier applications but the right operand (<code><span class='Value'>subject</span> <span class='Function'>|</span> <span class='Function'>Func</span></code>) cannot. Trains are right-associative, but bind less tightly than modifiers. Assignment is not allowed in the top level of a train: it must be parenthesized.</p>
<pre><span class='Function'>Derv</span>     <span class='Function'>=</span> <span class='Function'>Func</span>
         <span class='Function'>|</span> <span class='Function'>Operand</span> <span class='Modifier'>_mod1</span>
         <span class='Function'>|</span> <span class='Function'>Operand</span> <span class='Modifier2'>_mod2_</span> <span class='Paren'>(</span> <span class='Value'>subject</span> <span class='Function'>|</span> <span class='Function'>Func</span> <span class='Paren'>)</span>
<span class='Function'>Operand</span>  <span class='Function'>=</span> <span class='Value'>subject</span>
         <span class='Function'>|</span> <span class='Function'>Derv</span>
<span class='Function'>Fork</span>     <span class='Function'>=</span> <span class='Function'>Derv</span>
         <span class='Function'>|</span> <span class='Function'>Operand</span> <span class='Function'>Derv</span> <span class='Function'>Fork</span>          <span class='Comment'># 3-train
</span>         <span class='Function'>|</span> <span class='Value'>nothing</span> <span class='Function'>Derv</span> <span class='Function'>Fork</span>          <span class='Comment'># 2-train
</span><span class='Function'>Train</span>    <span class='Function'>=</span> <span class='Function'>Fork</span>
         <span class='Function'>|</span> <span class='Function'>Derv</span> <span class='Function'>Fork</span>                  <span class='Comment'># 2-train
</span><span class='Function'>FuncExpr</span> <span class='Function'>=</span> <span class='Function'>Train</span>
         <span class='Function'>|</span> <span class='Function'>F</span> <span class='Function'>ASGN</span> <span class='Function'>FuncExpr</span>
</pre>
<p>Subject expressions are complicated by the possibility of list assignment. We also define nothing-statements, which have very similar syntax to subject expressions but do not permit assignment.</p>
<pre><span class='Value'>arg</span>      <span class='Function'>=</span> <span class='Value'>subExpr</span>
         <span class='Function'>|</span> <span class='Paren'>(</span> <span class='Value'>subject</span> <span class='Function'>|</span> <span class='Value'>nothing</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Function'>Derv</span> <span class='Value'>arg</span>
<span class='Value'>nothing</span>  <span class='Function'>=</span> <span class='String'>&quot;¬∑&quot;</span>
         <span class='Function'>|</span> <span class='Paren'>(</span> <span class='Value'>subject</span> <span class='Function'>|</span> <span class='Value'>nothing</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Function'>Derv</span> <span class='Value'>nothing</span>
<span class='Function'>LHS_NAME</span> <span class='Function'>=</span> <span class='Value'>s</span> <span class='Function'>|</span> <span class='Function'>F</span> <span class='Function'>|</span> <span class='Modifier'>_m</span> <span class='Function'>|</span> <span class='Modifier2'>_c_</span>
<span class='Function'>LHS_ANY</span>  <span class='Function'>=</span> <span class='Function'>LHS_NAME</span>
         <span class='Function'>|</span> <span class='String'>&quot;‚ü®&quot;</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Paren'>(</span> <span class='Paren'>(</span> <span class='Function'>LHS_ELT</span> <span class='Separator'>‚ãÑ</span> <span class='Paren'>)</span><span class='Value'>*</span> <span class='Function'>LHS_ELT</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='String'>&quot;‚ü©&quot;</span>
<span class='Function'>LHS_ATOM</span> <span class='Function'>=</span> <span class='Function'>LHS_ANY</span> <span class='Function'>|</span> <span class='String'>&quot;(&quot;</span> <span class='Value'>lhsStr</span> <span class='String'>&quot;)&quot;</span>
<span class='Function'>LHS_ELT</span>  <span class='Function'>=</span> <span class='Function'>LHS_ANY</span> <span class='Function'>|</span> <span class='Value'>lhsStr</span>
<span class='Value'>lhsStr</span>   <span class='Function'>=</span> <span class='Function'>LHS_ATOM</span> <span class='Paren'>(</span> <span class='String'>&quot;‚Äø&quot;</span> <span class='Function'>LHS_ATOM</span> <span class='Paren'>)</span><span class='Function'>+</span>
<span class='Value'>lhs</span>      <span class='Function'>=</span> <span class='Value'>s</span> <span class='Function'>|</span> <span class='Value'>lhsSub</span> <span class='Function'>|</span> <span class='Value'>lhsStr</span>
<span class='Value'>subExpr</span>  <span class='Function'>=</span> <span class='Value'>arg</span>
         <span class='Function'>|</span> <span class='Value'>lhs</span> <span class='Function'>ASGN</span> <span class='Value'>subExpr</span>
         <span class='Function'>|</span> <span class='Value'>lhs</span> <span class='Function'>Derv</span> <span class='String'>&quot;‚Ü©&quot;</span> <span class='Value'>subExpr</span>       <span class='Comment'># Modified assignment
</span></pre>
<p>A header looks like a name for the thing being headed, or its application to inputs (possibly twice in the case of modifiers). As with assignment, it is restricted to a simple form with no extra parentheses. The full list syntax is allowed for arguments. As a special rule, a monadic function header specifically can omit the function when the argument is not just a name (as this would conflict with a subject label). The following cases define only headers with arguments, which are assumed to be special cases; there can be any number of these. Headers without arguments can only refer to the general case‚Äînote that operands are not pattern matched‚Äîso there can be at most two of these kinds of headers, indicating the monadic and dyadic cases.</p>
<pre><span class='Value'>headW</span>    <span class='Function'>=</span> <span class='Value'>subject</span> <span class='Function'>|</span> <span class='String'>&quot;ùï®&quot;</span>
<span class='Value'>headX</span>    <span class='Function'>=</span> <span class='Value'>subject</span> <span class='Function'>|</span> <span class='String'>&quot;ùï©&quot;</span>
<span class='Function'>HeadF</span>    <span class='Function'>=</span> <span class='Function'>F</span> <span class='Function'>|</span> <span class='String'>&quot;ùïó&quot;</span> <span class='Function'>|</span> <span class='String'>&quot;ùîΩ&quot;</span>
<span class='Function'>HeadG</span>    <span class='Function'>=</span> <span class='Function'>F</span> <span class='Function'>|</span> <span class='String'>&quot;ùïò&quot;</span> <span class='Function'>|</span> <span class='String'>&quot;ùîæ&quot;</span>
<span class='Function'>Mod1H1</span>   <span class='Function'>=</span> <span class='Function'>HeadF</span> <span class='Paren'>(</span> <span class='Modifier'>_m</span>  <span class='Function'>|</span> <span class='String'>&quot;_ùï£&quot;</span>  <span class='Paren'>)</span>
<span class='Function'>Mod2H1</span>   <span class='Function'>=</span> <span class='Function'>HeadF</span> <span class='Paren'>(</span> <span class='Modifier2'>_c_</span> <span class='Function'>|</span> <span class='String'>&quot;_ùï£_&quot;</span> <span class='Paren'>)</span> <span class='Function'>HeadG</span>
<span class='Function'>FuncHead</span> <span class='Function'>=</span> <span class='Value'>headW?</span> <span class='Paren'>(</span> <span class='Function'>F</span> <span class='Function'>|</span> <span class='String'>&quot;ùïä&quot;</span> <span class='Paren'>)</span> <span class='Value'>headX</span>
         <span class='Function'>|</span> <span class='Value'>sl</span> <span class='Function'>|</span> <span class='String'>&quot;(&quot;</span> <span class='Value'>subExpr</span> <span class='String'>&quot;)&quot;</span> <span class='Function'>|</span> <span class='Value'>brSub</span> <span class='Function'>|</span> <span class='Value'>list</span>   <span class='Comment'># subject,
</span>         <span class='Function'>|</span> <span class='Function'>ANY</span> <span class='Paren'>(</span> <span class='String'>&quot;‚Äø&quot;</span> <span class='Function'>ANY</span> <span class='Paren'>)</span><span class='Function'>+</span>                      <span class='Comment'># but not s
</span><span class='Modifier'>_m1Head</span>  <span class='Function'>=</span> <span class='Value'>headW?</span> <span class='Function'>Mod1H1</span> <span class='Value'>headX</span>
<span class='Modifier2'>_m2Head_</span> <span class='Function'>=</span> <span class='Value'>headW?</span> <span class='Function'>Mod2H1</span> <span class='Value'>headX</span>
</pre>
<p>A braced block contains bodies, which are lists of statements, separated by semicolons and possibly preceded by headers, which are separated from the body with a colon. Multiple bodies allow different handling for various cases, which are pattern-matched by headers. For an immediate block there are no inputs, so there can only be one possible case and one body. Functions and modifiers allow any number of &quot;matched&quot; bodies, with headers that have arguments, followed by at most two &quot;main&quot; bodies with either no headers or headers without arguments. If there is one main body, it is ambivalent, but two main bodies refer to the monadic and dyadic cases.</p>
<pre><span class='Function'>BODY</span>     <span class='Function'>=</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Paren'>(</span> <span class='Function'>BSTMT</span> <span class='Separator'>‚ãÑ</span> <span class='Paren'>)</span><span class='Value'>*</span> <span class='Function'>EXPR</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span>
<span class='Function'>FCase</span>    <span class='Function'>=</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Function'>FuncHead</span> <span class='String'>&quot;:&quot;</span> <span class='Function'>BODY</span>
<span class='Modifier'>_mCase</span>   <span class='Function'>=</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Modifier'>_m1Head</span>  <span class='String'>&quot;:&quot;</span> <span class='Function'>BODY</span>
<span class='Modifier2'>_cCase_</span>  <span class='Function'>=</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Modifier2'>_m2Head_</span> <span class='String'>&quot;:&quot;</span> <span class='Function'>BODY</span>
<span class='Function'>FMain</span>    <span class='Function'>=</span> <span class='Paren'>(</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Paren'>(</span>  <span class='Function'>F</span>  <span class='Function'>|</span>  <span class='String'>&quot;ùïä&quot;</span>           <span class='Paren'>)</span> <span class='String'>&quot;:&quot;</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Function'>BODY</span>
<span class='Modifier'>_mMain</span>   <span class='Function'>=</span> <span class='Paren'>(</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Paren'>(</span> <span class='Modifier'>_m</span>  <span class='Function'>|</span> <span class='String'>&quot;_ùï£&quot;</span>  <span class='Function'>|</span> <span class='Function'>Mod1H1</span> <span class='Paren'>)</span> <span class='String'>&quot;:&quot;</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Function'>BODY</span>
<span class='Modifier2'>_cMain_</span>  <span class='Function'>=</span> <span class='Paren'>(</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Paren'>(</span> <span class='Modifier2'>_c_</span> <span class='Function'>|</span> <span class='String'>&quot;_ùï£_&quot;</span> <span class='Function'>|</span> <span class='Function'>Mod2H1</span> <span class='Paren'>)</span> <span class='String'>&quot;:&quot;</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Function'>BODY</span>
<span class='Value'>brSub</span>    <span class='Function'>=</span> <span class='String'>&quot;{&quot;</span> <span class='Paren'>(</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Value'>s</span> <span class='String'>&quot;:&quot;</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Function'>BODY</span> <span class='String'>&quot;}&quot;</span>
<span class='Function'>BrFunc</span>   <span class='Function'>=</span> <span class='String'>&quot;{&quot;</span> <span class='Paren'>(</span>  <span class='Function'>FCase</span>  <span class='String'>&quot;;&quot;</span> <span class='Paren'>)</span><span class='Value'>*</span> <span class='Paren'>(</span>  <span class='Function'>FCase</span>  <span class='Function'>|</span>  <span class='Function'>FMain</span> <span class='Paren'>(</span> <span class='String'>&quot;;&quot;</span>  <span class='Function'>FMain</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Paren'>)</span> <span class='String'>&quot;}&quot;</span>
<span class='Modifier'>_brMod1</span>  <span class='Function'>=</span> <span class='String'>&quot;{&quot;</span> <span class='Paren'>(</span> <span class='Modifier'>_mCase</span>  <span class='String'>&quot;;&quot;</span> <span class='Paren'>)</span><span class='Value'>*</span> <span class='Paren'>(</span> <span class='Modifier'>_mCase</span>  <span class='Function'>|</span> <span class='Modifier'>_mMain</span> <span class='Paren'>(</span> <span class='String'>&quot;;&quot;</span> <span class='Modifier'>_mMain</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Paren'>)</span> <span class='String'>&quot;}&quot;</span>
<span class='Modifier2'>_brMod2_</span> <span class='Function'>=</span> <span class='String'>&quot;{&quot;</span> <span class='Paren'>(</span> <span class='Modifier2'>_cCase_</span> <span class='String'>&quot;;&quot;</span> <span class='Paren'>)</span><span class='Value'>*</span> <span class='Paren'>(</span> <span class='Modifier2'>_cCase_</span> <span class='Function'>|</span> <span class='Modifier2'>_cMan_</span> <span class='Paren'>(</span> <span class='String'>&quot;;&quot;</span> <span class='Modifier2'>_cMan_</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Paren'>)</span> <span class='String'>&quot;}&quot;</span>
</pre>
<p>A namespace block is very similar in grammar to an ordinary immediate block, but allows export declarations with <code><span class='Gets'>‚áê</span></code>, either in place of the ordinary definition <code><span class='Gets'>‚Üê</span></code> or in the special <code><span class='Function'>EXPORT</span></code> statement. The arrow <code><span class='Gets'>‚áê</span></code> can also be placed in the header to mark a namespace block. Since the block returns all exported values and not the result of the last line, the last line does not need to be an expression.</p>
<pre><span class='Function'>NS_STMT</span>  <span class='Function'>=</span> <span class='Value'>nsLHS</span> <span class='Function'>ASGN</span> <span class='Value'>brNS</span>
<span class='Function'>NS_VAR</span>   <span class='Function'>=</span> <span class='Paren'>(</span> <span class='Value'>lhs</span> <span class='String'>&quot;‚áê&quot;</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Function'>LHS_NAME</span>
<span class='Value'>nsLHS</span>    <span class='Function'>=</span> <span class='Function'>LHS_NAME</span> <span class='Paren'>(</span> <span class='String'>&quot;‚Äø&quot;</span> <span class='Function'>LHS_NAME</span> <span class='Paren'>)</span><span class='Function'>+</span>
         <span class='Function'>|</span> <span class='String'>&quot;‚ü®&quot;</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Paren'>(</span> <span class='Paren'>(</span> <span class='Function'>NS_VAR</span> <span class='Separator'>‚ãÑ</span> <span class='Paren'>)</span><span class='Value'>*</span> <span class='Function'>NS_VAR</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='String'>&quot;‚ü©&quot;</span>
<span class='Function'>EXPORT</span>   <span class='Function'>=</span> <span class='Paren'>(</span> <span class='Function'>LHS_NAME</span> <span class='Function'>|</span> <span class='Value'>lhsSub</span> <span class='Function'>|</span> <span class='Value'>lhsStr</span> <span class='Paren'>)</span> <span class='String'>&quot;‚áê&quot;</span>
<span class='Function'>NS_BODY</span>  <span class='Function'>=</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='Paren'>(</span> <span class='Function'>STMT</span> <span class='Separator'>‚ãÑ</span> <span class='Paren'>)</span><span class='Value'>*</span> <span class='Function'>STMT</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span>
<span class='Value'>brNS</span>     <span class='Function'>=</span> <span class='String'>&quot;{&quot;</span> <span class='Paren'>(</span> <span class='Separator'>‚ãÑ</span><span class='Value'>?</span> <span class='String'>&quot;‚áê&quot;</span><span class='Value'>?</span> <span class='Value'>s</span> <span class='String'>&quot;:&quot;</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Function'>NS_BODY</span> <span class='String'>&quot;}&quot;</span>
</pre>
<p>Two additional rules apply to blocks, based on the special name associations in the table below. First, each block allows the special names in its column to be used as the given token types within <code><span class='Function'>BODY</span></code> terms (not headers). Except for the spaces labelled &quot;None&quot;, each column is cumulative and a given entry also includes all the entries above it up to the next &quot;None&quot;. Second, for <code><span class='Function'>BrFunc</span></code>, <code><span class='Modifier'>_brMod1</span></code>, <code><span class='Modifier2'>_brMod2_</span></code>, and <code><span class='Value'>brNS</span></code> terms, if no header is given (or, for <code><span class='Value'>brNS</span></code>, if the header does not contain <code><span class='String'>&quot;‚áê&quot;</span></code>), then at least one <code><span class='Function'>BODY</span></code> term in it <em>must</em> contain one of the tokens on, and not above, the corresponding row. Otherwise the syntax would be ambiguous, since for example a simple <code><span class='String'>&quot;{&quot;</span> <span class='Function'>BODY</span> <span class='String'>&quot;}&quot;</span></code> sequence could have any type.</p>
<table>
<thead>
<tr>
<th>Term</th>
<th><code><span class='Value'>s</span></code></th>
<th><code><span class='Function'>F</span></code></th>
<th><code><span class='Modifier'>_m</span></code></th>
<th><code><span class='Modifier2'>_c_</span></code></th>
<th>other</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><span class='Value'>brNS</span></code>, <code><span class='Function'>PROGRAM</span></code></td>
<td>None</td>
<td>None</td>
<td>None</td>
<td>None</td>
<td><code><span class='Gets'>‚áê</span></code></td>
</tr>
<tr>
<td><code><span class='Value'>brSub</span></code></td>
<td>None</td>
<td>None</td>
<td>None</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><code><span class='Function'>BrFunc</span></code></td>
<td><code><span class='Value'>ùï®ùï©ùï§</span></code></td>
<td><code><span class='Function'>ùïéùïèùïä</span></code></td>
<td></td>
<td></td>
<td><code><span class='Value'>;</span></code></td>
</tr>
<tr>
<td><code><span class='Modifier'>_brMod1</span></code></td>
<td><code><span class='Value'>ùïóùï£</span></code></td>
<td><code><span class='Function'>ùîΩ</span></code></td>
<td><code><span class='Modifier'>_ùï£</span></code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code><span class='Modifier2'>_brMod2_</span></code></td>
<td><code><span class='Value'>ùïò</span></code></td>
<td><code><span class='Function'>ùîæ</span></code></td>
<td>None</td>
<td><code><span class='Modifier2'>_ùï£_</span></code></td>
<td></td>
</tr>
</tbody>
</table>
<p>The rules for special name can be expressed in BNF by making many copies of all expression rules above. For each &quot;level&quot;, or row in the table, a new version of every rule should be made that allows that level but not higher ones, and another version should be made that requires exactly that level. The values themselves should be included in <code><span class='Value'>s</span></code>, <code><span class='Function'>F</span></code>, <code><span class='Modifier'>_m</span></code>, and <code><span class='Modifier2'>_c_</span></code> for these copies. Then the &quot;allowed&quot; rules are made simply by replacing the terms they contain (excluding <code><span class='Value'>brSub</span></code> and so on) with the same &quot;allowed&quot; versions, and &quot;required&quot; rules are constructed using both &quot;allowed&quot; and &quot;required&quot; rules. For every part of a production rule, an alternative should be created that requires the relevant name in that part while allowing it in the others. For example, <code><span class='Paren'>(</span> <span class='Value'>subject</span> <span class='Function'>|</span> <span class='Value'>nothing</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Function'>Derv</span> <span class='Value'>arg</span></code> would be transformed to</p>
<pre><span class='Value'>arg_req1</span> <span class='Function'>=</span> <span class='Value'>subExpr_req1</span>
         <span class='Function'>|</span> <span class='Paren'>(</span> <span class='Value'>subject_req1</span> <span class='Function'>|</span> <span class='Value'>nothing_req1</span> <span class='Paren'>)</span> <span class='Function'>Derv_allow1</span> <span class='Value'>arg_allow1</span>
         <span class='Function'>|</span> <span class='Paren'>(</span> <span class='Value'>subject_allow1</span> <span class='Function'>|</span> <span class='Value'>nothing_allow1</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Function'>Derv_req1</span> <span class='Value'>arg_allow1</span>
         <span class='Function'>|</span> <span class='Paren'>(</span> <span class='Value'>subject_allow1</span> <span class='Function'>|</span> <span class='Value'>nothing_allow1</span> <span class='Paren'>)</span><span class='Value'>?</span> <span class='Function'>Derv_allow1</span> <span class='Value'>arg_req1</span>
</pre>
<p>Quite tedious. The explosion of rules is partly due to the fact that the brace-typing rule falls into a weaker class of grammars than the other rules. Most of BQN is <a href="https://en.wikipedia.org/wiki/Deterministic_context-free_grammar">deterministic context-free</a> but brace-typing is not, only context-free. Fortunately brace typing does not introduce the parsing difficulties that can be present in a general context-free grammar, and it can easily be performed in linear time: after <a href="token.html">scanning</a> but before parsing, move through the source code maintaining a stack of the current top-level set of braces. Whenever a colon or special name is encountered, annotate that set of braces to indicate that it is present. When a closing brace is encountered and the top brace is popped off the stack, the type is needed if there was no colon, and can be found based on which names were present. One way to present this information to the parser is to replace the brace tokens with new tokens that indicate the type.</p>
