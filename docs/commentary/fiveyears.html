<head>
  <meta charset="utf-8">
  <link href="../favicon.ico" rel="shortcut icon" type="image/x-icon"/>
  <link href="../style.css" rel="stylesheet"/>
  <title>Five-year review of BQN design</title>
</head>
<div class="nav">(<a href="https://github.com/mlochbaum/BQN">github</a>) / <a href="../index.html">BQN</a> / <a href="index.html">commentary</a></div>
<h1 id="five-year-review-of-bqn-design"><a class="header" href="#five-year-review-of-bqn-design">Five-year review of BQN design</a></h1>
<p>The first commit separating <a href="https://github.com/mlochbaum/BQN2NGN">BQN2NGN</a> from ngn/apl, entitled <a href="https://github.com/mlochbaum/BQN2NGN/commit/8960cfe2511bb4f53bf5567ff31751acf52bb889">Change all the functions</a>, was made on May 10, 2020. BQN's <a href="history.html">design process</a> has no definite beginning, but a concrete implementation marks the first step of evaluating that design. Five years later, what findings can other designers of similar languages take from it? I lay out my personal impressions here.</p>
<p>Many people assume that the goal of any serious language is to be the best, at least in its paradigmâ€”this is not at all how I thought of BQN. I wanted to play it safe and make a solid foundation both for programming and for more ambitious designers in the future. APL offers time-tested ideas (with or without a passing grade): for example, I've discussed how evaluating <a href="ltr.html">left to right</a> was too big of a change to consider. I also wanted to get to a <a href="stability.html">stable</a> core language quickly; I think real advances in array programming will come from explorations by multiple designers over time, not me obsessively polishing this one particular view of it. The upshot is that &quot;I trusted APL too much&quot; was the expected and accepted kind of error, and &quot;my ideas were too bold&quot; should be much rarer!</p>
<p>I'll focus on specifics of language design, and primitives in particular. I do think some other aspects of BQN, like the web REPL and documentation, have pushed language developers to improve on these quality-of-life features. But I don't have so much insight into these choices as there's not as much feedback, and <a href="https://www.uiua.org/">Uiua</a>'s probably a better example now anyway.</p>
<h2 id="primitives"><a class="header" href="#primitives">Primitives</a></h2>
<p>I won't say too much about glyph choices, but it's worth noting that having a convention for primitive functions versus 1- and 2-modifiers is very helpful for learners. I like superscripts but Unicode options for them are very sparse so I suffer for it.</p>
<p>I've discussed <a href="overload.html">overloading</a> and I don't necessarily support trying to pack in a monadic and dyadic meaning for every glyph, but here I'll stick to that framework to evaluate BQN on its own terms.</p>
<h3 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h3>
<p>I mostly stuck with APL's treatment of <a href="../doc/arithmetic.html">arithmetic</a>, and mostly I still think it's fine (having <code><span class='Function'>âŒˆ</span></code> and <code><span class='Function'>âŒŠ</span></code> for maximum and minimum is such a big improvement over non-array languages). Modulus's argument order is right in isolation but backwards relative to <code><span class='Function'>Ã·</span></code>, and <code><span class='Function'>|</span></code> isn't very suggestive, so <code><span class='Value'>%</span></code> or similar for <code><span class='Function'>|</span><span class='Modifier'>Ëœ</span></code> might be better. I'm not happy with <code><span class='Function'>Ã—</span></code> for sign and would rather just remove it in favor of <code><span class='Function'>Ã·</span><span class='Modifier2'>âŸœ</span><span class='Function'>|</span></code>, or <code><span class='Number'>0</span><span class='Paren'>(</span><span class='Function'>&lt;-&gt;</span><span class='Paren'>)</span><span class='Value'>ğ•©</span></code>, or even <code><span class='Number'>Â¯1</span><span class='Function'>â‹†</span><span class='Number'>0</span><span class='Function'>&gt;</span><span class='Value'>ğ•©</span></code> since that shows up tooâ€”although mostly <code><span class='Function'>Ã—</span></code> just ends up as a less clear golf for <code><span class='Number'>0</span><span class='Function'>&lt;</span><span class='Value'>ğ•©</span></code>. Still feel weird about pairing <code><span class='Function'>+</span></code> with complex conjugate but I guess it's got to go somewhere.</p>
<p>Adding <code><span class='Function'>âˆš</span></code> seems like a no-brainer to me (some APLs do it too). There are precision issues around <code><span class='Value'>ğ•¨</span><span class='Function'>âˆš</span><span class='Value'>ğ•©</span></code> since <code><span class='Value'>ğ•©</span><span class='Function'>â‹†Ã·</span><span class='Value'>ğ•¨</span></code> rounds twice, but it's better for the implementation to deal with this stuff than the programmer.</p>
<p>The glyph <code><span class='Function'>â‹†</span></code> (star) has caused minor confusion with <code><span class='Value'>*</span></code> (asterisk) from APL but avoids confusion with <code><span class='Value'>*</span></code> from everywhere else. I don't have a strong opinion on whether it's worth it or not.</p>
<p>Character arithmetic is great, every language with characters should use it, <a href="https://aplwiki.com/wiki/Character_arithmetic">some newer array languages</a> are already on board.</p>
<p><a href="../doc/logic.html#extension">Linear extensions</a> of logic functions <code><span class='Function'>âˆ§âˆ¨Â¬</span></code>: well, GCD and LCM are clearly rather niche but I don't think the bilinear extensions add a lot of value either. <code><span class='Function'>Â¬</span></code> as <code><span class='Number'>1</span><span class='Function'>-</span><span class='Value'>ğ•©</span></code> is more useful, very nice that <code><span class='Function'>-</span><span class='Modifier2'>âŸœ</span><span class='Function'>Â¬</span></code> sending 0,1 to -1,1 also works as a linear map. The dyadic Span feels good to use when it shows up but isn't that common. The character <code><span class='Function'>Â¬</span></code> is better than <code><span class='Value'>~</span></code> for these because of how the vertical part suggests the added 1.</p>
<p>Leaving out <a href="https://aplwiki.com/wiki/Comparison_tolerance">comparison tolerance</a> has been okay but not entirely painless: you have to be pretty careful when taking the floor of a floating-point computation for example. A global comparison tolerance trades these issues for less noticeable ones in a larger fraction of code, like being wrong on actual near-integers, and weird results and bad performance on searches. I'm still inclined to say it's easier to program correctly with tolerance, but it's a small difference and I don't think it's worth making a bunch of primitives stateful.</p>
<p>IEEE 754 issues: you have to <a href="../implementation/primitive/arithmetic.html#negative-zero">identify</a> -0 with 0 if you want to safely optimize with integer arrays, which you do. We kept IEEE's other float extensions (with all NaNs indistinguishable, allowing us to NaN-box pointers and characters). <code><span class='Number'>Â¯âˆ</span></code> and <code><span class='Number'>âˆ</span></code> are a clear win, and NaN is mixed. It's nice that arithmetic can't error on numbers, and it's often possible to arrange comparisons so that edge cases are handled without extra code, but it's also common for otherwise correct code to give wrong results when NaN is involved.</p>
<h3 id="array-manipulation"><a class="header" href="#array-manipulation">Array manipulation</a></h3>
<p>I'm happy with the glyphs for <a href="../doc/shape.html">array properties</a> Rank (<code><span class='Function'>=</span></code>), Length (<code><span class='Function'>â‰ </span></code>), <a href="../doc/depth.html">Depth</a> (<code><span class='Function'>â‰¡</span></code>), and Shape (<code><span class='Function'>â‰¢</span></code>). Rank is such a basic property that it feels much better to have a dedicated primitive even if it only saves a character, and comparisons like <code><span class='Function'>â‰¤</span><span class='Modifier2'>â—‹</span><span class='Function'>=</span></code> are fairly common. Depth is ugly, as it has to deeply traverse the array when you usually just want to know if the depth is larger than some constant. I think <code><span class='Number'>1</span><span class='Function'>âŒŠâ‰¡</span></code>, that is, 0 for an atom, and 1 for an array, should be considered instead.</p>
<h4 id="flat-arrays"><a class="header" href="#flat-arrays">Flat arrays</a></h4>
<p><a href="../doc/reshape.html">Reshape</a> (<code><span class='Function'>â¥Š</span></code>) ignoring the shape of <code><span class='Value'>ğ•©</span></code> is a blunder; it should work on the first axis like in Jâ€”this is <em>far</em> more useful with computed lengths in particular. This would remove the major reason to pair it with Deshape so there's room for some rethinking here. Another idea to consider is restricting reshape (non-computed at least) to the exact case, and separating out cyclic extension: then cycling could be a multi-axis primitive like Take.</p>
<p>On that note, <a href="../doc/reverse.html">Reverse/Rotate</a> (<code><span class='Function'>âŒ½</span></code>), <a href="../doc/take.html">Take and Drop</a> (<code><span class='Function'>â†‘â†“</span></code>), <a href="../doc/replicate.html">Replicate</a> (<code><span class='Function'>/</span></code>), and <a href="../doc/join.html">Join To</a> (<code><span class='Function'>âˆ¾</span></code>) are all classics, they're fine. Of course Take uses fills, so if you don't like thatâ€¦ maybe it should cycle?</p>
<p><a href="../doc/shift.html">Shifts</a> <code><span class='Function'>Â»Â«</span></code> are super useful, and mostly avoid the problems APL's 2-wise reduction has with length 0. There can still be boundary issues, like it's common to want <code><span class='Function'>Â»</span><span class='Modifier2'>âŠ¸</span><span class='Function'>â‰ </span></code> except the first result is always 1, and no particular shifted value guarantees that. Well <code><span class='Number'>1</span><span class='Function'>Â»â‰ </span><span class='Modifier2'>âŸœ</span><span class='Function'>Â«</span></code> is solid assuming there's a fill, but it's pretty confusing. Also you can't shift a unit into an array with rank&gt;1, maybe the left argument should be rank-extended.</p>
<p>I declare the <a href="../doc/transpose.html">Transpose</a> (<code><span class='Function'>â‰</span></code>) changes a great success! Yeah, dyadic Transpose is still hard for people to understand and some might prefer J's version, but it's all better than what APL had.</p>
<h4 id="nested-arrays"><a class="header" href="#nested-arrays">Nested arrays</a></h4>
<p>The nested result of <a href="../doc/range.html">Range</a> (<code><span class='Function'>â†•</span></code>) on a list argument can be convenient, but it's slow and doesn't encourage array thinking. This suits BQN fine, and I don't think there's much call for an alternative like K's odometer, as the dedicated array programmer would mostly use <code><span class='Modifier'>âŒœ</span></code> regardless.</p>
<p><a href="../doc/pair.html">Enlist/Pair</a> (<code><span class='Function'>â‹ˆ</span></code>) is very useful, pretty embarrassing it took me over a year to add it. <a href="../doc/couple.html">Solo/Couple</a> (<code><span class='Function'>â‰</span></code>) now seems somewhat less important but is still nice to have, particularly for stuff like zipping with <code><span class='Function'>â‰</span><span class='Modifier'>Ë˜</span></code>.</p>
<p><a href="../doc/enclose.html">Enclose</a> (<code><span class='Function'>&lt;</span></code>) is what it is. <a href="../doc/couple.html">Merge</a> (<code><span class='Function'>&gt;</span></code>) is good and I'm still happy with the choice to be strict about shapes, even if it's annoying in code golf. The multi-dimensional form of <a href="../doc/join.html#join">Join</a> (<code><span class='Function'>âˆ¾</span></code>) comes in handy a lot when working with rank-2 arrays. The extension to allow some elements to have lower ranks was a nightmare to define and tough to implement too. Not having it was frustrating, but it might be possible to get by just allowing a mix of rank-0 and rank-1 elements in a list as a special case.</p>
<p><a href="../doc/prefixes.html">Prefixes</a> (<code><span class='Function'>â†‘</span></code>), Suffixes (<code><span class='Function'>â†“</span></code>), and <a href="../doc/windows.html">Windows</a> (<code><span class='Function'>â†•</span></code>) are not pulling their weight. They're useful theoretical tools but aren't very practical. For prefixes/suffixes you almost always want either <code><span class='Number'>1</span><span class='Function'>â†“â†‘</span></code>, <code><span class='Function'>â‰ â†‘â†‘</span></code>, <code><span class='Number'>1</span><span class='Function'>â†“â†“</span></code>, or <code><span class='Function'>â‰ â†‘â†“</span></code>, and figuring out which one is a headache. I'd suggest <code><span class='Number'>Â¯1</span><span class='Modifier2'>âŠ¸</span><span class='Function'>â†“</span></code> and <code><span class='Number'>1</span><span class='Modifier2'>âŠ¸</span><span class='Function'>â†“</span></code> as better uses for the glyphs <code><span class='Function'>â†‘</span></code> and <code><span class='Function'>â†“</span></code> respectively (so pairwise differences are <code><span class='Function'>â†“-â†‘</span></code> for example). And writing a windowed reduction with <code><span class='Function'>+</span><span class='Modifier'>ËË˜</span><span class='Value'>k</span><span class='Function'>â†•</span><span class='Value'>ğ•©</span></code> is a lot of ceremony, but really for performance you mostly want <code><span class='Function'>+</span><span class='Modifier'>Ë</span><span class='Paren'>((</span><span class='Function'>â‰ </span><span class='Value'>ğ•©</span><span class='Paren'>)</span><span class='Function'>Â¬</span><span class='Value'>k</span><span class='Paren'>)</span><span class='Function'>â†•</span><span class='Value'>ğ•©</span></code>, but this is also not great because it copies when you could be taking slices. There's still a lot to dislike about it but APL's windowed reduction might be the winner for not-2-wise cases (just, not sharing a glyph with normal reduction). I often think of performance as pointing the way to better design, and I believe it did here but I was insufficiently informed: what I had seen was a bunch of hacks for various cases in Dyalog, and what I didn't know about was the van Herk/Gil-Werman <a href="https://github.com/mlochbaum/Singeli/blob/master/doc/minfilter.md">method</a> which beautifully handles associative functions on any window size in linear time using scans. Roughly <code><span class='Value'>k</span><span class='Function'>Ã—â‰ </span><span class='Value'>ğ•©</span></code> function calls for not-provably-associative operands is still not <em>good</em>, but seems more palatable now.</p>
<h3 id="selection"><a class="header" href="#selection">Selection</a></h3>
<p><a href="../doc/select.html">Select</a> (<code><span class='Function'>âŠ</span></code>) is all good, about the best you could hope for as a functional form of APL bracket indexing (it doesn't cover omitted indices except at the end, but the Rank modifier works for initial ones, and internal ones are pretty rare). It wouldn't quite have worked in APL floating array model, because selecting a cell with <code><span class='Paren'>(</span><span class='Function'>&lt;</span><span class='Modifier'>Â¨</span><span class='Value'>c</span><span class='Paren'>)</span><span class='Function'>âŠ</span><span class='Value'>ğ•©</span></code> would be indistinguishable from <code><span class='Value'>c</span><span class='Function'>âŠ</span><span class='Value'>ğ•©</span></code>. There's still an ambiguity with <code><span class='Bracket'>âŸ¨âŸ©</span><span class='Function'>âŠ</span><span class='Value'>ğ•©</span></code>, which could mean <code><span class='Value'>ğ•©</span></code> and not <code><span class='Number'>0</span><span class='Function'>â†‘</span><span class='Value'>ğ•©</span></code>, but it's a non-issue in practice.</p>
<p><a href="../doc/pick.html">Pick</a> (<code><span class='Function'>âŠ‘</span></code>)â€¦ what a mess. It works well for selecting a single element, but the nested format for multiple elements is never what you want. I'm fairly convinced now that a better structure would be to always have one element of <code><span class='Value'>ğ•¨</span></code> corresponding to each axis of <code><span class='Value'>ğ•©</span></code>, but allow these elements to be arrays or more deeply nested with a shared structure. Something like <code><span class='Paren'>(</span><span class='Function'>+</span><span class='Modifier'>Â´</span><span class='Value'>ğ•¨</span><span class='Function'>Ã—</span><span class='Paren'>(</span><span class='Number'>1</span><span class='Function'>Â»Ã—</span><span class='Modifier'>`</span><span class='Paren'>)</span><span class='Modifier2'>âŒ¾</span><span class='Function'>âŒ½â‰¢</span><span class='Value'>ğ•©</span><span class='Paren'>)</span><span class='Function'>âŠâ¥Š</span><span class='Value'>ğ•©</span></code>. There's even an extension to allow a shorter <code><span class='Value'>ğ•¨</span></code> for selecting cells of <code><span class='Value'>ğ•©</span></code>, if each element of <code><span class='Value'>ğ•¨</span></code> is an array of numbers, as selecting 0-cells in this way gives the same result as picking elements.</p>
<p>I'm not terribly fond of First (<code><span class='Function'>âŠ‘</span></code>) and First Cell (<code><span class='Function'>âŠ</span></code>), and often prefer <code><span class='Function'>âŠ£</span><span class='Modifier'>Â´</span></code> and <code><span class='Function'>âŠ£</span><span class='Modifier'>Ë</span></code>, pronounced &quot;leftmost&quot;. These let you pass in a default result as <code><span class='Value'>ğ•¨</span></code>, and immediately suggest the &quot;rightmost&quot; functions <code><span class='Function'>âŠ¢</span><span class='Modifier'>Â´</span></code> and <code><span class='Function'>âŠ¢</span><span class='Modifier'>Ë</span></code> (but don't try <code><span class='Value'>ğ•¨</span></code> with these, they will return it in all cases).</p>
<h3 id="indices-and-grouping"><a class="header" href="#indices-and-grouping">Indices and grouping</a></h3>
<p><a href="../doc/replicate.html#indices">Indices</a> (<code><span class='Function'>/</span></code>) is great of course (how did it take until the 2010s for anyone to add this to APL?), and the pairing with Replicate is very natural. Not having a multi-dimensional form can be annoying in various domains, but as it's not compatible with the 1-dimensional form I still wouldn't want to jam them together.</p>
<p><a href="../doc/replicate.html#inverse">The inverse</a> <code><span class='Function'>/</span><span class='Modifier'>â¼</span></code> should absolutely be supported if inverses are defined, and extending to unsorted arguments has also been entirely positive for us. I demand credit for the heroic struggle of getting this into J, after <a href="https://www.jsoftware.com/pipermail/programming/2010-September/020289.html">nearly 15 years</a> of advocacy: I unilaterally implemented it in Dyalog, added it to BQN influencing other languages to do so too, and finally was able to point out the long list of supporting languages and convince Henry to do it in 2024.</p>
<p>Similarly, I think at least the rank-1 form of <a href="../doc/group.html">Group</a> (<code><span class='Function'>âŠ”</span></code>) would be worth including in most array languages. APL's Key and K's group are poor substitutes because they leave out empty groups and can have ordering issues (although some approaches to dicts with fill values might fix this satisfactorily in K's case).</p>
<p>Both Indices inverse and Group have a <a href="problems.html#group-doesnt-include-trailing-empty-groups">nasty gotcha</a> where the result length will be too short if indices at the end of the range aren't present, making various programs subtly wrong if the length isn't specified. In the particular case that the indices come from a search <code><span class='Value'>u</span><span class='Function'>âŠ</span><span class='Value'>keys</span></code> for some &quot;universe&quot; of possible values <code><span class='Value'>u</span></code>, the length should be <code><span class='Function'>â‰ </span><span class='Value'>u</span></code>, and a function that takes both the universe and keys would of course know this. In Singeli I defined a single search/group builtin <code><span class='Value'>findmatches</span></code> that gives a nested result containing every matching index for each searched value; if elements of <code><span class='Value'>u</span></code> are unique then this is also the same as <code><span class='Paren'>(</span><span class='Function'>â‰ </span><span class='Value'>u</span><span class='Paren'>)</span> <span class='Function'>â†‘</span> <span class='Function'>âŠ”</span> <span class='Value'>u</span><span class='Function'>âŠ</span><span class='Value'>keys</span></code>. It's cool in terms of enabling a lot of functionality with very little implementation work, but using it directly is often pretty clunky so you wouldn't want to get rid of the simpler primitives for it.</p>
<h3 id="ordering"><a class="header" href="#ordering">Ordering</a></h3>
<p><a href="../doc/order.html#sort">Sorting</a> functions <code><span class='Function'>âˆ§âˆ¨</span></code> are good and the glyphs aligning with <code><span class='Function'>â‹â’</span></code> is intuitive. Maybe you could ask for sort-by functions but <code><span class='Function'>â‹</span><span class='Modifier2'>âŠ¸</span><span class='Function'>âŠ</span></code> is good enough for me, and makes the order of arguments clear; J's <code><span class='Function'>/</span><span class='Head'>:</span></code> is backwards isn't it?</p>
<p>Equally happy with <a href="../doc/order.html#bins">Bins Up</a> <code><span class='Function'>â‹</span></code> and Bins Down <code><span class='Function'>â’</span></code>. Bins Down isn't used a ton, but one nice feature is that it allows <code><span class='Function'>â‰ </span><span class='Modifier2'>âˆ˜</span><span class='Function'>âŠ£-âŒ½</span><span class='Modifier2'>âŠ¸</span><span class='Function'>â’</span></code> for <code><span class='Function'>â‹</span></code> with exclusive comparisons (and I don't view the pair <code><span class='Function'>â‹â’</span></code> as taking up significantly more resources than a single Bins Up function would; if you understand one then you understand the other).</p>
<h3 id="searching"><a class="header" href="#searching">Searching</a></h3>
<p><a href="../doc/search.html#index-of">Index Of</a> (<code><span class='Function'>âŠ</span></code>), <a href="../doc/search.html#member-of">Member Of</a> (<code><span class='Function'>âˆŠ</span></code>), <a href="../doc/selfcmp.html#mark-firsts">Mark Firsts</a> (<code><span class='Function'>âˆŠ</span></code>), and <a href="../doc/selfcmp.html#deduplicate">Deduplicate</a> (<code><span class='Function'>â·</span></code>), and for that matter <a href="../doc/match.html">Match</a> (<code><span class='Function'>â‰¡</span></code>) and Not Match (<code><span class='Function'>â‰¢</span></code>) are the same as APL with the widely-recognized issue in high-rank Member Of cleared up. None of the search glyphs are especially good. No regrets about dropping the set functions Union, Intersection, Without, because the details are hard enough to remember that using <code><span class='Function'>âˆŠ</span></code> is just less work. Well, I do write out Without often enough that it doesn't seem crazy as a primitive, just not compelling.</p>
<p><a href="../doc/selfcmp.html#classify">Classify</a> (<code><span class='Function'>âŠ</span></code>) is nice! I like how if you have multiple self-search things to do on a list with complicated elements, you can call it once and then use the result like the argument but without the hashing overhead. It also turns Group into <a href="https://aplwiki.com/wiki/Key">Key</a>, which is important if you don't have that primitive.</p>
<p><a href="../doc/selfcmp.html#occurrence-count">Occurrence Count</a> (<code><span class='Function'>âŠ’</span></code>) is all right, it's useful somewhat often and is tricky to implement otherwise. But the dyadic <a href="../doc/search.html#progressive-index-of">Progressive Index Of</a> is rubbish, hardly ever used and not hard to write in terms of Occurrence Count. Sure, a dedicated implementation's faster, but most uses don't need the performance, and it's not that easy to do, with challenges that differ from other search functions. Sorry to waste everyone's time.</p>
<p>The idea with the shorter result of <a href="../doc/find.html">Find</a> (<code><span class='Function'>â·</span></code>) is that it exposes the symmetry of the problem under reversal, so that <code><span class='Paren'>(</span><span class='Function'>â‰ </span><span class='Value'>ğ•©</span><span class='Paren'>)</span><span class='Function'>â†‘</span><span class='Value'>ğ•¨</span><span class='Function'>â·</span><span class='Value'>ğ•©</span></code> marks the start of each match and <code><span class='Paren'>(</span><span class='Function'>-â‰ </span><span class='Value'>ğ•©</span><span class='Paren'>)</span><span class='Function'>â†‘</span><span class='Value'>ğ•¨</span><span class='Function'>â·</span><span class='Value'>ğ•©</span></code> marks the end. Mostly people think in terms of the start and just find this confusing. Also we ended up having to break the strict shape arithmetic to support short <code><span class='Value'>ğ•©</span></code>. I don't really like Find generally, it feels more like it belongs to a text processing toolkit than array programming. Also the high-rank case is basically never used and no one has a good implementation. Probably it's the only reasonable extension, but you could also just not define it.</p>
<h3 id="iteration"><a class="header" href="#iteration">Iteration</a></h3>
<p>Right-to-left fold, the big mistake you've been waiting for. With decent enough mathematical arguments for it, I didn't feel comfortable breaking with APL. Instead I should have noted that <a href="math.html">BQN's not mathematics</a> and that K was just fine going left to right. In addition to being better for lots of general-purpose programming because you see the elements in index order, it would make the placement of the initial value <code><span class='Value'>ğ•¨</span></code> on the left much more intuitive.</p>
<p>There's no denying that the split of list-wise <a href="../doc/fold.html">Fold</a> (<code><span class='Modifier'>Â´</span></code>) and cell-wise <a href="../doc/fold.html">Insert</a> (<code><span class='Modifier'>Ë</span></code>), but column-wise <a href="../doc/scan.html">Scan</a> (<code><span class='Modifier'>`</span></code>), is super weird: scan corresponds to <code><span class='Modifier'>Â¨Ë</span></code> and not either fold directly. But having the right modifiers <code><span class='Modifier'>Â´</span></code> and <code><span class='Modifier'>`</span></code> for lists is really important, and then needing <code><span class='Modifier'>Â¨Ë</span></code> for APL2-style reduction is less bad than <code><span class='Function'>F</span><span class='Modifier'>Â´</span><span class='Function'>&lt;</span><span class='Modifier'>Ë˜</span></code> for Insert. The high-rank scan isn't quite as good as a dedicated one for lists because you have to enclose <code><span class='Value'>ğ•¨</span></code>, but would you really add a second scan modifier for that?</p>
<p>At present, <code><span class='Modifier'>`</span></code> probably beats <code><span class='Value'>\</span></code> as the most troublesome character a programming language can have, because all sorts of markdown-based stuff uses it for code and there's not even a consistent way to escape it. Strongly recommend avoiding both of these.</p>
<p><a href="../doc/map.html">Each</a> (<code><span class='Modifier'>Â¨</span></code>) and <a href="../doc/map.html">Table</a> (<code><span class='Modifier'>âŒœ</span></code>) are good, throwing out APL's weird <code><span class='Modifier2'>âˆ˜</span><span class='Value'>.</span></code> is a pretty easy decision. Haven't learned anything about <a href="../doc/rank.html#rank">Rank</a> (<code><span class='Modifier2'>â‰</span></code>) that I didn't know when I started (I even complained about it in the documentation), it's clunky but sometimes you need it. <a href="../doc/rank.html">Cells</a> (<code><span class='Modifier'>Ë˜</span></code>) has worked out great as the most common special case however.</p>
<p>I'm down on <a href="../doc/depth.html#the-depth-modifier">Depth</a> (<code><span class='Modifier2'>âš‡</span></code>), because it's rarely useful, the details are hard to understand, and the programmer can implement it more explicitly and flexibly with recursion. Should have given more thought to how I never liked J's <code><span class='Function'>L</span><span class='Head'>:</span></code> either. The cases each-left <code><span class='Modifier2'>âš‡</span><span class='Number'>Â¯1</span><span class='Ligature'>â€¿</span><span class='Number'>âˆ</span></code>, each-right <code><span class='Modifier2'>âš‡</span><span class='Number'>âˆ</span><span class='Ligature'>â€¿</span><span class='Number'>Â¯1</span></code>, and pervasion <code><span class='Modifier2'>âš‡</span><span class='Number'>0</span></code> all seem like fine choices for more specialized primitives, they'd just take up a lot of characters.</p>
<p>BQN's <a href="../doc/repeat.html">Repeat</a> (<code><span class='Modifier2'>âŸ</span></code>) is J's with some obvious adjustments. No problems here; handling an array for <code><span class='Value'>ğ•˜</span></code> is a bit complicated and not crucial but is nice to have. A different language might add repeat-until type primitives but I still think it's inappropriate to try to special-case them into Repeat. We've added <code><span class='Modifier2'>â€¢_while_</span></code> which covers the most important cases but becomes ugly if you want to save intermediate results.</p>
<h3 id="combinators"><a class="header" href="#combinators">Combinators</a></h3>
<p>The primitives <code><span class='Function'>âŠ£âŠ¢</span><span class='Modifier'>Ë™Ëœ</span><span class='Modifier2'>âˆ˜â—‹âŠ¸âŸœâŠ˜â—¶</span></code> feel like an appropriate set for a language that wants to make <a href="../doc/tacit.html">tacit</a> programming nice but isn't that focused on it. Nothing to add beyond <a href="https://chat.stackexchange.com/transcript/52405?m=54577483#54577483">quoting myself</a> a month into development: &quot;<code><span class='Modifier2'>âŠ¸</span></code>/<code><span class='Modifier2'>âŸœ</span></code> are extremely magical and make tacit programming like 20% easier.&quot;</p>
<h3 id="undo-under"><a class="header" href="#undo-under">Undo, Under</a></h3>
<p>I hardly know what to say about <a href="../doc/under.html">structural Under</a> (<code><span class='Modifier2'>âŒ¾</span></code>). Most people find it intuitive, except the things they intuit are often not the same! The basic flat array case is very easy to implement using indices <code><span class='Function'>â†•</span><span class='Modifier2'>âˆ˜</span><span class='Function'>â‰ </span><span class='Modifier2'>âŒ¾</span><span class='Function'>â¥Š</span><span class='Value'>ğ•©</span></code>, but even then ruling out non-structural functions and checking for duplicates takes some work, and beyond it, nested cases run into all sorts of little implementation issues. Similar functionality can be provided in a way that's more like old imperative APL than new functional stuff. I highly recommend <a href="https://doi.org/10.1145/75144.75153">Understanding selective assignment</a>, where Jim Brown gives a more unified and consistent approach to APL2's assignment, and so-called &quot;mutable value semantics&quot; works by passing mutable views into variables with exclusive ownership.</p>
<p><a href="../doc/undo.html">Undo</a> (<code><span class='Modifier'>â¼</span></code>) is complicated to support and could be left out, but the benefits are significant. Using it for computational Under is worth questioning. One point in favor is that some cases of Under that look structural like <code><span class='Function'>ğ”½</span><span class='Modifier2'>âŒ¾</span><span class='Function'>â‰</span></code> or <code><span class='Function'>ğ”½</span><span class='Modifier2'>âŒ¾</span><span class='Function'>âŒ½</span></code> sometimes aren't because <code><span class='Function'>ğ”½</span></code> changes the shape and instead are relying on the inverse of <code><span class='Function'>ğ”¾</span></code>.</p>
<h3 id="errors"><a class="header" href="#errors">Errors</a></h3>
<p>Making <a href="../doc/assert.html">Assert</a> (<code><span class='Function'>!</span></code>) a primitive feels very right in retrospect: of course it's meaningless from a mathematical view of programming but it's a fundamental part of writing code. <a href="../doc/assert.html#catch">Catch</a> (<code><span class='Modifier2'>âŠ</span></code>) could safely be a system modifier, as you often want to use it with <code><span class='Function'>â€¢CurrentError</span></code> anyway, but I don't have any issue with it as a primitive either.</p>
<h2 id="grammar"><a class="header" href="#grammar">Grammar</a></h2>
<p>A <a href="../doc/context.html">context-free grammar</a> and <a href="../doc/functional.html">first-class functions</a> are important features, but BQN's system with case-insensitive variables is not the only way to bring these to APL. TinyAPL's explicit role-conversion syntax is more intuitive and makes converting un-named values as easy as named ones, at the cost of adding that extra syntax.</p>
<p>Modifiers are a major source of unjustified complexity. I'm entirely happy with leaving out J's 2-modifier partial application and 1-modifier composition, and would want to go further. One way is to cut out named modifiers entirely, and have a primitive 2-modifier that can apply a monadic function like <code><span class='Value'>arg&amp;</span><span class='Function'>Fn</span></code>. Named 2-modifiers are so hard to read in an expression context that I might actually prefer the structure of <code><span class='Bracket'>âŸ¨</span><span class='Function'>+</span><span class='Separator'>,</span><span class='Function'>Ã—</span><span class='Bracket'>âŸ©</span><span class='Value'>&amp;</span><span class='Function'>Oper</span></code> over <code><span class='Function'>+</span> <span class='Modifier2'>_oper_</span> <span class='Function'>Ã—</span></code>. Of course I still like all the <code><span class='Modifier2'>âŠ¸âŸœâ—‹</span></code> primitives and wouldn't want to get rid of them like K does. But like K's adverbs, a primitive modifier might have an underlying function value; perhaps <code><span class='Paren'>(</span><span class='Modifier2'>âŠ¸</span><span class='Paren'>)</span></code> would even convert to a function role.</p>
<h3 id="array-notation"><a class="header" href="#array-notation">Array notation</a></h3>
<p>Always consider destructuring when thinking about <a href="../doc/arrayrepr.html#array-literals">array notation</a>, since primitives are fine for forming arrays but only syntax is good for destructuring.</p>
<p>I'm still all for explicit stranding <code><span class='Ligature'>â€¿</span></code>; a less-obvious benefit over implicit is that it works on functions. It doesn't fully substitute for <code><span class='Bracket'>âŸ¨âŸ©</span></code> because, besides looking ugly with large structures, it can't form 1-element lists (<code><span class='Function'>â‹ˆ</span></code> can do that in code, but not in destructuring).</p>
<p>I held off on adding high-rank notation <code><span class='Bracket'>[]</span></code> for a while so I know what a difference it makes, andâ€¦ it's been kind of disappointing. Having it for destructuring headers is good but doesn't come up often. New programmers are always expecting <code><span class='Bracket'>[]</span></code> to be the list notation, and it'd let you copy-paste JSON too, so doing that and ditching <code><span class='Bracket'>âŸ¨âŸ©</span></code> would be tempting if I started over. Also note that the high-rank notation doesn't let you form rank-0 or many empty arrays, so it's not &quot;complete&quot; in any sense.</p>
<h3 id="blocks"><a class="header" href="#blocks">Blocks</a></h3>
<p><a href="../doc/block.html">Blocks</a> are one component of BQN that had major additions over time, so earlier features were sometimes designed without knowledge of later ones. One bit of ugliness is that the header <code><span class='Value'>name</span><span class='Head'>:</span></code> is for an immediate block although it could be a monadic function with implied <code><span class='Function'>ğ•Š</span></code>; the main reason for this is at the time I wanted <code><span class='Value'>name</span><span class='Gets'>â†’</span></code> for an early return, and I've removed that from the spec and all but it still kind of feels like a feature we want so it's all very confusing.</p>
<p><a href="../doc/block.html#block-headers">Headers</a> feel way more complex than they need to be, and a huge chunk of that is all the different modifier combinations. Again just dropping user-defined modifiers is possibleâ€”this also means no <code><span class='Function'>ğ”½ğ”¾</span><span class='Value'>ğ•—ğ•˜ğ•£</span></code> in the character set. APL has no immediates, although I'd say that exacerbates the issue that choosing modifiers over first-class functions for the nicer syntax leaves you with worse functionality. An approach without this issue would be to support immediate modifiers only, requiring non-immediate ones to be nested.</p>
<p>Determining the syntax of a block from special names <code><span class='Value'>ğ•©</span></code>, <code><span class='Function'>ğ”½</span></code>, etc. in the body is something I'd want to get away from if at all possible. This comes from dfns versus dops in APL, but BQN's use for functions versus immediate blocks really highlights the issue and is a common source of confusion and errors. Making any block with no header a function is probably the practical solution, even though I hate giving functions the simpler syntax when immediate blocks are more fundamental. The thing where two headerless (and predicate-less!) function bodies define the monadic and dyadic cases is useless; this should be spelled out with at least an <code><span class='Function'>ğ•Š</span><span class='Value'>ğ•©</span><span class='Head'>:</span></code> header on the first one.</p>
<p>The convention that <code><span class='Value'>ğ•¨</span></code> means <code><span class='Nothing'>Â·</span></code> in a monadic block function call is quirky but has held up okay. It's definitely easier to write ambivalent code this way than using tacit combinators.</p>
<p>Namespaces are just about perfect at being namespaces (other than missing convenience features we should add eventually). Sometimes people would like to have this level of syntax support for dictionaries/maps insteadâ€¦ I'm not into it. The purpose of export syntax <code><span class='Value'>a</span><span class='Ligature'>â€¿</span><span class='Value'>b</span><span class='Ligature'>â€¿</span><span class='Value'>c</span><span class='Gets'>â‡</span></code> is maybe kind of muddled: if you have that at the top of a file and then <code><span class='Value'>a</span><span class='Gets'>â†</span><span class='Value'>â€¦</span></code> later on, there's no hint it was exported, so requiring <code><span class='Value'>a</span><span class='Gets'>â‡</span><span class='Value'>â€¦</span></code> could be better.</p>
<h2 id="overall-thoughts"><a class="header" href="#overall-thoughts">Overall thoughts</a></h2>
<p>Clear mistakes: backwards folds <code><span class='Modifier'>Â´</span></code> and <code><span class='Modifier'>Ë</span></code>; APL-style instead of J-style (first-axis) Reshape <code><span class='Function'>â¥Š</span></code>; Progressive Index of <code><span class='Function'>âŠ’</span></code>.</p>
<p>Major successes: character arithmetic; shift functions <code><span class='Function'>Â»Â«</span></code>; structural Under <code><span class='Modifier2'>âŒ¾</span></code>; hooks <code><span class='Modifier2'>âŠ¸âŸœ</span></code>.</p>
<p>Other primitive candidates: flip <code><span class='Function'>&lt;</span><span class='Modifier'>Ë˜</span><span class='Function'>â‰&gt;</span></code>; restructured Pick (<a href="#selection">see above</a>); <a href="https://aplwiki.com/wiki/Case">case</a> <code><span class='Brace'>{</span><span class='Value'>ğ•¨</span><span class='Function'>âŠ</span><span class='Modifier2'>â‰</span><span class='Number'>0</span><span class='Ligature'>â€¿</span><span class='Number'>1</span><span class='Function'>â‰&gt;</span><span class='Value'>ğ•©</span><span class='Brace'>}</span></code>; windowed reduction.</p>
<p>Stepping back a bit, for the do-it-yourself programmer I say there is a lot of value in the right set of <a href="primitive.html">primitives</a> on immutable arrays. Most of it's in the boring obvious onesâ€”think intersection, not union, of array languages. And a simple symbol can be the best expression of a simple function, but we spend so much effort to adapt our high-minded multi-dimensional theory to the human factors of 1-dimensional text! Improving array programming is a noble goal but I'm increasingly interested in projects like <a href="https://beyondloom.com/decker/lil.html">Lil</a> that treat it as a means and not an end. So I hope BQN has made some progress in showing that arrays can sit comfortably even with the vulgar art of object-oriented programming.</p>
<p>Wait, what's that? You want to hear what this review says aboutâ€¦ <em>me</em>? Oh, I have the skills of every other designer put together, and all of the humility that Dijkstra doesn't! Thanks for asking!</p>
