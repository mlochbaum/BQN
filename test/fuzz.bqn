# Tester that checks primitives on random arguments

opts â† {
help â† 1â†“"
Fuzz testing. Options:
  -h, --help: Print this message and exit
  -r: Random seed, u to use â€¢UnixTime then print (1)
  -b: Maximum bound (1e3)
  -z: Don't generate large zero-product shapes (0)
  -v: Show description of each test before it runs (0)
  -o: Show full function output when it fails a test (0)
  -f: Failures allowed before stopping (1)
  -n: Number of iterations (100)
  -t: Element type (0 3 4 5 6)
  -p: Primitives: both | mon%dy | mon%dy%both
  -m: Modifier operands (dyadic arithmetic)

Any number of types or bounds can be given; all combinations are tested."

  o â† "-h"â€¿"--help"â€¿"-b"â€¿"-z"â€¿"-v"â€¿"-o"â€¿"-f"â€¿"-n"â€¿"-t"â€¿"-p"â€¿"-m"â€¿"-r"
  oo â† (â‰ o) = oi â† o âŠ aâ†â€¢args
  â€¢Exitâˆ˜â€¢Outâˆ˜helpâŸ(âˆ¨Â´2âŠ¸>) oi

  opts â† 2â†“oâ‰ âŠ¸â†‘ a âŠ”Ëœ (Â¬-ËœâŠ¢Ã— oiâŠËœ â†•âˆ˜â‰ âŒˆ`âˆ˜Ã—Â¬)oo
  boundsâ€¿zeroboundâ€¿verboseâ€¿showresâ€¿numfailâ€¿numâ€¿typesâ€¿primsâ€¿modopâ€¿seed â‡ â€¢BQNÂ¨Â¨âŒ¾(Â¯3âŠ¸â†“) opts
  _default_ â† { (âˆ¾"Only one "â€¿ğ•˜â€¿" can be given") ! 1â‰¥â‰ ğ•¨ â‹„ ğ•©ğ”½âˆ˜âŠ£Â´ğ•¨ }
  num âŠ¢_default_"iteration number"â†© 100
  types â†© 0â€¿3â€¿4â€¿5â€¿6âŸ(0=â‰ ) types
  bounds â†© âŸ¨1e3âŸ©âŸ(0=â‰ ) bounds
  zeroboundâ€¿verboseâ€¿showresâ€¿numfail âŠ£Â´Â¨Ëœâ†© 0â€¿0â€¿0â€¿1
  seed "u"âŠ¸â‰¡â—¶âŸ¨â€¢BQN,â€¢Show(2â‹†31)|âŒŠâˆ˜â€¢UnixTimeâŸ©_default_"random seed"â†© 1

  modop âˆ¾â†©
  prims ((âŠ¢-ËœÂ¬Ã—+`+2Ã—Â·Â¬âˆ¨Â´)'%'âŠ¸=)Â¨âŠ¸(âŠ”â—‹âˆ¾)â†©
  "At most three %-separated primitive groups allowed" ! 3â‰¥â‰ prims
  prims â†© 2 (â†‘((Â¬âˆ˜âˆŠ/âŠ£)âˆ¾âŠ¢)Â¨âŠ) 3 â†‘ prims

  Failed â‡ {ğ•Š: â€¢Exitâˆ˜1âŸ(0âŠ¸=) numfail -â†© 1}
}

Squeezeâ€¿ListVariationsâ€¿Variationâ€¿ClearRefs â† â€¢internal

âŸ¨Range,SubsetâŸ© â† â€¢MakeRand opts.seed
Rand â† {ğ•¨ Range 1âŒˆğ•©}
_randChoose â† { Randâˆ˜(â‰ ğ•—)â—¶ğ•— }
_randUnbounded â† { ğ•ŠâŠ¸+âŸ(1=-)âŸœRand ğ•— }
RandRank â† 4 _randUnbounded

# Prime factorization
âŸ¨FactorâŸ© â† {
  p â† (Â¬âˆ˜âˆŠ/âŠ£)âŸœ(â¥ŠÃ—âŒœËœ)2â†“â†•mâ†60
  Pr â† {m<ğ•©}â—¶{ğ•©â†‘p}â€¿{ mâ†©(Ã—Ëœm)âŒŠ2Ã—ğ•© â‹„ pâˆ¾â†©1â†“/1(mâ¥Š0<â†•)âŠ¸âˆ§Â´p â‹„ Pr ğ•© }
  Factor â‡ {
    !(1=â€¢Typeğ•©)âˆ§(ğ•©=âŒŠğ•©)âˆ§0<ğ•©
    âˆ§ ğ•© {(0<â‰ âˆ˜âŠ¢)â—¶âŸ¨â¥ŠâŠ£,âŠ¢âˆ¾ğ•ŠâŸ©âŸ(>âŸœ1)ËœâŸœ(ğ•¨Ã·Ã—Â´)ğ•©/Ëœ0=ğ•©|ğ•¨} Pr âŒˆâˆšğ•©
  }
}

Sigmoid â† (40â‰¤|)â—¶âŸ¨1(-Ã·+)Ëœâ‹†,Ã—âŸ©

# ğ•© is maximum bound plus 1 for both functions
âŸ¨RandBound,RandShapeâŸ© â† {
  RandBound â‡ âŸ¨
    Rand                                         # Uniform
    Rand 128âŠ¸âŒŠ                                   # Small
    (0âŒˆ-âŸœ1) âŒŠ Randâˆ˜(1âŒˆâŒˆ)âŒ¾((2â‹†3+âŠ¢)â¼) + Â¯7+Randâˆ˜15 # Near power of two
  âŸ©_randChoose

  z â† opts.zerobound
  Squash â† {                       # Multiply by constant so product is â‰¤ğ•¨
    0=ğ•¨ ? 0Ã—ğ•© ;                    # Avoid division by 0
    aâ†(âˆ§`ğ•¨>Ã—`Ã·âŠ¢â‹†1+â†•âˆ˜â‰ )âŠ¸/âˆ˜âˆ¨âŸz ğ•©     # Numbers that don't need to go below 1, if z
    âŒŠ ğ•© Ã— (â‰ a) âˆš SigmoidâŠ¸Ã·1âŒˆğ•¨Ã·ËœÃ—Â´a
  }
  Augment â† {
    d â† 1+âŒŠğ•¨Ã·1âŒˆÃ—Â´zâŒˆğ•©       # Maximum bound that can be added, plus 1
    C â† 10âŠ¸+ RandâŠ¸< 1.2âŠ¸âˆš  # Decide whether to add
    d (ğ•¨ ğ•Š âŸ¨âˆ¾,âˆ¾ËœâŸ©_randChooseâŸœRandBoundËœ)âŸ(CâŠ£) ğ•©
  }
  Combine â† âŸ¨
    Randâˆ˜â‰ âŠ¸âŒ½ (2+Randâˆ˜â‰ )âŠ¸{Ã—Â´Â¨ğ•¨â†‘(ğ•¨|â†•âˆ˜â‰ )âŠ¸âŠ”ğ•©}âˆ˜âŠ¢ # Random number of groups
    Ã—Â´Â¨ (âŠÂ·RandÂ¨â¥ŠËœâˆ˜â‰ )âŠ¸âŠ”âˆ˜âŠ¢                   # Distribute randomly
  âŸ©_randChoose
  RandShape â‡ âŠ¢ Augment âŸ¨
    âŠ¢ Squash Â· RandÂ¨ (RandRankâŒˆâˆš<Rand)âŠ¸â¥Š
    âŠ¢ CombineâŸœFactor 1âŒˆRandBound
  âŸ©_randChoose
}

RandShape1 â† 1âŠ¸âˆ¾âŸ(0=â‰ ) RandShape

# A generator is an object containing a randomly-generated array,
# along with the seed and procedure used to generate it.
gen â† {
  getGen â† â€¢Import "fuzzgen.bqn"
  Generate â† { ğ•¨ğ•Šp:
    s â† ğ•¨ RangeâŠ˜âŠ£ 2â‹†31  # Random seed
    AsFn â† (GetGen â€¢MakeRand s)âŠ¸â€¢ns.GetâŸ=
    d â† Squeeze {=â—¶âŠ‘â€¿(AsFnâˆ˜âŠ‘(âˆŠâŸœâˆ¾â€¿âŠ¢âŒ¾<âˆ˜âŠ£)â—¶âŸ¨{(2=â‰ ğ•©)â—¶âŸ¨ğ•âŠ‘,ğ•Â´âŸ©ğ•©}âŸœ(ğ•ŠÂ¨âŒ¾âŒ½),{ğ•ğ•©}âŸœ(ğ•ŠÂ¨)âŸ©1âŠ¸â†“)ğ•©} p
    {1â‰¥â‰ â¥Šd?âˆ§Â´â¥Š0â‰ â€¢TypeÂ¨d? d ; seedâ‡s, procâ‡p, dataâ‡d}
  }
  # Convert generator to array
  Arr â‡ {ğ•©.data}âŸ(6=â€¢Type)
  # Apply non-random function to generated ğ•©
  _apply â‡ {
    6â‰ â€¢Typeğ•© ? ğ•¨ğ”½ğ•© ;
    âŸ¨seedâŸ©â‡ğ•© â‹„ procâ‡ğ•¨ğ”½_ağ•©.proc â‹„ dataâ‡ğ•¨ğ”½ğ•©.data
  }
  # Formatting for error output
  Format â‡ {
    6â‰ â€¢Typeğ•© ? â€¢Reprğ•© ;
    TrimPar â† (Â¯1â†“1âŠ¸â†“)âŸ('('=âŠ‘)
    TxtApply â† {âˆŠâŸœ"âˆ¾"â€¿"âŠ¢"âŒ¾<ğ•¨?((ğ•¨â‰¡"âˆ¾")/"âˆ¾ ")âˆ¾1â†“âˆ¾"â€¿"âŠ¸âˆ¾Â¨ğ•©;âˆ¾âŸœ" "âŠ¸âˆ¾Â´âŒ½âŒ¾(2âŠ¸â†‘)âŸ(3=â‰ )âŸ¨ğ•¨âŸ©âˆ¾TrimParâŒ¾(Â¯1âŠ¸âŠ‘)ğ•©}
    FmtTemp â† {=â—¶âŸ¨â€¢ReprâŠ‘,"("âˆ¾")"âˆ¾Ëœ=â—¶âŸ¨â€¢Repr,"g."âŠ¸âˆ¾âŸ©âˆ˜âŠ‘TxtApplyÂ·ğ•ŠÂ¨1âŠ¸â†“âŸ©ğ•©}
    âˆ¾âŸ¨"{gâ†", â€¢Repr ğ•©.seed, "â€¢Import""fuzzgen.bqn""â‹„"
      TrimPar FmtTemp ğ•©.proc
      "}"âŸ©
  }

  RN â† (0âŒˆ-âŸœ1) âŒŠ 1â€¿RandRankâ€¿RandBound _randChoose
  RandSplit â† âŒ½âŸ(Randâˆ˜2) (-â‹ˆâŠ¢)âŸœRN

  _a â† {âŸ¨ğ”½âŸ©âˆ¾â‹ˆ}                # Apply function symbolically
  _raâ† {(â‹ˆRandâˆ˜â‰ âŠ¸âŠ‘âˆ˜ğ•—)âˆ¾â‹ˆ}      # Same, choosing randomly from list
  _flat â† { <âˆ˜âŠ¢ â¥Š_a ğ”½âŸœ(Ã—Â´â¥Š) } # Generate list, then reshape

  _Rec_ â† {
    S â† {ğ•¨Rğ•©}
    R â† âŸ¨
      ğ”½                                  # Random
      âˆ§â€¿âˆ¨_ra ğ”½                           # Sort
      âŠ¢ âŸ¨â¥Š,"Stretch"âŸ©_ra SâŸœ(1âŒˆRN)        # Repeat
      "Shuffle"_aâŸ(Randâˆ˜2) âŸ¨âˆ¾âŸ© âˆ¾ <âŠ¸(ğ”¾â€¿âŠ¢_randChooseâŠ¸SÂ¨)âŸœRandSplit # Partition
    âŸ©{ 8âŠ¸â‰¤â—¶âŸ¨0,Randâˆ˜(â‰ ğ•—)âŸ©â—¶ğ•— }
    R _flat
  }

  # ğ•¨ is 2â‹†â¼bits in type; ğ•© is shape
  floats â† âŸ¨2â‹†Â¯1074,2â‹†Â¯1022,(2-2â‹†Â¯52)Ã—2â‹†1023âŸ©
  RandFloat â† âŸ¨
    (floatsâˆ¾2â‹†0â€¿8â€¿32â€¿100)_randChoose Ã—_a (2Ã·ËœRandâˆ˜3) -Ëœ_aâŸ(0â‰ âŠ£) "Unit"_a
    âŠ¢ "Sel"_a Â·<(Rand(âŠ£â‰¥âŒˆÂ´âŠ¸âŒŠ)3+Randâˆ˜+)Ëœâˆ˜â‰ âŠ¸/âˆ˜(âˆ¾âŸœ-0âˆ¾floatsâˆ¾âˆ)
  âŸ©_randChoose
  RandTyped â† =âŸœ6â—¶âŸ¨"Int"_a, RandFloatâŠ¢âŸ©
  Arith â‡ Generate RandTyped _Rec_ Rand

  ContractRange â† (âŸ¨â‹ˆâŸœ0,0â‹ˆ-âŸ©_randChooseÂ·RN-ËœÂ´)âŠ¸+
  RandInterval â† <âŠ¸("Interval"_a) _Rec_ ContractRange

  IndSub â† (0âŠ¸â‹ˆ âŠ£ Â·!0âŠ¸<)âŠ¸RandInterval
  Index â‡ Generateâˆ˜IndSub
  _multi â† {
    0â‰ â€¢Typeğ•© ? Generate ğ•¨ğ”½ğ•© ;
    (2âŒŠâ‰ )â—¶âŸ¨âŠ¢,GenerateÂ·â‹ˆ_aâŠ‘,GenerateâŸ¨âŠ¢âŸ©âˆ¾âŠ¢âŸ© ğ•¨ğ”½Â¨ğ•©
  }
  IndMulti â‡ âˆ§â—‹(0âŠ¸â‰ )â—¶âŸ¨<âŸ¨âŸ©, IndSubâŸœ(â¥Šâ€¿RandShape _randChoose)ËœâŸ©_multi
  Replic â‡ ("Diffs"_a (0â‹ˆ1+âŠ£) RandInterval â¥Šâˆ˜âŠ¢) _multi

  ch_end â† 17Ã—2â‹†16
  ChR â† 0â‹ˆch_endâŒŠ2â‹†2â‹†âŠ£
  Char â‡ Generate Â·"ToChar"_a ChRâŠ¸RandInterval

  Struct â‡ Generate =âŸœ6â—¶âŸ¨
    âŸ¨"Int"_a, "ToChar"_a <âˆ˜ChRâŠ¸("Interval"_a)âŸ©_randChoose
    "Unit"_aâŠ¢
  âŸ©_flat
}

_testConsistent_ â† {Matchâ†ğ”¾ â‹„ Fâ†ğ”½
  Arr â† 0=â€¢Type
  ListVar â† Arrâ—¶(5â¥Š@)â€¿ListVariations
  Var â† Arrâˆ˜âŠ¢â—¶âŠ¢â€¿Variation
  v â† <Ë˜â‰> (5âŒŠÂ´â‰ Â¨)âŠ¸(((0âˆ¾RandâŒ¾(-âŸœ1))âŸœâ‰ âŠâŠ¢)Â¨) ListVarÂ¨ aâ†gen.ArrÂ¨oâ†ğ•¨â‹ˆğ•©
  Describe â† {ğ•Š: â€¢Show f â‹„ â€¢Outâˆ˜gen.FormatÂ¨o}
  DescribeâŸopts.verbose @
  c â† (âˆ§Â´ âŠ MatchÂ¨ 1âŠ¸â†“) r â† (ğ•¨ (FâŠ‘âˆ˜âŠ¢)âŠ˜(FÂ´âŠ¢) VarÂ¨âŸœa)Â¨ v
  {c?@;                             # If results don't match:
    DescribeâŸ(Â¬opts.verbose) @      # Output function and arguments
    gv â† (â’â‰ Â¨)âŠ¸âŠ âŠ”âŠMatchâŒœËœr         # Variations grouped by result
    â€¢Show âŠË˜âŸ(Â¬opts.showres) >(âŠâŸœ(>v)â‹ˆâŠ‘âŠ‘rË™)Â¨ gv
    opts.Failed@
  }
  ClearRefs@
  c
}

FlatMatch â† â‰¡â—¶âŸ¨âˆ§Â´âˆ˜â¥Š=âˆ¨âˆ§â—‹(â‰ Ëœ),1âŸ©

_testMonArith â† {
  (ğ•¨ gen.Arith RandShape ğ•©)âŠ¸{ ğ• _testConsistent_ FlatMatch ğ•¨ }Â¨ ğ•—
}

RandDyShape â† {
  Prefix â† (âˆ¨`âŒ¾âŒ½ ğ•© â‰¥ Ã—`)âŠ¸/ (Rand 1+â‰ )âŠ¸â†‘
  (Rand 2) âŒ½ â‹ˆâŸœPrefix RandShape ğ•©
}
_testDyArith â† {fâ†ğ•—
  ch â† 0<+Â´â‰ Â¨ pmn â† (âˆŠâŸœfâ¥ŠÂ¨âŠ¢) +â€¿-â€¿Â¬
  {
    sh â† RandDyShape ğ•©
    Atom â† âŠ‘âŸ(Randâˆ˜2)âŸ(0==)âŸ(0=â€¢Type)
    _t â† { ğ• _testConsistent_ FlatMatchÂ´ ğ•— }
    (AtomÂ¨ ğ•¨âŠ¸gen.ArithÂ¨ sh)_tÂ¨ f
    {
      kâ†ğ•©
      rca â† AtomÂ¨âŸ¨gen.Char,gen.ArithâŸ©{kğ•ğ•©}Â¨sh
      Fit â† -âŸœ(@+1-Ëœ17Ã—2â‹†16)âŒˆ-âŸœ@âŒŠâŠ¢
      # Remove -âŸœ@ to test full-range Â¬ (extended from 1+-)
      _sâ†{ğ”½â—‹gen.Arr`}
      âŸ¨âŒ½âŸ(Rand 2)-âˆ˜FitâŸœ-_s,Fit _s,(-âŸœ@âŒŠ1+Fit)_sâŸ© { (ğ•rca)_t ğ•© }Â¨Â¨ pmn
      { (sh (k gen.Char âŠ£)âŒ¾(1âŠ¸âŠ‘) rca)_tÂ¨ ğ•© }âŸ(0<â‰ ) âˆ¾1â†“pmn
    }âŸ(châˆ§0âŠ¸<âˆ§â‰¤âŸœ5) ğ•¨
  }
}

NoIdent â† âŠ‘âˆŠâŸœâˆšâ€¿|â€¿â‰¤â€¿<  # Operands not allowed for empty fold
_testMonFold â† {
  l â† ğ•¨ gen.Arith 1 âŒˆ b â† 0Ã—RandBound ğ•©
  Cut â† 0âŠ¸â†‘âŸ(Â¬NoIdentâˆ˜âŠ£)âŸ(0=b)  # Avoid missing identity
  modop {mâ†ğ•© â‹„ ğ•¨_m _testConsistent_ FlatMatch ğ•¨ Cut l }âŒœ ğ•—
}
_testDyFold â† {
  iâ€¿l â† Â¯1 (âŠ‘âŸœgen.Arrâ‹ˆâ†“gen._apply) ğ•¨ gen.Arith 1 + RandBound ğ•©
  modop {mâ†ğ•© â‹„ i ğ•¨_m _testConsistent_ FlatMatch l }âŒœ ğ•—
}
_testMonScan â† {
  e â† 0=âŠ‘ s â† RandShape1 ğ•©
  l â† ğ•¨ gen.Arith (âˆ¨`âŒ¾âŒ½ ğ•© â‰¥ Â·Ã—`1âŒ¾âŠ‘)âŠ¸/âˆ˜(1âŒ¾âŠ‘)âŸe s
  Cut â† 0âŠ¸â†‘âŸ(Â¬{(NoIdentğ•¨)âˆ§ğ•©â‰¡{Ë}}Â´âˆ˜âŠ£)âŸe
  modop {mâ†ğ•© â‹„ ğ•¨_m _testConsistent_ FlatMatch ğ•¨â€¿m Cut l }âŒœ ğ•—
}
_testDyScan â† {
  iâ€¿l â† ğ•¨âŠ¸gen.ArithÂ¨ 1âŠ¸â†“âŠ¸â‹ˆ (âˆ§`ğ•©â‰¥Â·Ã—`1âŒ¾âŠ‘)âŠ¸/âŸ(0=âŠ‘) RandShape1 ğ•©
  modop {mâ†ğ•© â‹„ i ğ•¨_m _testConsistent_ FlatMatch l }âŒœ ğ•—
}

_testMonStruct â† { # â¥Šâ‰âŒ½â‰âŠ
  k â† 3|1+ âŒ½â€¿âŠ âŠ ğ•—
  sh â† k âŠ {ğ•ğ•¨}` (1+âŒˆÂ´k) â†‘ âŸ¨RandShape ğ•©, 1âŠ¸âˆ¾âŸ(0=â‰ ), 1âŠ¸âˆ¾âŸ(0=âŠ‘)âŸ©
  ((âŠsh) âŠ ğ•¨âŠ¸gen.StructÂ¨ â·sh) { ğ• _testConsistent_ â‰¡ ğ•¨ }Â¨ ğ•—
}

_testDyStruct â† { # â¥Šâ†‘â†“â†•âŒ½â‰ (no overtake)
  d â† ğ•¨ gen.Struct sh â† RandShape ğ•©
  l â† RandShape ğ•©
  K â† (Rand 1+â‰ )âŠ¸â†‘
  RR â† â‹ˆ âŸ¨âŠ‘âŠ¸+,âŠ¢Â´âŠ¸-âŸ©_randChoose RandBoundâˆ˜Â¬Ëœ
  RT â† (-RRÂ¨âŠ¢)K
  Atom â† âŠ‘âŸ(Randâˆ˜2)âŸ(1=â‰ )
  [p,r] â† â‰ [âŸ¨â¥Š,(0âˆ¾1âŠ¸â†“)âŸ(sh>â—‹(0=Ã—Â´)âŠ¢)âˆ˜lâŸ©, âŸ¨â†“,lâ€¿RT _randChooseâŸ©
             âŸ¨âŒ½,RT+ËœâŸ©, âŸ¨â†‘,RTâŸ©, âŸ¨â†•,0 RRÂ¨ 1+KâŸ©, âŸ¨â‰,(â‹âŠâŠ)RandËœâˆ˜â‰ âŸ©]
  (râŠËœpâŠğ•—) { (Atom ğ•sh) ğ• _testConsistent_ â‰¡ d }Â¨ ğ•—
}

_testDim â† { # â‰ =â‰¢
  (ğ•¨ gen.Struct RandShape ğ•©)âŠ¸{ ğ• _testConsistent_ â‰¡ ğ•¨ }Â¨ ğ•—
}

_testCombine â† { # â‰âˆ¾Â«Â»
  a â† ğ•¨ gen.Struct sh â† RandShape1 ğ•©
  bs â† (RandBound 1âŠ¸+)âŒ¾âŠ‘âŸ({â‰}â‰ ğ•—) sh
  swap â† (Rand 2)âŠ‘{ğ”½}â€¿Ëœ
  ((âŠbs) âŠ ğ•¨âŠ¸gen.StructÂ¨ â·bs) { a ğ• _testConsistent_ â‰¡ _swap ğ•¨ }Â¨ ğ•—
}

_testMonSearch â† { # âŠâŠ’âˆŠâ·âˆ§âˆ¨â‹â’
  (ğ•¨ gen.Arith RandShape1 ğ•©)âŠ¸{ ğ• _testConsistent_ â‰¡ ğ•¨ }Â¨ ğ•—
  (ğ•¨ gen.Char  RandShape1 ğ•©)âŠ¸{ ğ• _testConsistent_ â‰¡ ğ•¨ }Â¨ ğ•—
}
_testDySearch â† { # âŠâŠ’âˆŠâ‹â’
  sh â† RandShape1 ğ•©
  ss â† âŸ¨sh, (0âŠ¸<â—¶âŸ¨-âŸœâŒŠRandShapeâˆ˜ğ•©,RandShapeâŸ©Â·âŒŠğ•©Ã·1âŒˆÃ—Â´)âŠ¸âˆ¾ 1â†“shâŸ©
  aâ€¿b â† ğ•¨âŠ¸((0=Rand 4) âŠ‘ gen.Arithâ€¿gen.Char)Â¨ ss
  k â† â‹â€¿â’âŠğ•—
  as â† (âŠk) âŠ {ğ•a}Â¨ (â·k)âŠ{ğ•gen._apply}Â¨âŒ¾(2âŠ¸â†‘) âˆ§â€¿âˆ¨â€¿âŠ¢
  as { ğ•¨ ğ• _testConsistent_ â‰¡ b }Â¨ {ğ•Ëœ}âŸ(âˆŠË™âŠ¸=)Â¨ ğ•—
}

_testIndices â† { # /âŠ”
  (gen.Replicâ—‹RandBoundËœ ğ•©)âŠ¸{ ğ• _testConsistent_ â‰¡ ğ•¨ }Â¨ ğ•—
}
_testSelect â† { # /âŠâŠ”
  lâ€¿sh â† (â‹â‰ Â¨)âŠ¸âŠ RandShapeÂ¨ ğ•©â€¿ğ•©
  n â† RandBound ğ•©
  d â† ğ•¨ gen.Struct sh
  g â† ({âŠ} = ğ•—) âŠ gen.Replicâ€¿gen.IndMulti
  g { (n ğ•  0âŠ£Â´sh) ğ• _testConsistent_ â‰¡ d }Â¨ ğ•—
  g { (l ğ• lâ‰ âŠ¸â†‘sh) ğ• _testConsistent_ â‰¡ d }âŸ((0<â‰ l)âˆ¨âŠ”Ë™âŠ¸â‰ )Â¨ ğ•—
  GR â† ğ•¨ gen.StructâŸœRandShape1 Â·âŒŠğ•©Ã·1âŠ¸âŒˆ
  { (ğ• _testConsistent_ â‰¡)âŸœGR Range 2â‹†Range 8 }Â¨ âˆŠâŸœâŸ¨/âŸ©âŠ¸/ ğ•—
}

cases â† [
  âŸ¨âˆ¾`"+-Ã—Ã·â‹†âˆšâŒŠâŒˆÂ¬|"â€¿"âˆ§âˆ¨â‰¤<>â‰¥=â‰ ", testMonArithâ€¿testDyArithâŸ©
  âŸ¨"â¥Šâ‰âŒ½â‰âŠ"â€¿"â¥Šâ†‘â†“â†•âŒ½â‰", testMonStructâ€¿testDyStructâŸ©  # Monadic Â«Â» hard to test
  âŸ¨"â‰ =â‰¢"â€¿"", testDimâ€¿@âŸ©
  âŸ¨""â€¿"â‰âˆ¾Â«Â»", @â€¿testCombineâŸ©
  âŸ¨"âŠâŠ’âˆŠâ·âˆ§âˆ¨â‹â’"â€¿"âŠâŠ’âˆŠâ‹â’", testMonSearchâ€¿testDySearchâŸ©
  âŸ¨"/âŠ”"â€¿"/âŠâŠ”", testIndicesâ€¿testSelectâŸ©
# â†•<âˆ¾â†‘â†“â‰¡>âŠ‘ % âŠ‘â·
  âŸ¨"Â´"â€¿"Â´", testMonFoldâ€¿testDyFoldâŸ©
  âŸ¨"Ë`"â€¿"Ë`", testMonScanâ€¿testDyScanâŸ©
# Ë˜â‰Â¨âš‡âŒœâ¼âŸ
]
MakeTests â† {
  primâ€¿test â† <âˆ˜>Ë˜ â‰ ğ•¨
  m â† ğ•© âˆŠÂ¨â‰1 prim
  ((âˆ¾"Unsupported primitives: "â€¿"%"âˆ¾Â¨/Â¨âŸœğ•©) ! 0Ë™)âŸ(âˆ¨Â´âˆ¨Â´Â¨) Â¬âˆ¨Ëm
  p â† â€¢BQNâˆ˜â¥ŠÂ¨Â¨ ğ•©
  t â† <âˆ˜{tâ†2âŠ‘ğ•©â‹„(/Â´2â†‘ğ•©)_t}Ë˜ (âˆ¨Â´Â¨âŠË˜)âŠ¸/ â‰>â¥ŠÂ¨âŸ¨m,pË™Ë˜m,testâŸ©
  1 {ğ•âŠ¢ğ•}Â´ t
}

pr â† (âŠ‘cases)âŸ(0=Â·+Â´â‰ Â¨) opts.prims
modop â† â€¢BQNâˆ˜â¥ŠÂ¨ (1âŠ‘âŠ‘cases)âŸ(0=â‰ ) opts.modop
opts.types (cases MakeTests pr)âŒœ opts.num/opts.bounds
