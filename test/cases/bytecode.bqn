# Tests of bytecode operations.
# These use no primitives, so that compiled code can be run directly in
# a correct VM even if it has no runtime.
# Compile with a command such as $ src/cjs.bqn "aâ†2â‹„bâ†3â‹„a"

# Tests are meant to be run in order; comments indicate new instructions
# introduced by each.

5  % 5                     #  0 PUSH,  7 RETN
3  % 4â‹„3                   #  6 POPS
5  % aâ†5                   # 33 VARM, 48 SETN
4  % aâ†5â‹„aâ†©4               # 49 SETU
2  % aâ†2â‹„bâ†3â‹„a             # 32 VARO
1  % aâ†1â‹„A 4               # 18 FN1O
2  % aâ†2â‹„3 A 4             # 19 FN2O
6  % {ğ•©}6                  #  1 DFND
3  % Aâ†{ğ•¨}â‹„3 A 4           #    dyadic block function
7  % aâ€¿bâ†7â€¿2â‹„a             # 11 ARRO, 12 ARRM
4  % 4{ğ”½}                  # 26 MD1D
6  % 4{ğ”½â‹„ğ•©}6               #    deferred modifier
1  % 3{ğ”¾}{ğ•©} 1             # 27 MD2D
2  % (2{ğ”½}{ğ•©})3            # 20 TR2D
3  % 3({aâ€¿bâ†ğ•©â‹„a}{ğ•¨â€¿ğ•©})4    #    dyadic 2-train
4  % 4({ğ•¨â€¿ğ•©}{ğ•©}{ğ•¨})5       # 23 TR3O
2  % aâ€¿bâ†(2{ğ•¨â€¿ğ•©}{ğ•©})5â‹„a    #    monadic, data in left branch
2  % ({aâ†©2â‹„ğ•©}{ğ•©â‹„a}{aâ†©3â‹„ğ•©})aâ†4 # ordering
8  % aâ†3â‹„a{ğ•©}â†©8â‹„a          # 50 SETM
5  % aâ†4â‹„a{ğ•¨â‹„5}â†©6          #    returns new value
1  % aâ†3â‹„a{ğ•©â‹„1}â†©â‹„a         # 51 SETC
4  % aâ€¿bâ†2â€¿1â‹„aâ€¿b{ğ•©â€¿ğ•¨}â†©4â‹„a  #    lists

# Further tests for lexical scoping
1  % aâ†1â‹„{aâ†2}â‹„a
2  % aâ†1â‹„{aâ†©2}â‹„a
6  % fâ€¿gâ†{aâ†2â‹„{aâ†©ğ•©}â€¿{ğ•©â‹„a}}â‹„F 6â‹„G 0
5  % Lâ†{ğ•©{ğ•ğ•—}}â‹„{ğ•ğ•¤}L L L 5
3  % _lâ†{ğ•©{ğ•ğ•—} ğ”½}â‹„{ğ•ğ•¤} {ğ•©}_l 3 _l 5
1  % 1{ğ•¨}{ğ”½{ğ•©ğ”½ğ•¨}ğ”¾ğ”½}{ğ•©}0    # 0â‰ 1 via Church booleans
2  % 0â€¿(0â€¿{ğ•©}){{aâ€¿bâ†ğ•©â‹„tâ†ğ•¤â‹„{ğ•¤â‹„Tâ†©{ğ•¤â‹„{aâ€¿bâ†ğ•©â‹„a}}}{Bğ•—}0â‹„(T b){aâ€¿bâ†ğ•©â‹„ğ”½b}}ğ•—} 0â€¿(1â€¿(2â€¿(3â€¿(4â€¿{ğ•©}))))
