# Format an array to a string including newlines
{
  âŸ¨Type,Decomp,FF,FNâŸ©â†ğ•©
  ReprAtom â† <âŸœ@â—¶âŸ¨@âŠ¸â‰ â—¶âŸ¨"@","'"âŠ¸(âˆ¾âˆ¾âŠ£)âŸ©,FNâŸ©

  # Vertical padding for arrays of rank greater than 2
  PadCount â† {
    # Empty lines after each row: 1 if it's at the end of a 2-cell, plus
    # 1 if it's at the end of a 2-cell and a 3-cell, and so on
    # But none at the very end
    0âŒ¾(Â¯1âŠ¸âŠ‘) â¥Š ğ•¨ +â‰Â¯1â€¿âˆÂ´ Ã—âŒœËœ`âŒ¾âŒ½ (-ğ•©)â†‘Â¨1
  }
  PadV â† {
    # Leading shape and padding count
    p â† PadCount 1 âŒˆ ls â† Â¯1â†“â‰¢ğ•©
    # If ğ•© has cells, pad by selection; if it's empty, there are only
    # pads but selection would try to get cells (1âŒˆ above), so overtake.
    Pad â† {(Â»âŠ¸<âŠ¸Ã—/0âˆ¾1+ğ•¨) âŠ ' 'Â¨âˆ˜âŠâŠ¸âˆ¾ğ•©}
    p (0<â‰ âˆ˜âŠ¢)â—¶âŸ¨+Â´âŠ¸â†‘,PadâŸ© ((Ã—Â´ls)âˆ¾Â¯1â†‘â‰¢ğ•©) â¥Š ğ•©
  }âŸ(2 < =)
  PadVMixed â† {
    # PadV, but with 2-cells enclosed: they might have different lengths
    âˆ¾ (1 PadCount â‰¢ğ•©) (âŠ¢âˆ¾â‰âŸœ(Â¯1âŠ‘â‰¢)â¥Š' 'Ë™)Â¨ â¥Šğ•©
  }

  # Horizontal padding: just some spaces on either side
  PadH â† { sâ†âŸ¨â‰ ğ•©,ğ•¨âŸ©â¥Š' ' â‹„ âˆ¾â‰âŸ¨s,ğ•©,sâŸ© }

  # Add a frame to padded data
  Enframe â† âˆ¨â—‹(1âŠ¸â‰ )âŸœâ‰ â—¶{âˆ¨Â´2=+`-Ë"âŸ¨âŸ©"=âŒœâŠğ•©}â€¿1â—¶{
    # One-line version
    â‰"âŸ¨"âˆ¾(Â¯1â†“1â†“âŠğ•©)âˆ¾"âŸ©"
  }â€¿{
    # General case
    t â† "â”Œ" âˆ¾ (5âŠ¸<)â—¶âŸ¨â¥Š"Â·â”€"âŠËœ1âŒŠâŠ¢,FNâŸ©ğ•¨
    l â† (â‰ t) âŒˆ Â¯1 âŠ‘ â‰¢ğ•©
    âˆ¾ âŸ¨â‰lâ†‘t, ((0âŒˆ4âŒŠğ•¨-1)âŠ‘"Â·â•µâ•â”†â”Š")âŒ¾âŠ‘lâ†‘Ë˜ğ•©, â‰l-âŠ¸â†‘"â”˜"âŸ©
  }

  FmtEmpty â† (0â€¿0â‰¢â‰¢)â—¶("â”Œâ”"â‰"â””â”˜")â€¿(((2â‰ =)âˆ¨0=â‰ )â—¶{
    'â”'âŒ¾(0â€¿Â¯1âŠ¸âŠ‘) 2 Enframe 1 PadH ' 'Â¨ğ•©
  }â€¿{
    â‰(1<â‰ )â—¶âŸ¨"âŸ¨âŸ©",'â†•'âŒ¾âŠ‘Â·âˆ¾Â·"â€¿"âŠ¸âˆ¾Â¨FNÂ¨âŸ©â‰¢ğ•©
  })âˆ˜âŠ¢
  
  AlignNums â† {
    SameExp â† âŠ£`âŠ¸â‰¡âˆ˜â¥Š (âˆ¨`'e'âŠ¸=)âŠ¸/Â¨
    FrontPad â† âŒˆÂ´âˆ˜â¥ŠâŠ¸- âŠ‘âˆ˜âŠâŸœ'.'Â¨
    Wid â† SameExpâ—¶âŸ¨(âŒˆÂ´âˆ˜â¥ŠâŠ£Â¨âŠ¢)â‰ Â¨, â‰ Â¨+FrontPadâŸ© âŠÂ¨
    â‰ -âˆ˜WidË˜âŠ¸(â†‘Ë˜Â¨)âŒ¾(ğ•¨âŠ¸/) â‰â¼ğ•©
  }

  PaddingJoin â† {
    s â† â‰¢Â¨ ğ•©
    w â† (0<=)â—¶âŸ¨â¥Š,âŒˆËâŸ(=-1Ë™)âŸ©1âŠ‘Â¨s
    h â† âŒˆËâ‰1âŸ(0<=) âŠ‘Â¨s
    o â† <âˆ˜âˆ¾â‰2 â‰âŸ(0âŒˆ2-=) (h â‹ˆâŒœ wÂ¬(-â‰ w)â†‘1) â†‘Â¨ ğ•©
    2 PadH (1âŠ¸âŒ½âŠ¸â‰¡â¥Šh)â—¶âŸ¨PadVMixed,PadVâˆ˜>âŸ© o
  }

  FmtNonEmpty â† {
    r â† =ğ•©
    n â† (1<=)â—¶âŸ¨â†•0, âˆ§ËâŸ(=-1Ë™) 1=TypeÂ¨âŸ© ğ•©  # Numeric columns
    Join â† r Enframe Â· PaddingJoin nâŠ¸AlignNumsâŸ(0<+Â´n)
    ğ•¨ (âˆ¨Â´<âŸœâˆ)â—¶(Join <âŠ¸(FmtÂ¨))â€¿{
      p â† âŸ¨r>1,2âŸ©  # Outer padding
      o â† Â¯1((0+âŒœÂ´(1(1+Ã—)`âŠ¢)âŒ¾âŒ½Ã—â†•Â¨)âˆ˜â†“â‹ˆâŒœ2Ã—â†•âˆ˜âŠ‘)â‰¢ğ•©  # Offset
      E â† (1â€¿1â¥Š'â€¦')Ë™
      f â† o (ğ•¨-p)âŠ¸-âŠ¸(âŠ£ Eâˆ˜âŠ¢âŸ(âˆ¨Â´<âŸœâ‰¢) (âˆ¨Â´â‰¤âŸœ0)â—¶Fmtâ€¿E)Â¨ ğ•©
      Join f
    } ğ•©
  }

  FmtCharArr â† {
    r â† =ğ•© â‹„ ğ•© â†© ><Â¨0â†“ğ•©  # Ensure rank>0 and ' ' for fill
    k â† âˆâŸ(0âŠ¸=) -â‰  c â† Â¯1â†“â‰¢ğ•©
    q â† "'"""âŠ‘Ëœ0<r
    # Escape quotes in strings (rank 1) and substitute control chars
    # with control pictures for other ranks.
    CSub â† { ğ•© + (ğ•©(=Ã—'â¡'-âŠ¢)@+127) + ('â€'-@)Ã—ğ•©<@+32 }
    ğ•© â†© (1â‰ r)â—¶âŸ¨(1+q=âŠ¢)âŠ¸/,CsubâŸ© ğ•©
    (r Enframe 1 PadH PadV)âŸ(1â‰ r) â‰ (qâŒ¾âŠ‘câ¥Š(Â¯1âŠ‘1âˆ¾c)â†‘'Â·') âˆ¾â‰k ğ•© âˆ¾â‰k c-âŠ¸â†‘q
  }

  FmtArr â† (0<â‰ )â—¶âŸ¨2,âˆ§Â´2=TypeÂ¨âŸ©âˆ˜â¥Šâˆ˜âŠ¢â—¶FmtNonEmptyâ€¿FmtCharArrâ€¿FmtEmpty

  # Format data type
  FmtDat â† (0=Typeâˆ˜âŠ¢)â—¶âŸ¨â‰ ReprAtomâˆ˜âŠ¢, FmtArrâŸ©

  # Word-forming characters need to be separated by spaces
  IsWordChar â† âˆŠâŸœ(âˆ§"Â¯Ï€âˆ_") âˆ¨ (â¥Šâˆ§"0AaÃ€Ã Ã˜Ã¸"+0â‰Ë˜10âˆ¾2/26â€¿23â€¿7)âŠ¸(2|â‹)

  # Format part of a compound operation; return precedenceâ€¿string
  Paren â† "("âˆ¾âˆ¾âŸœ")"
  _dispOp_ â† {
    FmtComp â† Type (3â‰¤âŠ£)â—¶âŸ¨0â‹ˆÂ·ğ”½âŠ¢, ğ•ŠâŸ© âŠ¢
    k â† âŠ‘ d â† Decomp ğ•©
    p â† k âŠ‘ "00321111"-'0'
    JW â† âˆ¾ (âˆ§Ëâˆ˜IsWordChar (âŠ¢Â´Â¨Â¯1âŠ¸â†“)â‰(âŠ£Â´Â¨1âŠ¸â†“)) 0âŠ¸âˆ¾âŠ¸(â†‘âŸœ" "âŠ¸âˆ¾Â¨)âŸ(âˆ¨Â´âŠ£) âŠ¢
    FromComp â† JW (âŒ½âŸ(p>1)Â·-0=â†•âˆ˜â‰ ) (+âŸœâŠ‘Parenâˆ˜âŠ¢âŸ((2âŒŠp)â‰¤âŠ£)1âŠ¸âŠ‘)âŸœFmtCompÂ¨ âŠ¢
    s â† (2âŒŠ|k)â—¶âŸ¨â¥Šâˆ˜FFğ•©Ë™,ğ•¨ğ”¾âŠ¢,FromCompâŸ© 1â†“d
    s â†© âˆ¾âŸœ"{ğ”½}"âŸ(3>Â·Type Â¯1âŠ‘dË™)âŸ(2â‰¤p) s
    pâ€¿s
  }
  arr â† "*array*"
  FmtOp â† â‰1âŠ‘ (1=â‰ )â—¶âŸ¨arr,âŠâŸ©âˆ˜(âˆâ€¿âˆâŠ¸FmtDat) _dispOp_ (=âŸœ2â—¶âŸ¨FFâŠ‘âˆ˜âŠ¢,arrâŸ©)

  # Format any value to character matrix
  Fmt â† {
    t â† Typeğ•©
    ğ•¨ (3â‰¤t)â—¶âŸ¨FmtDat,tâŠ¸FmtOpâŸ© ğ•©
  }
  Trunc â† {
    c â† ğ•¨<sâ†â‰¢ f â† ğ•©
    ğ•¨ {lâ†c-Ëœğ•¨âŒŠs â‹„ lsâ†â‹ˆâŒœÂ´lâˆ¾âŸœ(â¥ŠâŸœ1)Â¨c â‹„ âˆ¾ ls â¥ŠÂ¨ (lâ†‘f)âŒ¾âŠ‘ 'â€¦'Â¨ ls}âŸ(âˆ¨Â´c) f
  }
  FmtW â† {
    m â† "â€¢Fmt: ğ•¨ must be a list of up to two numbers (width, height)"
    m ! (1â‰¥=)â—¶âŸ¨0,2â‰¥â‰ âŸ© ğ•¨
    (âŒ½ğ•¨âŠ¢âŠ˜Â»âˆâ€¿âˆ) (âŠ£ Trunc Fmt) ğ•©
  }

  # Represent as string
  RR â† {Reprğ•©}
  ReprList â† (0<â‰ )â—¶âŸ¨"âŸ¨âŸ©",(âŒˆÂ´(2â€¿1â€¿0Â»7â¥Š2)âŠËœTypeâŒœ)â—¶âŸ¨
    '"' (âŠ£âˆ¾((1+=)/âŠ¢)âˆ¾âŠ£) âŠ¢
    (1<â‰ )â—¶âŸ¨"âŸ¨"âˆ¾"âŸ©"Â«âˆ¾,1â†“âˆ¾âŸ©("â€¿"âˆ¾ReprAtom)Â¨
    "âŸ¨"âˆ¾"âŸ©"Â«Â·âˆ¾(","âˆ¾RR)Â¨
  âŸ©âŸ©
  ReprArr â† (2âŒŠ=)â—¶âŸ¨Paren"<"âˆ¾RRâˆ˜âŠ‘,ReprList,Parenâ‰¢âˆ¾âŸœ"â¥Š"âŠ¸âˆ¾â—‹ReprListâ¥ŠâŸ©
  ReprDat â† (0=Type)â—¶âŸ¨ReprAtom,ReprArrâŸ©
  ReprOp â† 1âŠ‘ RR _dispOp_ (!"Can't represent "âˆ¾"block"â€¿"namespace"âŠ‘Ëœ6=âŠ£)
  Repr â† Type (3â‰¤âŠ£)â—¶âŸ¨ReprDatâŠ¢,ReprOpâŸ© âŠ¢

  # Convert Fmt from matrix to string
  âŸ¨Â¯1â†“Â·â¥Š âˆ¾âŸœ(@+10)Ë˜âˆ˜FmtW, ReprâŸ©
}
