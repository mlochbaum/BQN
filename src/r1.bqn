# BQN runtime part 1. Requires:
#   Type Fill Log GroupLen GroupOrd _fillBy_
#   +-Ã—Ã·â‹†âŒŠâŒˆ|<>=â‰ â‰¤â‰¥â‰¢âŠ¢âŠ£â¥Šâˆ¾â‹ˆâ†‘â†“â†•âŠâŠ‘!âŒœË™ËœÂ¨Â´`âˆ˜â—‹âŠ¸âŸœâ—¶âŠ˜âŸ
# Filled in by runtime: glyphs and default PrimInd
# Provides: all BQN primitives

Ind1 â† { 0 Fill +`(0âŒˆâ‰ -1Ë™)âŠ¸â†‘GroupLen+`ğ•© }
/ â† Ind1 âŠ˜ (Ind1âŠ¸âŠ)  # LIMITED to natural number list ğ•©/ğ•¨

Decompose â† {0â€¿ğ•©}
PrimInd â† {ğ•©}
SetPrims â† {Decomposeâ€¿PrimInd â†© ğ•©}
SetInv   â† {{swapInverse ğ•â†©}ğ•¨ â‹„ inverse ğ•â†©}

IsArray â† 0=Type
IsAtom  â† 1â‰¤Type
Int â† (1=Type)â—¶âŸ¨0,âŒŠâŠ¸=âŸ©
Nat â† (1=Type)â—¶âŸ¨0,|âˆ˜âŒŠâŠ¸=âŸ©
ToArray â† <âŸIsAtom
IsSimple â† 1Ã—Â´IsAtomâŒœ
Deshape â† IsArrayâ—¶{ğ•©FillâŸ¨ğ•©âŸ©}â€¿â¥Š
Cell â† â†“âŸœâ‰¢
MatchS â† 1Ã—Â´=Â¨
PermInv â† 1âŒœâŠ¸GroupOrd

_qSearch â† {+Â´Â·Ã—`ğ•—(1-=)âŒœ<}
_glyphLookup_ â† {
  {PrimIndğ•©} âŠ‘ ((ğ•˜âŠ‘Ëœğ•—_qSearch)âŒœglyphs)Ë™
}
_isGlyph â† { (glyphs _qSearch ğ•—) = {PrimIndğ•©} }
IsJoin â† 'âˆ¾'_isGlyph
DIsConst â† (4=0âŠ¸âŠ‘)â—¶0â€¿('Ë™'_isGlyph 2âŠ¸âŠ‘)

Split2 â† { sâ†2âŠ¸Ã—âŒœâ†•(â‰ ğ•©)Ã·2 â‹„ âŸ¨sâŠğ•©,(1âŠ¸+âŒœs)âŠğ•©âŸ© }
_lookup_ â† {
  kâ€¿vâ†Split2 ğ•˜ â‹„ k _glyphLookup_ (vâˆ¾âŸ¨ğ•—âŸ©)
}
Identity â† {ğ•0} !âˆ˜"Â´: Identity not found" _lookup_ âŸ¨
  '+',0 , '-',0
  'Ã—',1 , 'Ã·',1
  'â‹†',1 , 'Â¬',1
  'âŒŠ',âˆ , 'âŒˆ',Â¯âˆ
  'âˆ¨',0 , 'âˆ§',1
  'â‰ ',0 , '=',1
  '>',0 , 'â‰¥',1
âŸ©

_foldâ†{
  "Â´: ğ•© must be a list" ! 1==ğ•©
  ğ•¨ (0<â‰ )âŠ˜1â—¶âŸ¨Identity ğ•—Ë™, ğ”½Â´âŸ© ğ•©
}

_eachdâ†{
  _dâ†{ # Equal ranks
    "Mapping: Equal-rank argument shapes don't agree" ! ğ•¨ MatchSâ—‹â‰¢ ğ•©
    ğ•¨ğ”½Â¨ğ•©
  }
  _eâ†{ # ğ•¨ has smaller or equal rank
    pâ†â‰¢ğ•¨ â‹„ kâ†=ğ•¨ â‹„ qâ†â‰¢ğ•©
    "Mapping: Argument shape prefixes don't agree" ! p MatchS kâ†‘q
    lâ†1Ã—Â´kâ†“q
    mâ†â‰ aâ†â¥Šğ•¨ â‹„ bâ†â¥Šğ•©
    qâ¥Šm (âŠ‘âŸœağ”½lâŠ¸Ã—âŠ¸+âŠ‘bË™)âŒœâ—‹â†• lÃ—m>0
  }
  =â—‹=â—¶âŸ¨>â—‹=â—¶âŸ¨ğ”½_eâ‹„ğ”½Ëœ_eËœâŸ©â‹„ğ”½_dâŸ©
}

_pervâ†{ # Pervasion
  Râ†+â—‹IsArrayâ—¶âŸ¨
    ğ”½
    {RâŒœğ•©}âŠ˜(>â—‹IsArrayâ—¶{ğ•¨Ë™âŠ¸RâŒœğ•©}â€¿{RâŸœ(ğ•©Ë™)âŒœğ•¨}) _fillBy_ {ğ•¨Rğ•©}
    {ğ•¨R _eachdğ•©} _fillBy_ {ğ•¨Rğ•©}
  âŸ©
}

# Sorting
CLE â† (â‰¤âŸœâˆâ‰¤Â·=ËœâŠ¢)â‰¤â‰¤  # Place NaNs after other numbers
Cmp0 â† CLEËœ-CLE
Cmp1 â† (0<1Ã—Â´â‰¢âˆ˜âŠ¢)â—¶âŸ¨1, IsArrayâˆ˜âŠ¢â—¶(1-2Ã—â‰¤)â€¿{ğ•¨Cmp1ğ•©}âŸœ(0âŠ‘â¥Š)âŸ©
CmpLen â† {
  eâ†ğ•¨-â—‹(1Ã—Â´0âŠ¸<âŒœ)ğ•©
  ğ•¨(e=0)â—¶âŸ¨e,0âŸ©â€¿{
    SMâ†Cmp0 â‹ˆ â‰¥âŠ‘â‹ˆ
    câ€¿râ†ğ•¨SMâ—‹â‰ ğ•©
    lâ†ğ•¨{
      iâ†0+Â´Ã—`ğ•¨=Â¨ğ•©
      mâ†1Ã—Â´iâ†•âŠ¸âŠğ•¨
      {kâ€¿lâ†SMÂ´ğ•©â‹„câ†©kâ‹„mÃ—â†©l}âˆ˜(<âŠ‘âŒœğ•¨â€¿ğ•©Ë™)âŸ(râŠ¸>)i
      m
    }â—‹{ğ•©âŠËœ(Â¯1+â‰ ğ•©)âŠ¸-âŒœâ†•r}ğ•©
    âŸ¨c,lâŸ©
  }ğ•©
}
_getCellCmp â† {
  Ciâ†ğ”½â‹„câ†ğ•¨âŠ£0â‹„lâ†ğ•©
  Ccâ†{
    aâ†ğ•¨â‹„bâ†ğ•©
    Sâ†(lâŠ¸=)â—¶{Sâˆ˜(1+ğ•©)âŸ(0âŠ¸=)a Ciâ—‹(ğ•©âŠ¸+)b}â€¿c
    S 0
  }
  (ğ•¨ âŠ¢âŠ˜{ğ•¨âŸ(0âŠ¸=)ğ•} ciË™)âŸ(1=l) cc
}
Cmp â† +â—‹IsArrayâ—¶âŸ¨
  Cmp0
  IsArrayâˆ˜âŠ£â—¶âŸ¨Cmp1,-Cmp1ËœâŸ©
  {
    lcâ†ğ•¨CmpLenâ—‹â‰¢ğ•©
    cc â† (âŠ‘âŸœ(â¥Šğ•¨))âŠ¸CmpâŸœ(âŠ‘âŸœ(â¥Šğ•©)) _getCellCmpÂ´ lc
    CcËœ0
  }
âŸ©

_grade â† {
  gt â† ğ•—
  cmps â† {ğ•Ëœ}âŒœâŸğ•—âŸ¨Cmp,Cmp0,Cmpâ‰¤0Ë™,CLEâŸ©
  _getC_ â† { ğ•¨ ğ•˜{(ğ•¨ ğ• _getCellCmp ğ•—)â‰¤0Ë™}âŸ(ğ•©â‰¤1) ğ”½ ğ•©âŠ‘cmps }
  0 Fill {
    "â‹ğ•©: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
    lâ†â‰ ğ•©
    (2â‰¤l)â—¶âŸ¨â†•âˆ˜l,{
      m1â†1=mâ†1Ã—Â´1 Cell ğ•©
      ğ•©â†©â¥Šğ•©
      a0â†1â‹„tsâ†0â‹„{a0Ã—â†©1â‰¤ğ•©â‹„ts+â†©ğ•©}âˆ˜TypeâŒœğ•©
      csâ†a0+2Ã—m1
      Merge â† { # Merge sort
        le â† ğ•©{ğ•â—‹(âŠ‘âŸœğ•—)} _getC_ m cs
        Bâ†lâŠ¸â‰¤â—¶âŠ¢â€¿l
        (â†•l){
          iâ†-dâ†ğ•¨ â‹„ jâ†eiâ†ejâ†0
          eâ†3 â‹„ Gâ†LEâ—‹(âŠ‘âŸœ(mâŠ¸Ã—âŒœâŸ(1-m1)ğ•©)) â‹„ câ†âŸ¨1-G,0,1,2âŸ©
          sâ†(8â‰¤d)âŠ‘âŸ¨+,{(ğ•©-1){eâ†©2â‹„jâ†©iâ‹„iâ†©ğ•©}âŸGâŸ(1-e)ğ•©}âŸ©
          Nâ†{iâ†©d+ğ•¨â‹„ejâ†©B d+eiâ†©B jâ†©d+ğ•©â‹„eâ†©lâ‰¤jâ‹„S eiâ‹„i R j}
          Râ†{ğ•¨eâ—¶cğ•©}â—¶{e+â†©2Ã—ei=iâ†©1+ğ•¨â‹„ğ•¨}â€¿{e+â†©ej=jâ†©1+ğ•©â‹„ğ•©}â€¿N
          {(i R j)âŠ‘ğ•©}âŸœğ•©âŒœğ•©
        }Â´(2â‹†ni-1+âŠ¢)âŒœâ†•niâ†âŒˆ2 Log l+l=0
      }
      # Counting sort for small-range ints
      blâ†buâ†0 â‹„ Countâ†{GroupLenâŠ¸GroupOrd (gtâŠ‘âŸ¨-âŸœbl,buâŠ¸-âŸ©)âŒœğ•©}
      srâ†((3=cs)Ã—ts=l)â—¶âŸ¨0,(1Ã—Â´âŒŠâŠ¸=âŒœ)â—¶0â€¿{((buâ†©âŒˆÂ´ğ•©)-blâ†©âŒŠÂ´ğ•©)â‰¤2Ã—l}âŸ©ğ•©
      srâ—¶Mergeâ€¿Count ğ•©
    }âŸ©ğ•©
  }âŠ˜{
    cxâ†(=ğ•©)-câ†1-Ëœ=ğ•¨
    "â‹ or â’: Rank of ğ•¨ must be at least 1" ! 0â‰¤c
    "â‹ or â’: Rank of ğ•© must be at least cell rank of ğ•¨" ! 0â‰¤cx
    swâ†1 Cell ğ•¨ â‹„ nwâ†â‰ ğ•¨
    ğ•©â†©ToArrayğ•© â‹„ sxâ†cx Cell ğ•© â‹„ lzâ†1Ã—Â´szâ†cxâ†‘â‰¢ğ•©
    sz â¥Š ğ•¨ (0<nw)â—¶{ğ•©â‹„0âŒœâ†•lz}â€¿{
      a0wâ†IsSimpleğ•¨ â‹„ Gwâ†âŠ‘âŸœğ•¨ â‹„ lwâ†1Ã—Â´sw
      lewâ†{ğ•â—‹Gw} _getC_ lw a0w+2Ã—1=lw
      "â‹ or â’: ğ•¨ must be sorted" ! 1Ã—Â´LEwâŸœ(lwâŠ¸+)âˆ˜(lwâŠ¸Ã—)âŒœâ†•nw-1
      a0â†IsSimpleâˆ˜ğ•©âŠ¸Ã—âŸâŠ¢a0w â‹„ Gxâ†âŠ‘âŸœğ•©
      cdâ€¿lcâ†sw CmpLen sx
      le â† cd {GwâŠ¸ğ•âŸœGx}_getC_ lc a0+2Ã—1=lc
      Bâ†lwâŠ¸Ã—âŠ¸LE
      BinSearch â† {
        Bx â† BâŸœğ•©
        R â† {aâ†Bx mâ†ğ•©+hâ†âŒŠğ•¨Ã·2â‹„(h+aÃ—ğ•¨-2Ã—h)R aâŠ‘ğ•©â€¿m}âŸ(>âŸœ1)
        1 + (nw+1) R Â¯1
      }
      (BinSearch (1Ã—Â´sx)âŠ¸Ã—)âŒœ â†•lz
    }â—‹â¥Š ğ•©
  }
}

â‹ â† 0 _grade
â’ â† 1 _grade

# Searching
_searchâ†{ # 0 for âˆŠËœ, 1 for âŠ
  ind â† ğ•—
  red â† ğ•—âŠ‘âŸ¨1-Ã—Â´,+Â´Ã—`âŸ©
  0 Fill {
    câ†1-Ëœ=ğ•¨
    "pâŠğ•© or ğ•¨âˆŠp: p must have rank at least 1" ! 0â‰¤c
    "pâŠn or nâˆŠp: Rank of n must be at least cell rank of p" ! câ‰¤=ğ•©
    nâ†â‰ ğ•¨ â‹„ kâ†1Ã—Â´sâ†1 Cell ğ•¨ â‹„ cxâ†c-Ëœ=ğ•©
    lxâ†1Ã—Â´shâ†cxâ†‘â‰¢ğ•©
    sh â¥Š ğ•¨ (eâ†0<nÃ—k)â—¶âŸ¨0,s MatchS cxâŠ¸CellâŸ©â—¶{ğ•©â‹„(indâ—¶âŸ¨nâŠ¸>,âŠ¢âŸ© nÃ—e)âŒœâ†•lx}â€¿{
      cc â† (âŠ‘âŸœ(â¥Šğ•¨))âŠ¸(1-Match)âŸœ(âŠ‘âŸœ(â¥Šğ•©)) _getCellCmp k
      ğ•¨ Ã—â—‹(8<â‰ âˆ˜â¥Š)â—¶{ğ•©
        iâ€¿jâ†(kâŠ¸Ã—âŒœâ†•)âŒœnâ€¿lx â‹„ {Red CCâŸœğ•©âŒœi}âŒœj
      }â€¿{
        gâ†Reverseâ’ğ•¨
        iâ†gâŠËœ(0âŒˆ-âŸœ1)âŒœâ¥Š(gâŠğ•¨)â‹ğ•©
        adjâ†indâŠ‘âŸ¨1âŠ¸-,âŠ£--âŸœnâŠ¸Ã—âŸ©
        i(âŠ£ Adj CCâ—‹(kâŠ¸Ã—))Â¨â†•lx
      } ğ•©
    } ğ•©
  }âŸœToArray
}
_selfâ†{
  "âˆŠğ•© or âŠğ•©: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  gâ†â‹ğ•©
  kâ†1Ã—Â´1 Cell ğ•©
  cc â† (1-Match)â—‹(âŠ‘âŸœ(â¥Šğ•©)) _getCellCmp k
  0 Fill (PermInv g) âŠ g ğ”½ 0âŠ¸<â—¶âŸ¨1, -âŸœ1 CCâ—‹(âŠ‘âŸœ(kâŠ¸Ã—âŒœg)) âŠ¢âŸ©âŒœâ†•â‰ ğ•©
}

Findâ†{
  râ†=ğ•¨ â‹„ dâ†(=ğ•©)-r
  "ğ•¨â·ğ•©: Rank of ğ•¨ cannot exceed rank of ğ•©" ! 0â‰¤d
  iâ†<0 â‹„ jâ†â¥ŠâŸœ(â†•1Ã—Â´âŠ¢)dâ†‘sâ†â‰¢ğ•©
  (â‰¢ğ•¨) { Aâ†Ã—âŸœğ•©âŒœâŠ¸(+âŒœ)âŸœâ†• â‹„ i Aâ†©ğ•¨ â‹„ j Aâ†©0âŒˆ1+ğ•©-ğ•¨ }Â¨ dâ†“s
  0 Fill (ğ•¨ Match (â¥Šğ•©)âŠËœi+âŒœ<)âŒœ j
}â—‹ToArray

Indicesâ†{
  "/ğ•©: ğ•© must have rank 1" ! 1==ğ•©
  "/ğ•©: ğ•© must consist of natural numbers" ! 1Ã—Â´NatâŒœğ•©
  / ğ•©
}
IndicesInvâ†{
  IA 1==ğ•©
  IA 1Ã—Â´NatâŒœğ•©
  GroupLen ğ•©
}
SelfClas â† (PermInvâˆ˜â‹âˆ˜/ËœâŠËœÂ¯1+`âŠ¢) _self
OccurrenceCount â† â†•âˆ˜â‰ âŠ¸(âŠ£-Â¨Â·âŒˆ`Ã—Â¨) _self

Transposeâ†(0<=)â—¶âŸ¨ToArray,{
  lâ†â‰ ğ•© â‹„ mâ†1Ã—Â´câ†1 Cell ğ•©
  (â¥Šğ•©)âŠËœ(câ¥Šâ†•m)+âŸœ(mâŠ¸Ã—)âŒœâ†•l
}_fillBy_âŠ¢âŸ©
TransposeInvâ†{
  râ†1-Ëœ=ğ•© â‹„ sâ†â‰¢ğ•© â‹„ lâ†râŠ‘s â‹„ câ†râ†‘s
  (â¥Šğ•©)âŠËœ(â†•l)+âŸœ(lâŠ¸Ã—)âŒœcâ¥Šâ†•1Ã—Â´c
}_fillBy_âŠ¢âŸ{IX IsArrayğ•©â‹„0<=ğ•©}

_reorderAxesSub_â†{
  "ğ•¨â‰ğ•©: ğ•¨ must have rank at most 1" ! 1â‰¥=ğ•¨
  ğ•¨â†©Deshapeğ•¨ â‹„ ğ•©â†©ToArrayğ•©
  "ğ•¨â‰ğ•©: Length of ğ•¨ must not exceed rank of ğ•©" ! (â‰ ğ•¨)â‰¤râ†=ğ•©
  "ğ•¨â‰ğ•©: ğ•¨ must consist of valid axis indices" ! 1âˆ§Â´(Natâˆ§<âŸœr)âŒœğ•¨
  rğ”½â†©nâ†GroupLenğ•¨
  aâ†ğ”¾ ğ•¨âˆ¾(/0âŠ¸=âŒœn)âˆ¾{ğ•©âŠ¸+âŒœâ†•r-ğ•©}â‰ n
  lâ€¿sâ†aâŠ¸Group1âŒœâ‹ˆâŸœStrideâ‰¢ğ•©
  (âŒŠÂ´âŒœl) (0<â‰ âˆ˜âŠ¢)â—¶âŸ¨â¥Š,((<0)+âŒœÂ´s(<+Â´)âŠ¸(Ã—âŒœ)âŸœâ†•Â¨âŠ£)âŠ¸âŠâŸœâ¥ŠâŸ© _fillBy_ âŠ¢ ğ•©
}
HandleDupAxesâ†{
  râ†ğ•¨-0+Â´(0âŒˆ-âŸœ1)âŒœğ•©
  "ğ•¨â‰ğ•©: Skipped result axis" ! (â‰ ğ•©)â‰¤r
  r
}
ReorderAxes â† HandleDupAxes _reorderAxesSub_ âŠ¢
ReorderAxesInv â† {IA 1â‰¥0âŒˆÂ´ğ•©â‹„ğ•¨} _reorderAxesSub_ PermInv

Prefixesâ†{
  "â†‘ğ•©: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  0âŠ¸âŠ‘âŠ¸Fill â†•âŠ¸âŠâŸœğ•©âŒœ â†•1+â‰ ğ•©
}
Suffixesâ†{
  "â†“ğ•©: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  lâ†â‰ ğ•©
  lâŠ¸âŠ‘âŠ¸Fill {ğ•©âŠ¸+âŒœâ†•l-ğ•©}âŠ¸âŠâŸœğ•©âŒœ â†•1+l
}

NormIndPâ€¿NormIndSâ†{
  EIâ€¿erâ†ğ•© â‹„ _crâ†{âŠ¢âŠ£er!ğ”½}
  0âŠ¸â‰¤â—¶âŸ¨0âŠ¸â‰¤_cr+, >_crâŸ© âŠ£ EIâˆ˜âŠ¢
}âŒœâŸ¨
  âŸ¨"ğ•¨âŠ‘ğ•©: Indices in ğ•¨ must consist of integers"!Int,"ğ•¨âŠ‘ğ•©: Index out of range"âŸ©
  âŸ¨"ğ•¨âŠğ•©: Indices in ğ•¨ must be integers"!âŒŠâŠ¸=,"ğ•¨âŠğ•©: Indices out of range"âŸ©
âŸ©
Pick0â†{
  "ğ•¨âŠ‘ğ•©: ğ•© must be a list when ğ•¨ is a number" ! 1==ğ•©
  ğ•©âŠ‘Ëœ(â‰ ğ•©)NormIndPğ•¨
}
Pick1â†{
  "ğ•¨âŠ‘ğ•©: Indices in compound ğ•¨ must be lists" ! 1==ğ•¨
  "ğ•¨âŠ‘ğ•©: Index length in ğ•¨ must match rank of ğ•©" ! ğ•¨=â—‹â‰ sâ†â‰¢ğ•©
  iâ†0â‹„ğ•¨{iâ†©(ğ•©NormIndPğ•¨)+ğ•©Ã—i}Â¨s
  iâŠ‘â¥Šğ•©
}âŸœToArray
Pickdâ†IsArrayâ—¶âŸ¨1,IsSimpleâ¥ŠâŸ©âˆ˜âŠ£â—¶{PickdâŸœğ•©âŒœğ•¨}â€¿Pick1
Pickâ†IsArrayâˆ˜âŠ£â—¶Pick0â€¿Pickd

_multiAxisâ†{
  glâ€¿Testâ€¿d1â€¿aaâ€¿Singleâ€¿Ind â† ğ•—
  pre â† "ğ•¨"âˆ¾glâˆ¾"ğ•©: "
  es â† preâˆ¾"ğ•© must have rank at least 1 for simple ğ•¨"
  er â† preâˆ¾"Compound ğ•¨ must have rank at most 1"
  el â† preâˆ¾"Length of compound ğ•¨ must be at most rank of ğ•©"
  et â† preâˆ¾"ğ•¨ must be an array of numbers or list of such arrays"
  tt â† d1 âŠ‘ âŸ¨âŠ¢ , et ! 1Ã—Â´Â·â¥ŠIsArrayâ—¶âŸ¨aa,1Ã—Â´Â·â¥Š(1=Type)âŒœâŸ©âŒœ âŸ©
  Testâˆ˜âŠ£â—¶{ # Multiple axes
    er ! 1â‰¥=ğ•¨ â‹„ TT ğ•¨
    lâ†â‰ ğ•¨â†©â¥Šğ•¨ â‹„ el ! lâ‰¤=ğ•©
    jâ†<0 â‹„ ğ•¨ { jâ†©(Ã—âŸœğ•©âŒœj)+âŒœğ•¨Indğ•© }Â¨ pâ†lâ†‘sâ†â‰¢ğ•©
    j âŠ (âŸ¨1Ã—Â´pâŸ©âˆ¾lâ†“s)â¥Šğ•©
  }â€¿{
    es ! 1â‰¤=ğ•©
    ğ•¨ Single ğ•©
  }
}

FirstCellâ†{
  "âŠğ•©: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  "âŠğ•©: ğ•© cannot have length 0" ! 0<â‰ ğ•©
  (<0) âŠ ğ•©
}
Select â† âŸ¨"âŠ"
  1Ã—Â´Â·(1=Type)âŒœâ¥Š â‹„ 1,0
  {(â‰ ğ•©)âŠ¸NormIndSâŒœğ•¨} âŠ âŠ¢
  {ğ•©âŠ¸NormIndSâŒœğ•¨}
âŸ©_multiAxisâ—‹ToArray
First â† IsArrayâ—¶âŸ¨âŠ¢, (0<â‰ )â—¶âŸ¨!âˆ˜"âŠ‘ğ•©: ğ•© can't be empty",0âŠ¸âŠ‘âŸ©â¥ŠâŸ©

Reverseâ†{
  "âŒ½ğ•©: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  lâ†â‰ ğ•©
  ((l-1)âŠ¸-âŒœâ†•l) âŠ ğ•©
}
RotReduce â† {
  "ğ•¨âŒ½ğ•©: ğ•¨ must consist of integers" ! Intğ•¨
  ğ•©+â†©0=ğ•© â‹„ râ†ğ•¨-ğ•©Ã—âŒŠğ•¨Ã·ğ•©
  "ğ•¨âŒ½ğ•©: ğ•¨ too large" ! r<ğ•©
  r
}
RotL â† â†“âˆ¾â†‘
Rot â† (1==âˆ˜âŠ¢)â—¶âŸ¨RotLâŸœ(â†•â‰ )âŠâŠ¢,RotLâŸ©
Rotate â† âŸ¨"âŒ½"
  IsAtom, 0,0
  (RotReduceâŸœâ‰  Rot âŠ¢)âŸ(0<â‰ âˆ˜âŠ¢)
  (RotReduce RotL Â·â†•âŠ¢)
âŸ©_multiAxisâŸœToArray _fillBy_ âŠ¢

RepIndâ†(2âŒŠ=âˆ˜âŠ£)â—¶{
  ğ•¨â†©(0âŠ‘â¥Š)âŸIsArrayğ•¨
  "ğ•¨/ğ•©: ğ•¨ must consist of natural numbers" ! Nat ğ•¨
  eâ†râ†ğ•¨
  {e+â†©râ‹„1+ğ•©}âŸ{e=ğ•¨}Ëœ`â†•rÃ—ğ•©
}â€¿{
  "ğ•¨/ğ•©: Lengths of components of ğ•¨ must match ğ•©" ! ğ•©=â‰ ğ•¨
  "ğ•¨/ğ•©: ğ•¨ must consist of natural numbers" ! 1Ã—Â´|âˆ˜âŒŠâŠ¸=âŒœğ•¨
  / ğ•¨
}â€¿{
  "ğ•¨/ğ•©: Components of ğ•¨ must have rank 0 or 1" ! 0Ë™
}
Replicateâ†âŸ¨"/"
  ((0<â‰ )Ã—Â´(1=Type)âŒœ)âˆ˜â¥Š, 1,1
  RepIndâŸœâ‰  âŠ âŠ¢
  RepInd
âŸ©_multiAxisâ—‹ToArray _fillBy_ âŠ¢

IsPure â† {dâ†Decomposeğ•© â‹„ 2âŠ¸â‰¤â—¶âŸ¨â‰¤âŸœ0, 1Ã—Â´Â·ğ•ŠâŒœ1â†“dË™âŸ©0âŠ‘d}
hfils â† {ğ•Â´{0 Fill ğ•}â€¿âŠ¢}âŒœ(âŠ¢âˆ¾{ğ•Ëœ}âŒœ)âŠ¢â€¿{ğ•{ğ•âŠ˜ğ•}ğ•}
HomFil â† "=â‰ â‰¡â‰¢"_glyphLookup_(1â€¿1â€¿2â€¿3â€¿0âŠhfils)âŠ¸{ğ•ğ•©}
_fillByPure_â†{
  ğ•˜ (3â‰¤Typeâˆ˜âŠ£)â—¶âŸ¨{ğ•¨Fillğ•},{(ğ•¨HomFilğ•©)_fillBy_ğ•¨}âŸ(IsPureâŠ£)âŸ© ğ•—
}
_each  â† {ğ•¨ğ”½âŒœâŠ˜(ğ”½_eachd)_fillByPure_ğ”½â—‹ToArrayğ•©}
_table â† {ğ•¨ğ”½âŒœ_fillByPure_ğ”½â—‹ToArrayğ•©}

matchâ†{(0âŠ‘ğ•¨)â—¶(1âŠ‘ğ•¨)â€¿ğ•©}Â´âŸ¨
  âŸ¨=â—‹IsArray, 0âŸ©
  âŸ¨IsArrayâˆ˜âŠ¢, =âŸ©
  âŸ¨=â—‹=      , 0âŸ©
  âŸ¨MatchSâ—‹â‰¢ , 0âŸ©
  {1Ã—Â´â¥Šğ•¨MatchÂ¨ğ•©}
âŸ©
Depthâ†IsArrayâ—¶0â€¿{1+0âŒˆÂ´DepthâŒœâ¥Šğ•©}

Join1â†{
  # List of lists
  "âˆ¾ğ•©: ğ•© must have an element with rank at least =ğ•©" ! 0<0+Â´=âŒœğ•©
  iâ†jâ†Â¯1 â‹„ eâ†âŸ¨âŸ© â‹„ aâ†ğ•©
  {{eâ†©Deshape aâŠ‘Ëœiâ†©ğ•©â‹„jâ†©Â¯1}âŸ(1-iâŠ¸=)ğ•©â‹„(jâ†©j+1)âŠ‘e}âŒœ/â‰ âŒœğ•©
}

underâ†{
  Errâ†{ğ•©}
  IsErr â† (3=Type)â—¶âŸ¨0,ErrË™âŠ¸=âŸ©
  E â† ErrË™
  _errIf â† {âŠ¢âŠ˜Ã—â—‹(1-ğ”½)â—¶âŸ¨ErrË™,ğ•âŸ©}
  SE â† IsErr _errIfâŸ(3â‰¥Type)

  Expand â† {
    fâ€¿aâ€¿iâ€¿qâ†ğ•© â‹„ eâ†iâŠ‘â¥Ša
    âŸ¨IsArrayâ—¶âŸ¨âŸ¨âŸ©,âˆ¾âŸœâŸ¨iâŸ©âŸ©f,e,IsArrayâ—¶âŸ¨0,@Fillâ¥ŠâŸœ(â†•1Ã—Â´âŠ¢)âˆ˜â‰¢âŸ©e,qâŸ©
  }
  _s â† {
    âŸ¨st,dâ€¿oâŸ©â†ğ•©  # Function, input depth, output is structural
    fâ€¿aâ€¿iâ€¿qâ†ExpandâŸ(d>Â·IsArray 2âŠ‘âŠ¢)ğ•—   # Path, array reference, indices
    {fâ€¿aâ€¿ğ•©â€¿(qâŒˆ1<o) _s}âŸ(0<o) ğ•¨ St i
  }
  IsStruct â† (4=0âŠ¸âŠ‘)â—¶âŸ¨0,sË™=2âŠ¸âŠ‘âŸ© {Decomposeğ•©}
  NS â† IsStruct _errIf
  InitS â† {Â¯1â€¿âŸ¨ğ•©âŸ©â€¿0â€¿0 _s}

  _amb â† {(IsStructâŠ¢)â—¶âŸ¨ğ•, ğ•©â€¿ğ•—{ğ•¨ğ•ğ•—}âŸ©}
  _mon â† {(ğ•—_ambğ•©)âŠ˜(NSğ•©)}
  _dy  â† {(NSğ•©)âŠ˜(ğ•—_ambğ•©)}
  kâ€¿v â† Split2 âŸ¨
    "âŠ¢âŠ£Ëœâˆ˜â—‹âŠ¸âŸœâŠ˜â—¶",  âŠ¢  # Ë™ handled specially
    "Â´Ë",         {râ†ğ•©â‹„{IsArrayâˆ˜âŠ¢â—¶âŸ¨E,ğ•—_râŸ©}}
    "=â‰ â‰¢",        1â€¿0 _mon
    "<â‹ˆ",         0â€¿2 _mon
    "â‰",          1â€¿1 _mon  # Dyad combines
    "â†•/Â»Â«",       1â€¿1 _dy
    "âŠ”",          1â€¿2 _dy
    "â¥ŠâŒ½â‰âŠ",       1â€¿1 _amb
    "â†‘â†“",         {(1â€¿2 _ambğ•©)âŠ˜(1â€¿1 _ambğ•©)}
    "âŠ‘",          1â€¿2 _amb
  # ">",          2â€¿1 _mon
  # "âˆ¾",          2â€¿1 _mon  # Dyad combines
  # "Ë˜â‰Â¨âŒœ",
  # "âš‡",
  âŸ©
  NSPrim â† (Type-3Ë™)â—¶âŸ¨NS, {mâ†ğ•©â‹„{NS(ğ•—_m)Ë™0}}, {mâ†ğ•©â‹„{NS(ğ•—_m_ğ•˜)Ë™0}}âŸ©
  SP â† (Join1 k)_glyphLookup_((kâ‰ âŒœâŠ¸/v)âˆ¾âŸ¨NSPrimâŸ©)

  Recompose â† âŠ£â—¶âŸ¨
    âŠ¢                  # 0 primitive
    âŠ¢                  # 1 block
    {ğ•ğ•}Â´âŠ¢             # 2-train
    {Fâ€¿Gâ€¿Hâ†ğ•©â‹„F G H}    # 3-train
    {Fâ€¿mâ†ğ•©â‹„F _m}       # 4 1-modifier
    {Fâ€¿mâ€¿Gâ†ğ•©â‹„F _m_ G}  # 5 2-modifier
  âŸ©
  Recomp â† (EË™=â‰¥âŸœ3âŠ¸âŠ‘)â—¶âŸ¨Recompose,EË™âŸ©

  SFN â† 0âŠ¸â‰¤â—¶âŸ¨3,2âŠ¸â‰¤â—¶âŠ¢â€¿2âŸ©âˆ˜(0âŠ‘âŠ¢)â—¶âŸ¨
    SE Â· {pâ†SPğ•©â‹„Pğ•©} 1âŠ‘âŠ¢           #  0 primitive
    EË™                            #  1 block
    DIsConstâ—¶âŸ¨0âŠ¸âŠ‘ Recomp {SFNâŒœ1â†“ğ•©}, SE{(1âŠ‘ğ•©)Ë™}âŸ©  # other operation
    SE 1âŠ‘âŠ¢                        # Â¯1 constant
  âŸ©âŸœ{Decomposeğ•©}

  # Traverse indices ğ•© and values ğ•¨.
  # Return flat lists âŸ¨indices,valuesâŸ©, or err if ğ•¨ doesn't capture ğ•©.
  conform â† {ğ•â—¶0â€¿ğ•}Â´âŸ¨IsArrayâŠ¢, =â—‹=, MatchSâ—‹â‰¢âŸ©
  GetInserts â† {
    vâ€¿dâ†ğ•¨
    countâ†1â‹„DCâ†IsArrayâ—¶âŸ¨0,dâ—¶âŸ¨1,1+0âŒˆÂ´{count+â†©Â¯1+â‰ dâ†â¥Šğ•©â‹„DCâŒœd}âŸ©âŸ©â‹„depthâ†DCğ•©
    ğ•© (2âŒŠdepth)â—¶(â‹ˆâ—‹â‹ˆ)â€¿(Conformâ—¶âŸ¨ErrË™,â‹ˆâ—‹â¥ŠâŸ©)â€¿{
      Failâ†{ğ•Šâ€¿0}
      # ğ• is parent traversal; ğ•© is current components of ind and val
      Travâ†(IsArray 0âŠ‘âŠ¢)â—¶âŸ¨â‹ˆ, ConformÂ´âˆ˜âŠ¢â—¶Failâ€¿{
        Parentâ†ğ• â‹„ nâ†â‰ 0âŠ‘aâ†â¥ŠâŒœğ•© â‹„ jâ†Â¯1
        Childâ†TravâŸœ{ğ•©âŠ¸âŠ‘âŒœa}
        { j+â†©1 â‹„ fâ†nâŠ¸â‰¤â—¶âŸ¨ğ•ŠË™âŠ¸Child,ParentË™âŸ©j â‹„ F 0 }
      }âŸ©
      next â† 0 Trav ğ•¨â€¿ğ•©
      res â† {nâ€¿oâ†Nextğ•©â‹„nextâ†©nâ‹„o}âŒœ â†•count
      (next=fail)â—¶âŸ¨0âŠ¸âŠ‘âŒœ â‹ˆ 1âŠ¸âŠ‘âŒœ, ErrË™âŸ© res
    } v
  }âŸ(1-IsErrâˆ˜âŠ¢)

  _insert â† {
    rootâ†ğ•—
    iâ€¿vâ†ğ•¨
    Set1â†ğ•¨âŠ¸{
      ğ•©â†©ToArrayğ•©
      sâ†â‰¢ğ•©â‹„lâ†â‰ dâ†â¥Šğ•©
      "Cannot modify fill with Structural Under"!1âˆ§Â´@âŠ¸>âŒœi
      glâ†l GroupLen i â‹„ vâŠËœâ†©gl GroupOrd i
      jâ†0â‹„Advâ†{(j+â†©ğ•©)-1}âŠ‘vË™
      CMâ†"âŒ¾: Incompatible result elements in structural Under"!Match
      sâ¥Š(â†•l)2âŠ¸âŒŠâ—¶âŸ¨âŠ‘âŸœd,Adv,Adv{(ğ•¨CM(j-ğ•©)âŠ¸+âŠ‘vË™)âŒœâ†•ğ•©-1â‹„ğ•¨}âŠ¢âŸ©Â¨gl
    }
    _at_ â† {(â†•â‰ ğ•©)ğ”½âŸ((ğ”¾ğ•©)=âŠ£)Â¨ğ•©}
    Set â† 0âŠ¸{ (ğ•¨â‰¥â‰ root)â—¶âŸ¨â‰¢â¥Š(1+ğ•¨)âŠ¸ğ•Š_at_(ğ•¨âŠ‘rootË™)âˆ˜â¥Š, Set1âŸ© ğ•© }
    IsArrayâˆ˜rootâ—¶âŸ¨0âŠ‘vË™, SetâŸ© _fillBy_ âŠ¢ ğ•©
  }

  {
    valâ†ğ•¨ğ”½â—‹ğ”¾ğ•©
    rootâ€¿indâ€¿d â† IsStructâ—¶âŸ¨0â€¿Errâ€¿0,0â€¿2â€¿3âŠ1âŠ‘DecomposeâŸ© ğ•˜ SFNâŠ¸{ğ•ğ•©} InitS ğ•©
    IsErrâ—¶âŸ¨root _insertâŸœ(ğ•©Ë™), {ğ•val}Â·Inverseğ”¾Ë™âŸ© valâ€¿d GetInserts ind
  }
}

â‰¡ â† Depth          âŠ˜ Match
â‰¢ â†© IsArrayâ—¶(â†•0)â€¿â‰¢ âŠ˜ (1-Match)

IF â† âŠ¢âŠ£!âˆ˜â‰¡  # Intersect fill
IEFâ† (0<â‰ )â—¶âŸ¨âŠ¢_fillBy_ Fill, âŠ¢_fillBy_ IFÂ´âŸ©âˆ˜â¥Š
HasFill â† 0=Â·FillâŠ¢_fillBy_(@âŸ(3â‰¤Typeâˆ˜âŠ£))âŸœ(â†•0)
_fillMerge_ â† {(0<â‰ âˆ˜â¥Š)â—¶âŸ¨(ğ”¾â—‹â‰¢â¥ŠâŸ¨âŸ©Ë™)_fillBy_âŠ¢âŸœFillâŸHasFill, ğ”½ âŠ£_fillBy_âŠ¢ IEFâŸ©}
Mergeâ†{
  câ†â‰¢0âŠ‘â¥Šğ•©
  (">ğ•©: Elements of ğ•© must have matching shapes" ! c =â—‹â‰ â—¶0â€¿MatchS â‰¢)âŒœâ¥Šğ•©
  (DeshapeâŒœğ•©)âŠ‘ËœâŒœcâ¥Šâ†•1Ã—Â´c
}_fillMerge_âˆ¾âŸIsArray

JoinToâ†(1<âŒˆâ—‹=)â—¶(âˆ¾â—‹â¥Š)â€¿{
  aâ†1-Ëœğ•¨âŒˆâ—‹=ğ•©
  sâ†ğ•¨â‹ˆâ—‹â‰¢ğ•©
  "ğ•¨âˆ¾ğ•©: Rank of ğ•¨ and ğ•© must differ by at most 1" ! 1Ã—Â´(aâ‰¤â‰ )âŒœs
  câ†(â‰ -aË™)âŠ¸â†“âŒœs
  "ğ•¨âˆ¾ğ•©: Cell shapes of ğ•¨ and ğ•© must match" ! MatchSÂ´c
  lâ†0+Â´(a<â‰ )â—¶1â€¿(0âŠ‘âŠ¢)âŒœs
  (âŸ¨lâŸ©âˆ¾0âŠ‘c)â¥Šğ•¨âˆ¾â—‹â¥Šğ•©
}â—‹ToArray _fillBy_ IF

_s0â†{sâ†ğ•¨â‹„Fâ†ğ”½â‹„{oâ†sâ‹„s Fâ†©ğ•©â‹„o}âŒœğ•©}
Strideâ†Reverse 1 Ã—_s0 Reverse
JoinMâ†{
  # Multidimensional
  nâ†â‰ zâ†â¥Šğ•© â‹„ sâ†â‰¢âŒœz â‹„ râ†=ğ•©
  shâ†â‰¢ğ•© â‹„ pâ†1 â‹„ iâ†jâ†heâ†<0
  (Stride sh){
    qâ†ğ•¨
    aâ†ğ•©âŠ‘sh
    hâ†-âŸœ(1-Ëœ0âŒˆÂ´rr)âŒœrrâ†=âŒœzâŠËœqâŠ¸Ã—âŒœâ†•a
    "âˆ¾ğ•©: Incompatible element ranks" ! 1Ã—Â´0âŠ¸â‰¤âŒœh
    hlâ†â‰ ihâ†qâŠ¸Ã—âŒœ/h
    sfâ†sâŠËœâ¥Š((aÃ—q)âŠ¸Ã—âŒœâ†•p)+âŒœih+âŒœâ†•q
    siâ†â¥ŠheâŠ£âŒœâ†•hlÃ—q
    "âˆ¾ğ•©: Incompatible element ranks" ! 1Ã—Â´si<âŸœâ‰ Â¨sf
    mâ†siâŠ‘Â¨sf
    lfâ†mâŠËœqâŠ¸Ã—âŒœâ†•hl
    "âˆ¾ğ•©: ğ•© element shapes must be compatible" ! m MatchS â¥Š(â†•p)âŠ¢âŒœlfâŠ£âŒœâ†•q
    k â† / lâ†{iâ†Â¯1â‹„âŠ¢â—¶1â€¿{(i+â†©ğ•©)âŠ‘lf}âŒœh}
    c â† (â†•â‰ k)-Â¨k âŠ 0+_s0 l
    heâ†© he +âŒœ h
    i â†© (i Ã—âŒœ kâŠl) +Â¨ iâŠ¢âŒœc
    j â†© j Ã—âŸœaâŠ¸+âŒœ k
    pÃ—â†©a
  }Â¨â†•r
  dâ†(=0âŠ‘z)-0âŠ‘heâ†©â¥Šhe
  "âˆ¾ğ•©: ğ•© element trailing shapes must match" ! he MatchS (=-dË™)âŒœz
  Gâ†(DeshapeâŒœz){ğ•¨âŠ‘ğ•©âŠ‘ğ•—}Â¨
  i (0<d)â—¶Gâ€¿{
    Trâ†(â‰ -dË™)âŠ¸â†“â‹„tâ†Tr 0âŠ‘s
    "âˆ¾ğ•©: ğ•© element trailing shapes must match" ! 1Ã—Â´(t MatchS Tr)âŒœs
    tiâ†tâ¥Šâ†•tpâ†Ã—Â´tâ‹„(ğ•¨tpâŠ¸Ã—âŠ¸+âŒœti)Gğ•©âŠ£âŒœti
  } j
}
Joinâ†(2âŒŠ=)â—¶âŸ¨
  Merge, (1Ã—Â´(1â‰¥=)âŒœ)â—¶JoinMâ€¿Join1, JoinM
âŸ©_fillMerge_{
  râ†â‰ ğ•¨ â‹„ dâ†â‰ ğ•©
  "âˆ¾ğ•©: empty ğ•© fill rank must be at least argument rank" ! dâ‰¥r
  (â†•d)(râ‰¤âŠ£)â—¶âŸ¨âŠ‘âŸœğ•¨âŠ¸Ã—,âŠ¢âŸ©Â¨ğ•©
} âŠ£ "âˆ¾ğ•©: ğ•© must be an array"!IsArray

_takeDropâ†{
  take â† 1 - ğ•—
  gl   â† ğ•—âŠ‘"â†‘"â€¿"â†“"
  noop â† ğ•—âŠ‘âŸ¨1-=âŸœ|, 1-0âŠ¸=âŸ©
  inds â† ğ•—âŠ‘âŸ¨
    { ğ”½âŸ(ğ•¨âŠ¸<)aâ†|ğ•© â‹„ (0<ğ•©)â—¶âŸ¨Â¯âˆâŸ(<âŸœ0)âŒœ+âŸœ(ğ•¨+ğ•©)âŒœ, Â¯âˆâŸ(ğ•¨âŠ¸â‰¤)âŒœâŸ©â†•a }
    { ğ”½ â‹„ 0âŠ¸<â—¶âŸ¨â†•0âŒˆ+,<âˆ˜âŠ¢+âŒœÂ·â†•0âŒˆ-âŸ© }
  âŸ©
  pre â† "ğ•¨"âˆ¾glâˆ¾"ğ•©: ğ•¨ must "
  ernk â† preâˆ¾"have rank at most 1"
  eint â† preâˆ¾"consist of integers"
  IsArrayâˆ˜âŠ£â—¶{
    eint ! Int ğ•¨
    pâ†0â‰¤ğ•¨
    lâ†ğ•¨pâ—¶âŸ¨0âŒˆ+,âŒŠâŸ©â‰ ğ•©
    Fâ†ğ•©{(Fillğ•—)Ë™âŒœâ†•ğ•©}
    kâ†1â‹„Sâ†âŠ¢ â‹„ ğ•¨âŠ¸{kÃ—Â´â†©câ†1 Cellğ•© â‹„ Sâ†©(âŸ¨(0âŒˆ(â‰ ğ•©)-âŠ¢)âŸ(1-take)|ğ•¨âŸ©âˆ¾c)âŠ¸â¥Š}âŸ(1<=) ğ•©
    S ((|âˆ˜ğ•¨-â‰ âˆ˜ğ•©){ğ•©pâ—¶âŸ¨âˆ¾Ëœ,âˆ¾âŸ©Fğ•¨Ã—k}âŸ(>âŸœ0)âŠ¢)âŸtake (lÃ—k) (take=p)â—¶â†“â€¿â†‘ â¥Šğ•©
  }â€¿{
    ernk ! 1â‰¥=ğ•¨
    ğ•¨ â†© â¥Šğ•¨
    eint ! 1Ã—Â´IntâŒœğ•¨
    r â† â‰ ğ•¨
    s â† r {(1âŒœâˆ˜â†•ğ•¨-â‰ ğ•©)âˆ¾ğ•©}âŸ(>âŸœâ‰ ) â‰¢ğ•©
    _c â† { (Ã—âŸœğ•—âŒœğ•¨) +âŒœ ğ•© }
    iâ†<0 â‹„ kâ†1 â‹„ UIkâ†{ i (kÃ—ğ•¨)_câ†© k â†•âŠ¸(ğ•¨_c)âŸ(1-=âŸœ1) ğ•© â‹„ kâ†©1 â‹„ â‰ ğ•© }
    doFilâ†0
    sh â† (râ†‘s) Noopâ—¶{kÃ—â†©ğ•¨â‹„ğ•¨}â€¿(âŠ£ UIk {ğ•©â‹„doFilâ†©1}_inds)Â¨ ğ•¨
    (0<=i)â—¶(sâŠ¸â¥Š)â€¿{
      sh âˆ¾â†© t â† râ†“s
      {i ğ•©_câ†© â†•ğ•©}âŸ(1-1âŠ¸=) kÃ—Â´t
      Sel â† âŠ‘âŸœ(â¥Šğ•©)
      ğ•©{Selâ†©0âŠ¸â‰¤â—¶âŸ¨(Fillğ•¨)Ë™,SelâŸ©}âŸâŠ¢doFil
      SelâŒœ sh â¥Š i
    } ğ•©
  }_fillBy_âŠ¢ âŸœ ToArray
}
Take â† 0 _takeDrop
Drop â† 1 _takeDrop

ShiftCheckâ†{
  "Â« or Â»: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  sâ†1 Cell ğ•©
  ğ•¨ {  # Only if called with two arguments
    "Â« or Â»: ğ•¨ must not have higher rank than ğ•©" ! 0â‰¤ğ•©
    "Â« or Â»: Rank of ğ•¨ must be at least rank of ğ•© minus 1" ! 1â‰¥ğ•©
    "Â« or Â»: ğ•¨ must share ğ•©'s major cell shape" ! s MatchS (1-ğ•©)â†“â‰¢ğ•¨
  } ğ•©-â—‹=ğ•¨
  (ğ•¨1âŠ˜{(ğ•©â‰¤â—‹=âŠ¢)â—¶1â€¿â‰ ğ•¨}ğ•©) Ã—Â´ s
}
ShiftBeforeâ†{
  nâ†ğ•¨ ShiftCheck ğ•©
  mâ†nâŒŠlâ†â‰ dâ†â¥Šğ•©
  (â‰¢ğ•©) â¥Š (ğ•¨{(Fillğ•©)âŒœâ†•ğ•¨}âŸ(0<l)âŸœğ•©âŠ˜(â†‘âŸœDeshapeËœ)m) âˆ¾ (l-m)â†‘d
} _fillBy_ (âŠ¢âŠ˜IF)
ShiftAfterâ†{
  nâ†ğ•¨ ShiftCheck ğ•©
  mâ†nâŒŠlâ†â‰ dâ†â¥Šğ•©
  (â‰¢ğ•©) â¥Š (mâ†“d) âˆ¾ ğ•¨{(Fillğ•©)âŒœâ†•ğ•¨}âŸ(0<l)âŸœğ•©âŠ˜(nâŠ¸-âŠ¸â†“âŸœDeshapeËœ)m
} _fillBy_ (âŠ¢âŠ˜IF)

RangeCheck â† "â†•ğ•©: ğ•© must consist of natural numbers"!Nat
Range â† IsArrayâ—¶(â†•âŠ£RangeCheck)â€¿{
  "â†•ğ•©: ğ•© must be a number or list"!1==ğ•© â‹„ RangeCheckâŒœğ•©
  (0âŒœğ•©)Fill 0âŠ¸FillâŒœ(0<1Ã—Â´âŠ¢)â—¶âŸ¨â¥ŠâŸœâŸ¨âŸ©,(<âŸ¨âŸ©)â‹ˆâŠ¸âˆ¾âŒœÂ´â†•âŒœâŸ©ğ•©
}
Windowsâ†{
  "ğ•¨â†•ğ•©: ğ•¨ must have rank at most 1" ! 1â‰¥=ğ•¨
  râ†â‰ ğ•¨â†©Deshape ğ•¨
  ğ•¨{
    "ğ•¨â†•ğ•©: Length of ğ•¨ must be at most rank of ğ•©" ! râ‰¤=ğ•©
    "ğ•¨â†•ğ•©: ğ•¨ must consist of natural numbers" ! Ã—Â´NatâŒœğ•¨
    sâ†â‰¢ğ•©
    lâ†(râ†‘s)(1+-)Â¨ğ•¨
    "ğ•¨â†•ğ•©: Window length ğ•¨ must be at most axis length plus one" ! Ã—Â´0âŠ¸â‰¤âŒœl
    kâ†1Ã—Â´tâ†râ†“s
    Win â† {
      str â† Reverse Ã—`âŸ¨kâŸ©âˆ¾sâŠËœ{ğ•©âŠ¸-âŒœâ†•ğ•©}r-1
      (â¥Šğ•©) âŠËœ k +âŒœâŸœ(tâ¥Šâ†•)ËœâŸ(1-=âŸœ1) l +âŒœâ—‹(+âŒœÂ´str{ğ•¨âŠ¸Ã—âŒœâ†•ğ•©}Â¨âŠ¢) ğ•¨
    }
    ğ•¨ (0<(kÃ—Â´l)Ã—Â´âŠ£)â—¶âŸ¨{âŸ¨âŸ©â¥ŠËœlâˆ¾ğ•¨âˆ¾t},WinâŸ© ğ•©
  }_fillBy_âŠ¢âŸ(0<r)ğ•©
}

EncCell â† {
  fâ†ğ•¨â†‘â‰¢ğ•© â‹„ câ†1Ã—Â´sâ†ğ•¨Cellğ•© â‹„ dâ†â¥Šğ•©
  iâ†sâ¥Šâ†•c
  Eâ†{eâ†Fill dâŠ¢_fillBy_(0âŸ(3â‰¤Type)âŠ£)â†•0 â‹„ (dâŠ£_fillBy_âŠ¢ËœeË™âŒœi)Fillğ•©}
  fâ¥Š EâŸ(0=â‰ ) {dâŠËœ(cÃ—ğ•©)âŠ¸+âŒœi}âŒœâ†•1Ã—Â´f
}
_cells â† {
  Fâ†ğ”½ â‹„ _mâ†{ğ”½âŒœâŠ˜(ğ”½Â¨)_fillByPure_ğ”½â—‹(1âŠ¸EncCell)}
  Dâ†{ "Ë˜: Argument lengths don't agree" ! ğ•©=â—‹â‰ ğ•¨ â‹„ ğ•¨ F _m ğ•© }
  Merge ğ•¨ 2âŠ¸Ã—âŠ¸+â—‹(0<=)â—¶âŸ¨<F,{ğ•¨Ë™âŠ¸F _mğ•©},{FâŸœ(ğ•©Ë™)_mğ•¨},DâŸ© ğ•©
}
_insertâ†{
  "Ë: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  Fâ†ğ”½
  Id â† {
    s â† 1â†“â‰¢ğ•©
    JoinSh â† {"Ë: Identity does not exist"!0<â‰ ğ•¨ â‹„ ğ•¨Ã—âŸœ(0âŠ¸<)Â¨â†•â‰ ğ•¨}
    s (1-IsJoinâˆ˜âŠ¢)â—¶âŸ¨JoinShâ¥Šğ•©Ë™, ReshapeâŸœIdentityâŸ© f
  }
  ğ•¨ (0<â‰ )âŠ˜1â—¶Idâ€¿{ğ•¨FÂ´1 EncCell ğ•©} ğ•©
}

ReshapeT â† "âˆ˜âŒŠâŒ½â†‘"_glyphLookup_(â†•5)
Reshapeâ†{
  "ğ•¨â¥Šğ•©: ğ•¨ must have rank at most 1" ! 1â‰¥=ğ•¨
  sâ†Deshape ğ•¨
  spâ†0+Â´pâ†(1-Nat)âŒœs
  "ğ•¨â¥Šğ•©: ğ•¨ must consist of natural numbers" ! 1â‰¥sp
  nâ†â‰ dâ†Deshape ğ•©
  lâ†spâ—¶(1Ã—Â´âŠ¢)â€¿{
    lpâ†1Ã—Â´pâŠ£â—¶âŠ¢â€¿1Â¨ğ•©
    "ğ•¨â¥Šğ•©: Can't compute axis length when rest of shape is empty" ! 0<lp
    iâ†0+Â´pÃ—Â¨â†•â‰ p
    tâ†ReshapeT iâŠ‘s
    "ğ•¨â¥Šğ•©: ğ•¨ must consist of natural numbers or âˆ˜ âŒŠ âŒ½ â†‘" ! t<4
    Chk â† âŠ¢ âŠ£ "ğ•¨â¥Šğ•©: Shape must be exact when reshaping with âˆ˜" ! âŒŠâŠ¸=
    aâ†(2âŒŠt)â—¶âŸ¨Chk,âŒŠ,âŒˆâŸ©nÃ·lp
    sâ†©pâŠ£â—¶âŠ¢â€¿aÂ¨s
    {dâˆ¾â†©(Fill d)âŒœâ†•ğ•©-nâ‹„n}âŸ(nâŠ¸<)âŸ(3=t)lpÃ—a
  } s
  sâ¥Š{
    "ğ•¨â¥Šğ•©: Can't produce non-empty array from empty ğ•©" ! 0<n
    l >âŸœâ‰ â—¶âŸ¨â†‘, âŠ£(âŠ¢âˆ¾-âŸœâ‰ â†‘âŠ¢)Ã·âŸœ2âŠ¸{ğ•¨ğ•ŠâŸœ(âˆ¾Ëœ)âŸ(>âŸœâ‰ )ğ•©}âŸ© ğ•©
  }_fillBy_âŠ¢âŸ(1-l=n) d
}

_groupâ†{
  "âŠ”: Grouping argument must consist of integers" ! 1Ã—Â´IntâŒœğ•©
  "âŠ”: Grouping argument values cannot be less than Â¯1" ! 1Ã—Â´Â¯1âŠ¸â‰¤âŒœğ•©
  GLâ†GroupLenâ‹„ğ•©â†©ğ•¨(-ËœâŸœâ‰ {GLâ†©(ğ•¨âŠ‘ğ•©)GLâŠ¢â‹„ğ•¨â†‘ğ•©}âŠ¢)âŸ(0âŠ˜âŠ£)ğ•©
  dâ†(lâ†GLğ•©)GroupOrdğ•©
  iâ†0â‹„(ğ”½dâŠËœ{(i+â†©ğ•©)âŠ¢iâŠ¸+âŒœâ†•ğ•©})âŒœl
}
GroupIndsâ†{
  "âŠ”ğ•©: ğ•© must be a list" ! 1==ğ•©
  Gâ†âŠ¢_group
  (1<â‰¡)â—¶âŸ¨
    â†•âˆ˜0             Fill G
    ((âŠ¢Fillâ¥ŠâŸœâŸ¨âŸ©)0âŒœ) Fill (<<âŸ¨âŸ©) âˆ¾âŒœâŒœÂ´ {âŠâŸœ(â¥ŠRangeâ‰¢ğ•©)âŒœ Gâ¥Šğ•©}âˆ˜ToArrayâŒœ
  âŸ© ğ•©
}
Group1â†{
  nâ†=ğ•¨
  "ğ•¨âŠ”ğ•©: Rank of simple ğ•¨ must be at most rank of ğ•©" ! nâ‰¤=ğ•©
  ldâ†(â‰¢ğ•¨)-Â¨nâ†‘sâ†â‰¢ğ•©
  drâ†(1=n)â—¶âŸ¨0,1=0âŠ¸âŠ‘âŸ©ld
  "ğ•¨âŠ”ğ•©: Lengths of ğ•¨ must equal to ğ•©, or one more only in a rank-1 component" ! drâ—¶âŸ¨1Ã—Â´0âŠ¸=âŒœ,1âŸ©ld
  SXâ†((n==ğ•©)â—¶{câ†1Ã—Â´tâ†nâ†“sâ‹„ğ•©âŠËœ(câŠ¸Ã—âŠ¸+)âŒœâŸœ(tâ¥Šâ†•c)}â€¿{âŠâŸœğ•©} â¥Šğ•©)âˆ˜âŠ£ _fillBy_ âŠ¢âŸœğ•©
  (SXâŸ¨âŸ©) Fill dr SX _group â¥Šğ•¨
}â—‹ToArray
GroupMâ†{
  "ğ•¨âŠ”ğ•©: Compound ğ•¨ must be a list" ! 1==ğ•¨
  nâ†0+Â´râ†=âŒœğ•¨
  "ğ•¨âŠ”ğ•©: Total rank of ğ•¨ must be at most rank of ğ•©" ! nâ‰¤=ğ•©
  ldâ†(Join1â‰¢âŒœğ•¨)-Â¨nâ†‘â‰¢ğ•©
  "ğ•¨âŠ”ğ•©: Lengths of ğ•¨ must equal to ğ•©, or one more only in a rank-1 component" ! 1Ã—Â´ld((0â‰¤âŠ£)Ã—â‰¤)Â¨r/1âŠ¸=âŒœr
  drâ†râŒŠÂ¨(0+_s0 r)âŠldâˆ¾âŸ¨0âŸ©
  lâ†dr-ËœâŸœâ‰ Â¨ğ•¨â†©DeshapeâŒœğ•¨ â‹„ LSâ†âˆ¾âŸœ(n Cell ğ•©) Reshape ğ•©Ë™
  Sâ†âŠâŸœ(LSâŸ¨1Ã—Â´lâŸ©)
  (LS 0âŒœğ•¨) Fill dr (1â‰ â‰ âˆ˜âŠ¢)â—¶âŸ¨
    S _groupâ—‹(0âŠ¸âŠ‘)
    SâŒœ Â·+âŒœâŒœÂ´ (Stride l) {ğ•¨âŠ¸Ã—âŒœâŒœğ•©}Â¨ âŠ¢_groupÂ¨
  âŸ© ğ•¨
}
GroupGenâ†{
  "ğ•¨âŠ”ğ•©: ğ•© must be an array" ! IsArray ğ•©
  ğ•¨(2â‰¤â‰¡ğ•¨)â—¶Group1â€¿GroupMğ•©
}

GroupIndsInv â† {
  IA 1==ğ•©
  IX 1Ã—Â´(1==)âŒœğ•©
  jâ†Join1 ğ•©
  IA 1Ã—Â´(1â‰ =)âŒœj
  IX 1Ã—Â´NatâŒœj
  {IXğ•¨<ğ•©â‹„ğ•¨}Â´âŸ(0<â‰ )âŒœğ•©
  gâ†GroupLen j
  IX 1Ã—Â´â‰¤âŸœ1âŒœg
  oâ†/1âŠ¸-âŒœg
  (PermInv jâˆ¾o)âŠ(/â‰ âŒœğ•©)âˆ¾Â¯1âŒœo
}
GroupInv â† {
  IA 1==ğ•¨
  IA 1Ã—Â´NatâŒœğ•¨
  lâ†GroupLenğ•¨
  IX l=â—‹â‰ ğ•©
  IX l MatchS â‰ âŒœğ•©
  (PermInv l GroupOrd ğ•¨) âŠ Join ğ•©
}

ValidateRanksâ†{
  "â‰ or âš‡: ğ”¾ result must have rank at most 1" ! 1â‰¥=ğ•©
  ğ•©â†©Deshapeğ•©
  "â‰ or âš‡: ğ”¾ result must have 1 to 3 elements" ! (1âŠ¸â‰¤Ã—â‰¤âŸœ3)â‰ ğ•©
  "â‰ or âš‡: ğ”¾ result must consist of integers" ! 1Ã—Â´IntâŒœğ•©
  ğ•© âŠËœ (â‰ ğ•©)âŠ¸(-+1-ËœâŒŠâˆ˜Ã·ËœÃ—âŠ£)âŒœ ğ•¨
}
_ranks â† {âŸ¨2âŸ©âŠ˜âŸ¨1,0âŸ© ValidateRanks ğ”½}
_depthOp_â†{
  negâ†0âŠ¸>âŒœnâ†ğ•¨ğ”¾_ranksğ•© â‹„ Fâ†ğ”½ â‹„ Bâ†{ğ•}âŠ˜{ğ•¨Ë™âŠ¸ğ•}
  fbâ†((3â‰¤Type)â—¶1â€¿IsPureğ•—)âŠ‘{ğ•˜â‹„ğ”½}â€¿{ğ”½_fillBy_ğ”¾}
  _tfâ†{ğ•—âŒœ_fb_ğ•—} â‹„ _efâ†{ğ•—_eachd _fb_ ğ•—}
  _dâ†{
    râ†0 â‹„ GRâ†ğ•—{ğ•©â‹„grâ†©0â‹„Râ†©(ğ•—+Â¨neg)_d}
    Twâ€¿Txâ†âŸ¨0âŸ©âŠ¸âˆ¾âŸ(2>â‰ )neg{(ğ•¨Ã—0â‰¤ğ•©)âŠ‘âŸ¨(0âŒˆğ•©)<â‰¡,0âŸ©}Â¨ğ•—
    (2Ã—Tw)âŠ¸+âŸœTxâ—¶âŸ¨
      F, {GR 0â‹„(ğ•¨ B r)_tfğ•©}, {GR 0â‹„RâŸœ(ğ•©Ë™)_tfğ•¨}, {GR 0â‹„ğ•¨R _efğ•©}
    âŸ©
  }
  ğ•¨ n _d ğ•©
}
_rankOp_â†{
  Minâ†<â—¶âŠ¢â€¿âŠ£
  kâ†ğ•¨(â‹ˆâ—‹= (0â‰¤âŠ¢)â—¶âŸ¨MinâŸœ-,âŠ£-MinâŸ©Â¨ ğ”¾_ranks)ğ•©
  Encâ†(>âŸœ0Ã—1+â‰¥âŸœ=)â—¶âŸ¨<âŠ¢,EncCell,<âŒœ_fillBy_<âŠ¢âŸ©
  Merge ((0âŠ‘k)Encğ•¨) ğ”½_each ((1-Ëœâ‰ )âŠ¸âŠ‘k)Encğ•©
}

_repeat_â†{
  Fâ†ğ”½ â‹„ bâ†ğ•¨{ğ•âŠ£}Ë™âŠ˜{ğ•¨Ë™{ğ”½ğ•âŠ£}}0
  nâ†ğ•¨ğ”¾ğ•©
  Multiâ†{
    lâ†uâ†0
    {"âŸ: ğ•¨ğ”¾ğ•© must consist of integers"!Intğ•©â‹„lâŒŠâ†©ğ•©â‹„uâŒˆâ†©ğ•©}_perv n
    iâ†âŸ¨ğ•©âŸ©â‹„Pâ†BâŠ¸{ğ•`iâˆ¾â†•ğ•©}
    posâ†f P u
    negâ†f 0âŠ¸<â—¶âŸ¨i,InverseâŠ¸PâŸ© -l
    (|âŠ‘<âŸœ0âŠ‘posâ€¿negË™)_perv n
  }
  (Nat n)â—¶Multiâ€¿{ğ•©(B f)âˆ˜âŠ¢Â´â†•n} ğ•©
}

Ã· â†© Ã· _perv
â‹† â†© â‹† _perv
âˆš â† â‹†âŸœ(Ã·2)   âŠ˜ (â‹†âŸœÃ·Ëœ)
| â† (|       âŠ˜ (>â—‹|â—¶{ğ•©-ğ•¨Ã—âŒŠğ•©Ã·ğ•¨}â€¿(+âŸ(<âŸœ0â—¶âŸ¨0âŠ¸>,0âŠ¸<âŸ©))) ) _perv
âŒŠ â†© (âŒŠ       âŠ˜ (âŠ£âŸ<)) _perv
âŒˆ â†© (-âˆ˜âŒŠâˆ˜-   âŠ˜ (âŠ£âŸ>)) _perv
âˆ§ â† â‹âŠ¸âŠ      âŠ˜ (Ã— _perv)
âˆ¨ â† â’âŠ¸âŠ      âŠ˜ ((+-Ã—) _perv)
Ã— â†© (0âŠ¸(<->) âŠ˜ Ã—) _perv
< â†© <        âŠ˜ ((1-â‰¥) _perv)
> â†© Merge    âŠ˜ ((1-â‰¤) _perv)
â‰  â†© â‰         âŠ˜ ((1-=) _perv)
= â†© =        âŠ˜ (= _perv)
â‰¥ â† !âˆ˜"â‰¥: Needs two arguments" âŠ˜ (â‰¥ _perv)
â‰¤ â†© !âˆ˜"â‰¤: Needs two arguments" âŠ˜ (â‰¤ _perv)
+ â†© + _perv
- â†© - _perv
Â¬ â† 1+-

âŠ â† SelfClas       âŠ˜ (1 _search)

ProgressiveIndexOf â† 0 Fill {
  câ†1-Ëœ=ğ•¨
  "âŠ’: Rank of ğ•¨ must be at least 1" ! 0â‰¤c
  "âŠ’: Rank of ğ•© must be at least cell rank of ğ•¨" ! câ‰¤=ğ•©
  ğ•¨âŠâ—‹(â‹ˆÂ¨âŸœ(â‰¢â¥ŠOccurrenceCountâˆ˜â¥Š) ğ•¨âŠ¸âŠ)ğ•©
}

â¼ â† {Inverse ğ•—}
IsConstant â† (3â‰¤Type)â—¶âŸ¨1 â‹„ DIsConstâˆ˜{Decomposeğ•©}âŠ¢âŸ©
AtopInverse â† {(ğ•ğ•)âŠ˜(ğ•âŸœğ•)}â—‹{Inverseğ•©}
TrainInverse â† {
  tâ€¿fâ€¿gâ€¿hâ†ğ•©
  Kâ†Â¬IsConstant
  f Kâˆ˜âŠ£â—¶âŸ¨{ğ•â¼{ğ•¨ğ”½ğ”¾ğ•©}(ğ•¨Gâ¼âŠ¢)},Kâˆ˜âŠ¢â—¶âŸ¨{ğ•â¼ğ•©G{SwapInverseğ•—}âŠ¢},INFË™âŸ©âŸ© h
}
FuncInverse â† (0âŠ¸âŠ‘ âŠ£â—¶âŸ¨
  {PrimInverseğ•©} 1âŠ¸âŠ‘                     # 0 primitive
  (!âˆ˜"Cannot currently invert blocks")Ë™  # 1 block
  1âŠ¸âŠ‘ AtopInverse 2âŠ¸âŠ‘                    # 2-train
  TrainInverse                           # 3-train
  1âŠ¸âŠ‘    {ğ•ğ•¨}âŸœ{Mod1Inverseğ•©} 2âŠ¸âŠ‘         # 4 1-modifier
  1â€¿3âŠ¸âŠ {ğ•Â´ğ•¨}âŸœ{Mod2Inverseğ•©} 2âŠ¸âŠ‘         # 5 2-modifier
âŸ© âŠ¢) {Decomposeğ•©}
Inverse â† Typeâ—¶(3â€¿1â€¿2/{âŠ¢âŠ£ğ•©IXâˆ˜â‰¡âŠ¢}â€¿FuncInverseâ€¿(!âˆ˜"Cannot invert modifier"))

IA â† "â¼: Inverse failed"âŠ¸!
IX â† "â¼: Inverse does not exist"âŠ¸!
INFâ† "â¼: Inverse not found"!0Ë™
_invChk_ â† {iâ†ğ•¨ğ”½ğ•©â‹„IX ğ•©â‰¡ğ•¨ğ”¾iâ‹„i}
â†• â†© Range          âŠ˜ Windows
âŠ â†© FirstCell      âŠ˜ Select _fillBy_ âŠ¢
âŒ½ â† Reverse        âŠ˜ Rotate
â†‘ â†© Prefixes       âŠ˜ Take
â†“ â†© Suffixes       âŠ˜ Drop
PrimInverse â† INF _lookup_ âŸ¨
  '+', +âŠ˜(-Ëœ)
  '-', -
  'Ã—', âŠ¢_invChk_Ã—âŠ˜(Ã·Ëœ)
  'Ã·', Ã·
  'â‹†', Log _perv
  'âˆš', Ã—ËœâŠ˜(â‹†Ëœ)
  'âˆ§', âŠ¢_invChk_âˆ§âŠ˜(Ã·Ëœ)
  'âˆ¨', âŠ¢_invChk_âˆ¨âŠ˜(-ËœÃ·1-âŠ£)
  'Â¬', Â¬
  'â‰ ', {Bâ†0âŠ¸=âˆ¨1âŠ¸=â‹„IX Bğ•©â‹„IA Bğ•¨â‹„ğ•©â‰ ğ•¨} _perv
  '<', {IX IsArrayğ•©â‹„IX 0==ğ•©â‹„0âŠ‘â¥Šğ•©}âŠ˜(IAâˆ˜0)
  'âŠ¢', âŠ¢
  'âŠ£', âŠ¢âŠ˜(âŠ¢âŠ£IXâˆ˜â‰¡)
  'âˆ¾', IAâˆ˜0 âŠ˜ {dâ†ğ•©-â—‹=ğ•¨â‹„IX(0âŠ¸â‰¤âˆ§â‰¤âŸœ1)dâ‹„lâ†dâ—¶1â€¿â‰ ğ•¨â‹„IX lâ‰¤â‰ ğ•©â‹„IX ğ•¨â‰¡dâ—¶âŸ¨âŠ,lâŠ¸â†‘âŸ©ğ•©â‹„lâ†“ğ•©}
  'â‰', {IX  1 =â‰ ğ•©â‹„ âŠğ•©} âŠ˜ {IX  2 =â‰ ğ•©â‹„IX ğ•¨â‰¡ âŠğ•©â‹„1âŠğ•©}
  'â‹ˆ', {IX âŸ¨1âŸ©â‰¡â‰¢ğ•©â‹„0âŠ‘ğ•©} âŠ˜ {IX âŸ¨2âŸ©â‰¡â‰¢ğ•©â‹„IX ğ•¨â‰¡0âŠ‘ğ•©â‹„1âŠ‘ğ•©}
  'â†‘', Â¯1âŠ¸âŠ‘_invChk_â†‘ âŠ˜ (IAâˆ˜0)
  'â†“',  0âŠ¸âŠ‘_invChk_â†“ âŠ˜ (IAâˆ˜0)
  'â†•', â‰¢_invChk_â†• âŠ˜ (IAâˆ˜0)  # Should trace edge and invChk
  'âŒ½', âŒ½ âŠ˜ (-âŠ¸âŒ½)
  'â‰', TransposeInv âŠ˜ ReorderAxesInv
  '/', IndicesInv âŠ˜ (IAâˆ˜0)
  'âŠ”', GroupIndsInv âŠ˜ GroupInv
âŸ©
SwapInverse â† INF _lookup_ âŸ¨
  '+', Ã·âŸœ2âŠ˜(-Ëœ)
  '-', IAâˆ˜0âŠ˜+
  'Ã—', âˆšâŠ˜(Ã·Ëœ)
  'Ã·', IAâˆ˜0âŠ˜Ã—
  'â‹†', IAâˆ˜0âŠ˜âˆš
  'âˆš', IAâˆ˜0âŠ˜(Ã·Log)
  'âˆ§', âˆšâŠ˜(Ã·Ëœ)
  'âˆ¨', (Â¬âˆšâˆ˜Â¬)âŠ˜(-ËœÃ·1-âŠ£)
  'Â¬', IAâˆ˜0âŠ˜(+-1Ë™)
âŸ©
âŒœ â†© _table
Â¨ â†© _each
âˆ¾ â†© Join           âŠ˜ JoinTo
Â» â† ShiftBefore
Â« â† ShiftAfter
Mod1Inverse â† INFË™ _lookup_ âŸ¨
  'â¼', âŠ¢
  'Ëœ', {SwapInverseğ•©}
  'Â¨', {ğ•â¼Â¨                     âŠ£Â·IX 0<â‰¡âˆ˜âŠ¢}
  'âŒœ', {ğ•â¼âŒœâŠ˜(IAâˆ˜0)              âŠ£Â·IX 0<â‰¡âˆ˜âŠ¢}
  'Ë˜', {(IXâˆ˜IsArrayâŠ¸âŠ¢ğ•â¼)Ë˜       âŠ£Â·IX 0<=âˆ˜âŠ¢}
  '`', {(âŠâˆ¾Â¯1âŠ¸â†“ğ•1âŠ¸â†“)âŸ(1<â‰ )âŠ˜(Â»ğ•âŠ¢)âŠ£Â·IX 0<=âˆ˜âŠ¢}âˆ˜{ğ•â¼Â¨}
âŸ©
âŸ â†© _repeat_
âŒ¾ â† _under_
Mod2Inverse â† INFË™ _lookup_ âŸ¨
  'âˆ˜', AtopInverse
  'â—‹', {Fiâ†ğ•â¼â‹„ğ•â¼ FiâŠ˜(ğ•âŠ¸Fi)}
  'âŒ¾', {ğ•â¼âŒ¾ğ•}  # Need to verify for computational Under
  'âŸ', Intâˆ˜âŠ¢â—¶âŸ¨IAâˆ˜0Ë™,{ğ•âŸ(-ğ•©)}âŸ©
  'âŠ˜', {(ğ•â¼)âŠ˜(ğ•â¼)}
  'âŠ¸', IsConstantâˆ˜âŠ£ âŠ£â—¶{INFâŠ˜ğ•}â€¿âŠ¢ {ğ•âŠ¸(ğ•â¼)}
  'âŸœ', {(ğ•¨IsConstantâˆ˜âŠ¢â—¶âŸ¨IAâˆ˜0Ë™,{ğ•©ğ•{SwapInverseğ•—}âŠ¢}âŸ©ğ•©)âŠ˜(ğ•â¼ğ•â¼)}
âŸ©

Â´ â†© _fold
Ë â† _insert
â¼ â†© {iâ†Inverseğ•—â‹„ğ•¨Iğ•©}
Ë˜ â† _cells
âŠ‘ â†© First          âŠ˜ Pick
â—¶ â†© {ğ•¨((ğ•¨ğ”½ğ•©)âŠ‘ğ•˜){ğ”½}ğ•©}  # Same definition, new Pick
âš‡ â† _depthOp_
â‰ â† _rankOp_
â¥Š â†© Deshape        âŠ˜ Reshape
â‰ â† >âˆ˜â‹ˆ _fillBy_ (âŠ¢âŠ˜IF)
â‹ˆ â†© {ğ•©FillâŸ¨ğ•©âŸ©}     âŠ˜ (â‹ˆâ—‹âŠ‘ _fillBy_ IFâ—‹<)
âŠ” â† GroupInds      âŠ˜ GroupGen
â‰ â† Transpose      âŠ˜ ReorderAxes
âˆŠ â† âŠ¢_self         âŠ˜ (0 _searchËœ)
â· â† âˆŠâŠ¸/            âŠ˜ Find
âŠ’ â† OccurrenceCountâŠ˜ ProgressiveIndexOf
/ â†© Indices        âŠ˜ Replicate
