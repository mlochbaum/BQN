funcâ€¿mod1â€¿mod2 â† â€¢args
lfâ†@+10
charSetâ€¿cglâ†(âˆ¾ â‰â—‹< â‰ Â¨)âŸ¨
  func                  # Function
  mod1                  # 1-modifier
  mod2                  # 2-modifier
  "â‹„,"âˆ¾lf               # Separator
  "â‡â†â†©"                 # Gets
  "(){}âŸ¨âŸ©"              # Bracket
  "â€¿"                   # Ligature
  "Â·"                   # nOthing
  # Use last character in case of UTF-16 (like dzaima/BQN)
  Â¯1âŠË˜10â€¿âˆ˜â¥Š"ğ•Šğ•ğ•ğ”½ğ”¾ğ•¤ğ•©ğ•¨ğ•—ğ•˜" # Input (ğ•£ pending; â„ not allowed)
  ".Â¯Ï€âˆ"                # Numeric
  '0'+â†•10               # Digit
  "_"âˆ¾Ëœâ¥Š"aA"+âŒœâ†•naâ†26    # Alphabetic
  "â€¢"âˆ¾(Â¯1â†“"ğ•¨")âˆ¾" "âˆ¾@+9  # Whitespace (or special name prefix in UTF-16)
  "#'""@"               # Preprocessed characters
âŸ©
bFâ€¿b1â€¿b2â€¿bSâ€¿bGâ€¿bBâ€¿bLâ€¿bOâ€¿bXâ€¿bNâ€¿bDâ€¿bAâ€¿bWâ€¿bPâ†â‰Â¨ËœâŸœ(0Â»+`)cgl
Mâ†1âŠ¸âŠ‘(0âŠ¸â‰¤âˆ§>)-âŸœâŠ‘   # âˆŠ for an init,length pair ğ•© as above
sepâ†âŠ‘bS
bIâ†5â‰âŸœ-âŠ¸+bX
Plâ†âˆ¾âŸœ("s"/Ëœ1<â‰ )   # Pluralize
_tmplâ†{âˆ¾ğ•—{ğ•ğ•©}Â¨<ğ•©} # Template
# Convert characters to numbers, mostly the same as tokens
CharCodeâ†charSet{
  ErrUnknownCharsâ†0!ËœâŸ¨"Unknown character"âŠ¸Pl,": ",âŠ¢âŸ©_tmpl
  Chk â† âŠ¢âŠ£ErrUnknownCharsâˆ˜(â‰ /âŠ£)âŸâ‰¢âŸœ(âŠâŸœğ•—)
  gâ†â‹ğ•— â‹„ âŠ¢ Chk gâŠËœ1-Ëœ1âŒˆ(gâŠğ•—)â‹âŠ¢
}

vdâ†1+viâ†âŠ‘bN  # Start of identifier numbering (plus dot)
charRoleâ†4âˆ¾Ëœâˆ¾â¥ŠÂ¨ËœâŸœ(â‰ â†‘cglË™)âŸ¨1,2,3,Â¯1,Â¯3,Â¯1â€¿0,Â¯2,0,5/âŒ½â†•2âŸ© # For first vd chars
Tâ†âŒˆ`Ã— â‹„ ITâ†â†•âˆ˜â‰ âŠ¸T â‹„ I1Tâ†(1+â†•âˆ˜â‰ )âŠ¸T

# Source to âŸ¨tokens, roles, number of identifiers, literalsâŸ©
# Identifiers then literal tokens are numbered starting at vi
Tokenizeâ†{
  # Resolve comments and strings
  câ†ğ•©='#'â‹„sâ†/0â€¿0âŠ¸Â«âŠ¸âˆ§smâ†ğ•©='''â‹„dâ†/dmâ†ğ•©='"'
  gâ†â‹qâ†âˆ¾âŸ¨  sâ‹„Â¯1â†“dâ‹„/câŸ© â‹„qâ†©gâŠq                # Open indices
  eâ† gâŠâˆ¾âŸ¨2+sâ‹„ 1â†“dâ‹„-âŸœÂ»âˆ˜âŠâŸœ(0âˆ¾+`c)âŠ¸//(ğ•©=lf)âˆ¾1âŸ© # Matching close indices
  Seâ†{(âŠËœğ•¨)Se 1Â¨âŒ¾((ğ•©/ğ•¨)âŠ¸âŠ)ğ•©}âŸ(0=Â¯1âŠ‘âŠ¢)       # Mark reachable openings
  Stâ†(â‰ ğ•©)â†‘Â·/â¼((â‰ â†‘âˆ¾âŸœâ‰ Se 1âˆ¾0Â¨)qâ‹e)âŠ¸/          # All indices â†’ reached mask
  aâ†St qâ‹„bâ†St eâ‹„fâ†1â‰ `abâ†aâˆ¨b                 # Open/close masks; filter
  {âŸ¨âŠ‘/ğ•©,"Unclosed quote"âŸ©!0}âŸ(âˆ¨Â´)(smâˆ¨dm)âˆ§b<f

  # Extract character and string literals
  uâ†fâˆ§ğ•©='@'â‹„ciâ†/uâˆ¨Â»aâˆ§sm
  chrâ†(âŠâŸœğ•©-('@'-@)Ã—âŠâŸœu)ci                   # Characters (indices ci)
  f>â†©qeâ†dmâˆ§Â«aâˆ§â†©dm                           # Quote Escape ""
  strâ†ğ•©âŠ”Ëœ1-Ëœ(siâ†a>Â»qe)(âŠ£+`âŠ¸Ã—â—‹(âˆ¾âŸœ1)<)â‰ `dmâˆ§ab # Strings (indices /si)

  # Extract words: identifiers and numbers
  ieâ†/fâ‹„isâ†ieâ‰ âŠ¸â†‘/1Â»fâ‹„Fsâ†{is/Ëœâ†©ğ•¨â‹„ğ•¨/ğ•©}        # Token start and end
  is-â†©is(-Ã—âŠâŸœc)ie                           # Comment â†’ ending newline only
  tâ†CharCode ieâŠğ•©
  ndâ†(t=âŠ‘bN)>Â«t M bD                        # Namespace dot
  wâ†Â»âŠ¸<lâ†nd<t M bN(âŠ£â‰-Ëœ)â—‹âŠ‘bW                # Word chars l, start w
  usâ†t=Â¯1++Â´bAâ‹„syâ†t=âŠ‘bW                     # Underscore, system dot
  {âŸ¨/usâˆ§w+`âŠ¸âŠ0âˆ¾ğ•©,"Words can't only have underscores"âŸ©!0}âŸ(âˆ¨Â´)w(/<1(âŠ¢/Â«)(âˆ¨/âŠ£))l>us
  wkâ†naâŒŠâˆ˜Ã·Ëœ(âŠ‘bA)-Ëœw/t                       # Kind of word from first char
  t-â†©naÃ—lâˆ§tâ‰¥na+âŠ‘bA                          # Case-insensitive
  {âŸ¨ğ•©/is,"System dot with no name"âŸ©!0}âŸ(âˆ¨Â´)sy>Â«l
  wâ‰ â†©Â»âŠ¸âˆ¨sy                                  # Start system word at dot
  wiâ†0<wtâ†(2Ã—wkâ‰¥0)(Ã—âŸœÂ¬+âŠ¢)w/sy               # Type: 0 number, 1 system, 2 identifier
  iâ†l>nâ†lâˆ§(+`w)âŠ0âˆ¾Â¬wi                       # Identifier/Number masks
  numâ†is ReadNumsâ—‹(((0âˆ¾us)<âˆ¨âŸœÂ«0âˆ¾n)/0âŠ¸âˆ¾) tÃ—l # Numbers
  irâ†(us/ËœÂ«âŠ¸<i)(âŠ¢+âˆ§âŸœ(2âŠ¸=))wi/wk             # Identifier role
  wsâ†1=wi/wtâ‹„igâ†1-Ëœ(i>us)Ã—+`w>n             # Identifier groups
  {âŸ¨isâŠËœğ•©/ğ•¨,"Numbers can't start with underscores"âŸ©!0}âŸ(âˆ¨Â´âŠ¢)âŸœ(ws<(âŠ‘bA)>âŠâŸœt)/(Â¯1Â»âŒˆ`)âŠ¸<ig
  idâ†(wsâˆ¾2)âŠ”igâŠ”tâŠcharSet                    # âŸ¨Identifiers, system valuesâŸ©

  # Deduplicate literals and identifiers; other cleanup
  kiâ†(wtâ’âŠ¸âŠ/w)âˆ¾(ciâˆ¾/si)âŠ+`Â»f                # Indices in t
  kâ†idâˆ¾numâ€¿chrâ€¿strâ‹„k(âŠ¢>Â¯1Â»âŒˆ`)âŠ¸/Â¨Ëœâ†©jâ†âŠÂ¨k     # IDs j into uniques k
  kâ†©ğ•âŒ¾(1âŠ¸âŠ‘)k                                # System value lookup
  wfâ†Â¬lâˆ¨t M bWâ‹„ie/Ëœâ†©wfâˆ¨>âŸœÂ«l                 # Index management for...
  tâ†©(wâˆ¨wf)Fs(âˆ¾j++`vdÂ»kkâ†â‰ Â¨k)âŒ¾(kiâŠ¸âŠ)t        # Add IDs; remove words/whitespace
  t-â†©t(MÃ—-âŸœâŠ‘)bS                             # Separators are equivalent
  pâ†â‰ `1Â¨sbâ†Â¯1â†“1â†“/1(âˆ¾â‰ âˆ¾Ëœ)t=sep               # Separator group boundaries (excludes leading and trailing)
  skâ†sb/Ëœp>âˆ¨âŸœÂ«(p+(sb-p)âŠt)âˆŠ3â€¿5+âŠ‘bB          # Keep the first of each group that's not just inside a bracket
  t{ie/Ëœâ†©ğ•¨â‹„ğ•¨Fsğ•©}Ëœâ†©1Â¨âŒ¾(skâŠ¸âŠ)tâ‰ sep            # Remove the rest
  râ†irâŒ¾((t M vdâ‰+Â´2â†‘kk)âŠ¸/)(vdâŒŠt)âŠcharRoleâˆ¾0 # Role
  t+â†©5Ã—t MâŸ¨âŠ‘bX,5âŸ©                           # Case-insensitive special names
  t-â†©vi(<+10Ã—=)t                            # Shift . to bX and variables back one
  âŸ¨t,r,k,is,ieâŸ©
}

# ğ•© is a list of tokens that contains the numeric literals, each
# preceded by 0. Return the numbers.
ReadNumsâ†{
  _err_â†{(0!Ëœ/âŸœğ”¾â‰â—‹<ğ”½)âŸ(âˆ¨Â´)}
  ECharsâ†âŸ¨"Letter"âŠ¸Pl," """,âŠâŸœcharSet,""" not allowed in numbers"âŸ©_tmpl
  eâ€¿dâ€¿nâ€¿pâ€¿iâ†=âŸœğ•©Â¨((âŠ‘bA)+-Â´"ea")âˆ¾+âŸœâ†•Â´bN       # Masks for e.Â¯Ï€âˆ
  ECharsâˆ˜(/âŸœğ•©)_err_ğ•¨ Â¬eâˆ¨ğ•©<âŠ‘bA
  sâ†dâˆ¨câ†eâˆ¨zâ†0=ğ•©â‹„mâ†Â¬nâˆ¨c
  "Negative sign in the middle of a number"_err_ğ•¨ n>Â»c
  "Portion of a number is empty"_err_ğ•¨ (1Â«s)âˆ§nâˆ¨s
  "Ill-formed decimal or exponent use"_err_(s/ğ•) Â¬(0âŠ¸=âˆ¨Â»âŠ¸<)s/ğ•©
  "Ï€ and âˆ must occur alone"_err_ğ•¨ (pâˆ¨i)>1(Â»âˆ§(pâˆ§Â«e)âˆ¨Â«)zâˆ¨n>Â»e
  fâ†(17â‰¥Â¬(âŠ¢-T)+`)âŠ¸âˆ§gâ†(Â«â‰¤(d<ğ•©â‰ âŠ‘bD)>â—‹I1TÂ¬)âŠ¸âˆ§m # No leading 0s; max 17 digits
  lâ†(Â¯1âˆ¾Ï€â€¿1âˆ¾â†•10)âŠËœ(Â¬d)/fÃ—ğ•©-1+âŠ‘bN            # Digit lookup, with âˆ as 1 to avoid âˆÃ—0
  vâ†(>âŸœÂ«0â‰¤l)/0(0âŠ¸â‰¤Ã—Ã—âŸœ10âŠ¸+)`l                # Numeric valuesâ€”mantissas and exponents
  vÃ—â†©1â€¿Â¯1âŠËœ(râ†>âŸœÂ»m)/Â»n                      # Negate if Â¯
  vmâ†c/z                                    # Mask of mantissas in l
  dpâ†vm/f(--Â»âŠ¸-(<Ã—âŠ¢)âŠâŸœ(I1TÂ«d)âŠ¸-)â—‹(/>âŸœÂ«)g    # Decimal position
  tâ†10â‹†|eeâ†dp-Ëœvm/Â«vÃ—Â¬vm                    # Power of 10
  tÃ·ËœâŒ¾((0>ee)âŠ¸/)tÃ—âŒ¾((0<ee)âŠ¸/)vm/vÃ—(r/i)âŠ1â€¿âˆ # Correct âˆ then Ã—10â‹†ee
}


Parse â† {râ€¿vnâ€¿iâ€¿eâ†ğ•¨â‹„nvâ†â‰ vn
  ErrMismatchedBracketsâ†{
    Lcs â† âˆ§â—‹(0<â‰ )â—¶âŸ¨0, Â¯1 âŠ‘ 0Â¨âˆ˜âŠ¢ {ğ•©âŒˆâŒˆ`ğ•¨+Â»ğ•©}Ë =âŒœâŸœâŒ½âŸ©
    _mis_ â† {"Missing "âˆ¾ğ•—âˆ¾" "âˆ¾charSetâŠËœğ•˜+âŠ¢/Ëœâ‰ âˆ˜âŠ£=âŠ’}
    Msg â† >â—‹â‰ â—¶âŸ¨"opening"_mis_ 0, "closing"_mis_ 1ËœâŸ©
    0 !Ëœ ğ•¨ (Lcs<âŒŠâ—‹â‰ )â—¶âŸ¨Msg,"Malformed bracket nesting"âŸ© ğ•©
  }
  _err_â†{(0!Ëœ(âˆ§âˆ˜â‰(iâ‰eË™)âŠâ‰1Ëœ/âŸœğ”¾)â‰â—‹<ğ”½)âŸ(âˆ¨Â´âŸ=)}

  # Bracket and ligature validation and handling
  # Open brackets have role Â¯1 and closed ones have role 0
  "Empty program" ! 0<â‰ ğ•©
  gâ†â‹pdâ†+`pâ†(Â¯1-2Ã—r)Ã—ğ•© M bBâ‹„gbâ†gâŠr=Â¯1       # Paren (actually any bracket type) depth and grade
  (gâŠp)(>âŸœ0âŠ¸/ErrMismatchedBracketsâŸâ‰¢1-Ëœ<âŸœ0âŠ¸/)gxâ†gâŠğ•©
  "Swapped open and closed brackets" ! 0â‰¤(âŠ‘g)âŠ‘pd
  "Parentheses can't contain separators"_err_(gb/G) ((âŠ‘bB)âŠ¸=Â»âŠ¸âˆ§sepâŠ¸=)gb/gx
  {"Empty statement or expression"_err_(ğ•©/0âˆ¾G) (4+âŠ‘bB)â‰ ğ•©/0âˆ¾gx}1âŠ¸Â«âŠ¸âˆ§1âˆ¾gb
  r-â†©(ğ•©=âŠ‘bG)>ecâ†Â«0â‰¤r+p                      # Role Â¯4 for exports: âŠ‘bG is â‡
  "Invalid assignment or stranding use"_err_(â†•âˆ˜â‰ ) ((Â¯4âŠ¸<âˆ§â‰¤âŸœÂ¯2)r)>ecâˆ§Â»0â‰¤r
  "Dot must be followed by a name"_err_(â†•âˆ˜â‰ ) (r=4)>Â«ğ•© M viâ€¿nv
  dlâ†Â«âŠ¸âˆ¨dcâ†r=4                              # Dot left
  srâ†Â»âŒ¾(((â‹âŠâŸœdl)âŠ¸âŠg)âŠ¸âŠ)slâ†Â«âŠ¸âˆ¨r=Â¯2â‹„nsâ†Â¬slâˆ¨sr # Strand right and left; not stranded
  cpâ†ğ•©=1+âŠ‘bB                                # Closed paren
  nrâ†(ITÂ¬cp)âŠğ•©=âŠ‘bO                          # Nothingness role: 1 for Â· (handle ğ•¨ later?)
  "Can't strand Nothing (Â·)"_err_(â†•âˆ˜â‰ ) ns<nr
  gâŠËœâ†©â‹gâŠsdlâ†slâˆ¨dl                          # Avoid reordering strands and dots in rev
  # Permutation to reverse each expression: *more* complicated than it looks
  revâ†â‹+`Â¯1â†“(Â¯1âˆ¾g)(âŠ£â‹âŠ¸âŠâŠËœâŸœâ‹Â¬âŠËœ)â‹+`âŠ¸+1âˆ¾gâŠsdlâˆ¨r=Â¯1
  gfâ†â‹fdâ†+`brâ†revâŠpÃ—ğ•©MâŸ¨2+âŠ‘bB,2âŸ©             # Order by brace depth fd to de-nest blocks
  revâŠËœâ†©gfâ‹„fdâŠËœâ†©gfâ‹„brâŠËœâ†©gf
  ğ•©âŠËœâ†©revâ‹„pâŠËœâ†©revâ‹„iâŠËœâ†©revâ‹„eâŠËœâ†©rev
  fiâ†+`bâ†br>0â‹„câ†/br<0                       # Block Begin (mask) and Close (index), in matching order

  # Block properties
  PNâ†1(âˆ¾/âˆ¾Ëœ)(âˆ¨/âŠ£)â‹„Hâ†bÂ¬âˆ˜PN=                  # Which blocks have a property
  snâ†(0â€¿3â€¿4â€¿5+âŠ‘bI)â‹ğ•©â‹„spâ†/ğ•© M bI             # Special name index
  fxâ†1 H snâ‹„frâ†(fxâˆ¨0âŠ¸<)âŠ¸+ftâ†(2âŠ¸HâŒˆ2Ã—3âŠ¸H)sn   # Block immediacy Â¬fx and type ft
  "Special name outside of any block"_err_(/{(0=fi)âˆ§ğ•© M bI}âˆ˜ğ•©) 0<âŠ‘fr
  nfâ†(âŠ‘bG)Hğ•©                                # Namespace blocks
  {"Can't return Nothing (Â·)"_err_ğ•© ğ•©âŠnr} 1-ËœnfÂ¬âŠ¸/0âˆ¾câŠrev
  fscâ†(ftâŠ0â€¿2â€¿3)+3Ã—fx                       # Special name count

  # Propagate roles through parentheses
  # ir is the role of the expression ending at each position (truncated to the right)
  râ†©sl-ËœnsÃ—(1â†“fr)âŒ¾((câŠrev)âŠ¸âŠ)r              # Add block roles; make strand elements Â¯1
  ptâ†cpâˆ§ns                                  # Pass-through parentheses: not in strands
  ppâ†ptâˆ§Â»esâ†1âŠ¸Â»âŒ¾(gâŠ¸âŠ)r<0                    # Parens enclosing one object (maybe with assignment) don't change roles
  irâ†((Â»âŒ¾(gâŠ¸âŠ)(1+es)Ã—3=âŠ¢)âŒˆâŠ¢-es<2â‰¤âŠ¢)r+ppÃ—(ITÂ¬pp)âŠr # Propagate modifier roles
  irâŒˆâ†©(ITÂ¬ptâˆ§ir=0)((âŠ-âŠ¢)âŸœ(+`Â¬pp)(âŠ¢âŒŠ1âŒˆ+)âŠ)ir # ...and function roles
  r+â†©ptÃ—Â»ir                                 # Roles at pt were 0; set them now
  ir(Ã—âŸœÂ¬-âŠ¢)â†©nr                              # Include nothingness (doesn't handle ğ•)
  r-â†©(r=Â¯4)âˆ§1Â»r=Â¯1                          # Lone â‡ to role Â¯5
  "Dot must be preceded by a subject"_err_(â‹âˆ˜rev) dc>Â»r=0
  r(Ã—âŸœÂ¬-âŠ¢)â†©dlâ‹„dcâŠËœâ†©rev                      # Namespace and dot to Â¯1

  # Prep for lexical resolution before reordering ğ•©
  diâ†/dmâ†Â»dc                                # Dots aren't scoped
  idvâ†xvâŠËœidâ†/idmâ†dm<(0âŠ¸â‰¤âˆ§<âŸœnv)xvâ†ğ•©-vi

  # Parsing part 1
  p-â†©brâ‹„gâ†©â‹+`pâ‹„gâŠËœâ†©â‹gâŠÂ«âŠ¸âˆ¨dcâ‹„grâ†gâŠrev        # Order by non-brace bracket depth, then dots
  sllâ†1+2Ã·Ëœ0(<-â—‹/>)grâŠsr-slâ‹„lâ†/gâŠğ•©=5+âŠ‘bB    # Strand length; list starts
  bpâ†âŸ¨/b,câŸ©âˆ¾Â¨0(<â‰â—‹(</âŸœg)>)gâŠp               # Bracket pairs
  {iâ†©(ğ•¨âŠi)âŒ¾(ğ•©âŠ¸âŠ)iâ‹„eâ†©(ğ•©âŠe)âŒ¾(ğ•¨âŠ¸âŠ)e}Â´bp        # Highlight all contents of a pair when error reporting
  gâŠËœâ†©gsâ†â‹grâŠslâ‹„grâ†©gâŠrevâ‹„giâ†â‹g              # Send strand prefixes *â€¿ to the end
  ğ•©âŠËœâ†©gâ‹„râŠËœâ†©grâ‹„irâŠËœâ†©grâ‹„lâ†©(lâŠâ‹gs)âˆ¾/grâŠsr>sl
  aâ†(Â¯5âŠ¸<âˆ§â‰¤âŸœÂ¯3)râ‹„psâ†a<r<0                   # a: assignment, ps: part separator
  trâ†1â‰¤erâ†irâŠËœITÂ»ps                         # er: expression role; tr: train or modifier expression
  noâ†ir<0â‹„neâ†er<0                           # Nothing value; expression
  "Nothing (Â·) cannot be assigned"_err_(G) neâˆ§a
  oaâ†âŒ½/opâ†(er<2)âˆ§râ‰¥2â‹„roâ†opâˆ¨Â«opâˆ§m2â†r=3       # op: active modifiers; ro: mod or right operand
  "Missing operand"_err_(G) op>(Â«âˆ§m2â‰¤Â»)no<m2<roâˆ¨râˆŠâ†•2
  "Double subjects (missing â€¿?)"_err_(G) âˆ§âŸœÂ«roÂ»âŠ¸âˆ¨âŠ¸<r=0
  maâ†tr<(ğ•©=2+âŠ‘bG)âˆ§Â«irâ‰¥1                     # Modified assignment
  osâ†â†•âˆ˜â‰ âŠ¸(âŠ£-T)âŒ¾âŒ½Â¬roâˆ¨ma                      # Operator skip: distance rightward to derived function start
  atâ†1+âŠâŸœosâŠ¸+aiâ†/aâ‹„afâ†Â¯4â‰ aiâŠr               # Assignment target; af for actual (non-export) assignment
  "Role of the two sides in assignment must match"_err_(atâŠG) afâˆ§(0âŒˆatâŠer)â‰ arâ†atâŠr
  aidâ†(Â¯5âŠ¸â‰¤âˆ§<âŸœnv)ğ•©-vi                       # Assignable identifer
  akâ†(0â‰¤ar)+af+(âŠ‘bG)-ËœaiâŠğ•©                  # Class of assignment: 1â‡ 2â‡? 3â†? 4â†©?
  aaâ†Ã—gâŠacâ†Â»+`giâŠÂ«âŠ¸-akâŒ¾(atâŠ¸âŠ)0Â¨ğ•©            # ac broadcasts it to the entire target
  "Assignment target must be a name or list of targets"_err_(G) (aidâˆ¨psâˆ¨ğ•©(=âŸœ(3+âŠ‘)<M)bB)<aa
  "Can't use result of function/modifier assignment without parentheses"_err_(G) (0<er)âˆ§(0â‰¤r)âˆ§Â»âŠ¸>aa

  # Lexical resolution (independent of parsing part 2 below)
  ipâ†idâŠacâ‹„dâ†idâŠddâ†ac M 2â€¿2â‹„xmâ†ip M 1â€¿2     # Assignment classes; which are definitions, exports
  "Can't define special name"_err_(SP) spâŠdd
  idnâ†(idgâ†(d/idâŠfi)âˆ¾â‰ fsc)âŠ”d/idv            # Numbers for each identifier, per-block
  # Order every referenced identifier, and an undeclaration for each declaration
  ixfâ†(((1=ip)+âŠâŸœ(Â¯1âˆ¾b/gf))âˆ¾dâŠ¸/âŠ((â‰ ğ•©)âˆ¾câŠgf)Ë™)idâŠfi # First order by block index, open for real and closed for virtual
  igâ†(â‹âŠâŸœ(ixxâ†âˆ¾âŸœ(dâŠ¸/)idv))âŠ¸âŠâ‹ixf            # Then order by name
  {"Redefinition"_err_(ğ•©âŠÂ·âˆ¾âŸœ(dâŠ¸/)ID) Â¬ixxâˆ¨â—‹(Â»âŠ¸â‰ ğ•©âŠ¸âŠ)ixf} (â‰ d)âŠ¸â‰¤âŠ¸/ig
  igâ†©<âŸœ(â‰ d)âŠ¸/(â‹+`âˆ˜âŠâŸœ(dâˆ¾-/Ëœd))âŠ¸âŠig           # Last order by declaration depth
  dâŠËœâ†©ig
  ("Undefined identifier"Pl/)_err_(igâŠID) d<Â¯1âŠ¸Â»âŠ¸â‰ igâŠidv
  idxâ†idgâŠ”(â‹d/ig)âŠd(/â‰¥1â†“PN)igâŠxm            # Exported identifier mask
  uiâ†(IT d)âŠ¸âŠâŒ¾(igâŠ¸âŠ)id                      # Index of definition (âŠ for identifiers)
  lcâ†(1Â«b)/dnâ†b(âŠ¢-T)+`idmâˆ§dd                # Locals Count
  iddâ†(id-â—‹(âŠâŸœfd)ui)âˆ¾0Â¨sp                   # Identifier frame depth
  "Can't export from surrounding scope"_err_(ID) xmâˆ§0<idâ‰ âŠ¸â†‘idd
  idiâ†(uiâŠ(fiâŠfsc)+dn-1)âˆ¾((spâŠfi)âŠ3Ã—fx)+0âŠ¸â‰¤âŠ¸+2+spâŠxv # Slot within frame
  uuâ†ip(((1Â«d)âˆ§0=âŠ£)âˆ§d(âŠ£+`âŠ¸âŠPN)0<âŠ¢)âŒ¾(igâŠ¸âŠ)idd# Unused marker
  idorâ†âˆ¾2â€¿3/âŸ¨di,idâˆ¾spâŸ©                      # Identifier bytecode ordering
  idbcâ†âŸ¨26Â¨di,diâŠxv
        21+(10Ã—uu)+0<ipâˆ¾spâŠac,idd,idiâŸ©      # Identifier bytecode: instruction, depth, slot

  # Parsing part 2
  taâ†trâˆ§2(>âˆ¨|)ps(âŠ¢-T)+`Â¬ro                  # Train argument (first-level)
  faâ†/(feâ†taâˆ¨roâˆ¨Â«âŠ¸âˆ¨ps<aa)<ffâ†(r=1)âˆ¨Â»op      # Active functions: cases fe are excluded
  "Second-level parts of a train must be functions"_err_(G) tr>feâˆ¨ff
  dyâ†faâŠÂ«no<(trâˆ§râ‰¥0)âˆ¨ro<r=0                 # Dyadic
  obâ†prâŠ/Â¯1(âŠ¢-Â»)uâ†â·âˆ§prâ†ğ•©âŠËœpiâ†/ğ•©<sep         # Objects to be loaded
  cnâ†piâˆ¾ltâ†/ğ•©â‰¥ciâ†vi+nvâ‹„obâˆ¾â†©(ci-Ëœâ‰ u)+ltâŠğ•©    # Constants
  bkâ†câŠgi                                   # Block loads
  sâ†ğ•©=sepâ‹„foâ†ğ•©=2+âŠ‘bBâ‹„lsâ†sâˆ§fo<â—‹IT loâ†ğ•©=4+âŠ‘bB # List Separators: after âŸ¨lo, not {fo
  "Can't use Nothing (Â·) in lists"_err_(G) (Â»loâˆ¨ls)âˆ§ne
  llâ†sllâˆ¾Ëœ(Â¬lo/1Â«ps)+-âŸœÂ»1â†“(loâˆ¾1)/+`lsâˆ¾0     # List Length
  drâ†/(neâˆ¨Â»r=Â¯5)<ls<sâ‹„rtâ†/fo                # Drop (block separator) and return
  flâ†(dyÃ—âŠâŸœos)âŠ¸+fa+dy                       # Function application site
  drâˆ¾â†©((1+dy)Ã—fnâ†faâŠne)/fl                  # Turn function applications on Â· to drops
  fnâ†©Â¬fnâ‹„fa/Ëœâ†©fnâ‹„dy/Ëœâ†©fnâ‹„fl/Ëœâ†©fn            # And remove them

  # Bytecode generation: numbers bc ordered by source location (after rev) oi
  orâ†â‹oiâ†idorâˆ¾gâŠËœâˆ¾âŸ¨cn,cn,bk,bk,2/l,dr,af/at,oa+1âŒˆoaâŠos,fl,rtâŸ©
  bcâ†orâŠâˆ¾idbcâˆ¾âŸ¨0Â¨cn,ob,15Â¨bk,1+â†•â‰ bk,â¥Šâ‰(3+lâŠaa)â‰ll,14Â¨dr
               11âŒˆ(11-1+âŠ‘bG)+(af/ai)âŠma+ğ•©,5+oaâŠr,(âŠ¢+9Ã—10âŠ¸=)16+dy-7Ã—faâŠer,Â¯1â†“rcâ†25+4Ã—nfâŸ©
  # Instruction source positions
  MIâ†-âŠ¸â†“ËœâŸœâ‰ âˆ¾gâŠËœâŠ¢â‹„ojâ†(rt-âˆ˜â‰ âŠ¸âŒ½oiâŒŠ1-Ëœâ‰ i)Miâˆ¾âŸ¨1-Ëœaf/at,oa,faâŸ©
  indâ†âŸ¨oj,oj Mi faâŠITÂ»Â¬roâˆ¨maâŸ©(Â¯1âˆ¾ËœorâŠ(â‰ rt)âŠ¸âŒ½)âŠ¸âŠÂ¨iâ€¿e
  # Function metadata and overall output
  âŸ¨bcâˆ¾Â¯1âŠ‘rc,u,âŸ¨ft,Â¬fx,/1âˆ¾orâ‰¥bc-â—‹â‰ rt,lc+fsc,idn,idxâŸ©,indâŸ©
}

Compileâ†{
  primsâ€¿Sysâ†{âŸ¨ğ•©,("System values not supported"!0Ë™)Â¨Â¨âŸ©}âŸ(2â‰ â‰ )ğ•¨
  âŸ¨tok,role,val,t0,t1âŸ©â†txâ†sys Tokenize ğ•©
  âŸ¨bc,prim,blk,oiâŸ©â†âŸ¨role,âŠ‘val,t0,t1âŸ© Parse tok
  âŸ¨bc, âˆ¾âŸ¨primâŠprimsâŸ©âˆ¾1â†“val, <Ë˜â‰>blk, oi, txâŸ©
}
