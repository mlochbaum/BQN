# BQN runtime. Requires:
#   Type Fill Log GroupLen GroupOrd _fillBy_
#   !+-Ã—Ã·â‹†âŒŠ=â‰¤â‰¢â¥ŠâŠ‘â†•âŒœ`âŠ˜
# Filled in by runtime: glyphs and default PrimInd
Decompose â† {0â€¿ğ•©}
PrimInd â† {ğ•©}
SetPrims â† {Decomposeâ€¿PrimInd â†© ğ•©}

â—¶ â† {ğ•¨((ğ•¨ğ”½ğ•©)âŠ‘ğ•˜){ğ”½}ğ•©}     # LIMITED to number left operand result
âŠ¢ â† {ğ•©}
âŠ£ â† {ğ•©}âŠ˜{ğ•¨}
Ë™ â† {ğ•©â‹„ğ•—}
Ëœ â† {ğ•©ğ”½ğ•¨âŠ£ğ•©}
âˆ˜ â† {ğ”½ğ•¨ğ”¾ğ•©}
â—‹ â† {(ğ”¾ğ•¨)ğ”½ğ”¾ğ•©}
âŠ¸ â† {(ğ”½ğ•¨âŠ£ğ•©)ğ”¾ğ•©}
âŸœ â† {(ğ•¨âŠ£ğ•©)ğ”½ğ”¾ğ•©}
âŸ â† {ğ•¨((ğ•¨ğ”¾ğ•©)âŠ‘âŠ¢â€¿ğ•—){ğ”½}ğ•©}   # LIMITED to boolean right operand result

IsArrayâ†0=Type
Intâ†(1=Type)â—¶âŸ¨0,âŒŠâŠ¸=âŸ©
Natâ†(1=Type)â—¶âŸ¨0,0âŠ¸â‰¤Ã—âŒŠâŠ¸=âŸ©
Deshapeâ†IsArrayâ—¶{ğ•©FillâŸ¨ğ•©âŸ©}â€¿â¥Š
Pair â† {âŸ¨ğ•©âŸ©} âŠ˜ {âŸ¨ğ•¨,ğ•©âŸ©}
Box â† {ğ•©FillâŸ¨âŸ©â¥ŠâŸ¨ğ•©âŸ©}
ToArray â† BoxâŸ(1-IsArray)

# LIMITED to numeric arguments for arithmetic cases
â‰¥ â†            â‰¤Ëœ
< â† Box      âŠ˜ (1-â‰¥)
> â†            (1-â‰¤)
âŒŠ â†© âŒŠ        âŠ˜ (âŠ£-â‰¥Ã—-)
âŒˆ â† -âˆ˜âŒŠâˆ˜-    âŠ˜ (âŠ£-â‰¤Ã—-)
| â† 0âŠ¸â‰¤â—¶-â€¿âŠ¢
â‰  â† (0<=)â—¶âŸ¨1â‹„0âŠ‘â‰¢âŸ©  # LIMITED to monadic case

_foldâ†{
  "Â´: ğ•© must be a list" ! 1==ğ•©
  lâ†â‰ vâ†ğ•© â‹„ Fâ†ğ”½
  râ†ğ•¨ (0<l)â—¶{ğ•©â‹„Identity f}â€¿{lâ†©l-1â‹„lâŠ‘ğ•©}âŠ˜âŠ£ ğ•©
  ({râ†©ğ•© F r}(l-1)âŠ¸-âŠ‘ğ•©Ë™)âŒœâ†•l
  r
}
Â´ â† _fold

âˆ¾ â† {kâ†â‰ ğ•¨â‹„kâŠ¸â‰¤â—¶âŸ¨âŠ‘âŸœğ•¨â‹„-âŸœkâŠ‘ğ•©ËœâŸ©âŒœâ†•k+â‰ ğ•©}  # LIMITED to two list arguments
â†‘ â† {âŠ‘âŸœğ•©âŒœâ†•ğ•¨}                       # LIMITED to number ğ•¨ and list ğ•©
â†“ â† {(ğ•¨âŠ¸+âŠ‘ğ•©Ë™)âŒœâ†•(â‰ ğ•©)-ğ•¨}             # LIMITED to number ğ•¨ and list ğ•©
Cell â† â†“âŸœâ‰¢

GetCellsâ†(1==âˆ˜âŠ¢)â—¶{
  câ†1Ã—Â´sâ†1 Cell ğ•©
  ğ•¨((â¥Šğ•©)âŠ‘ËœcâŠ¸Ã—âŠ¸+)âŒœsâ¥Šâ†•c
}â€¿{
  âŠ‘âŸœğ•©âŒœğ•¨
} _fillBy_ âŠ¢
âŠ â† GetCells  # LIMITED to depth-1 natural number left argument

_qSearch â† {+Â´Â·Ã—`ğ•—(1-=)âŒœ<}
_glyphLookup_ â† {
  {PrimIndğ•©} âŠ‘ ((ğ•˜âŠ‘Ëœğ•—_qSearch)âŒœglyphs)Ë™
}
_isGlyph â† { (glyphs _qSearch ğ•—) = {PrimIndğ•©} }
IsJoin â† 'âˆ¾'_isGlyph

Split2 â† { sâ†2âŠ¸Ã—âŒœâ†•(â‰ ğ•©)Ã·2 â‹„ âŸ¨sâŠğ•©,(1âŠ¸+âŒœs)âŠğ•©âŸ© }
_lookup_ â† {
  kâ€¿vâ†Split2 ğ•˜ â‹„ k _glyphLookup_ (vâˆ¾âŸ¨ğ•—âŸ©)
}
Identity â† {ğ•0} ("Â´: Identity not found"!0Ë™) _lookup_ âŸ¨
  '+',0 , '-',0
  'Ã—',1 , 'Ã·',1
  'â‹†',1 , 'Â¬',1
  'âŒŠ',âˆ , 'âŒˆ',Â¯âˆ
  'âˆ¨',0 , 'âˆ§',1
  'â‰ ',0 , '=',1
  '>',0 , 'â‰¥',1
âŸ©

_eachdâ†{
  _dâ†{ # Equal ranks
    pâ†â‰¢ğ•¨
    "Mapping: Equal-rank argument shapes don't agree" ! 1(âŠ‘âŸœp=âŠ‘âŸœ(â‰¢ğ•©))âŠ¸Ã—Â´â†•=ğ•¨
    pâ¥Š (âŠ‘âŸœ(â¥Šğ•¨)ğ”½âŠ‘âŸœ(â¥Šğ•©))âŒœâ†•1Ã—Â´p
  }
  _eâ†{ # ğ•¨ has smaller or equal rank
    pâ†â‰¢ğ•¨ â‹„ kâ†=ğ•¨ â‹„ qâ†â‰¢ğ•©
    "Mapping: Argument shape prefixes don't agree" ! 1(âŠ‘âŸœp=âŠ‘âŸœq)âŠ¸Ã—Â´â†•k
    lâ†1(qâŠ‘ËœkâŠ¸+)âŠ¸Ã—Â´â†•(=ğ•©)-k
    aâ†â¥Šğ•¨ â‹„ bâ†â¥Šğ•©
    qâ¥Šâ¥Š(â‰ a) (âŠ‘âŸœağ”½lâŠ¸Ã—âŠ¸+âŠ‘bË™)âŒœâ—‹â†• l
  }
  =â—‹=â—¶âŸ¨>â—‹=â—¶âŸ¨ğ”½_eâ‹„ğ”½Ëœ_eËœâŸ©â‹„ğ”½_dâŸ©
}

_pervâ†{ # Pervasion
  Râ†ğ”½{ğ•¨ğ”½_pervğ•©}
  +â—‹IsArrayâ—¶âŸ¨
    ğ”½
    RâŒœâŠ˜(>â—‹IsArrayâ—¶{ğ•¨{ğ•—Rğ•©}âŒœğ•©}â€¿{ğ•©{ğ•©Rğ•—}âŒœğ•¨}) _fillBy_ R
    R _eachd _fillBy_ R
  âŸ©
}

# Sorting
Cmp0 â† â‰¥-â‰¤
Cmp1 â† (0<1Ã—Â´â‰¢âˆ˜âŠ¢)â—¶âŸ¨1, IsArrayâˆ˜âŠ¢â—¶(1-2Ã—â‰¤)â€¿{ğ•¨Cmp1ğ•©}âŸœ(0âŠ‘â¥Š)âŸ©
CmpLen â† {
  eâ†ğ•¨-â—‹(1Ã—Â´0âŠ¸<âŒœ)ğ•©
  ğ•¨(e=0)â—¶âŸ¨e,0âŸ©â€¿{
    SMâ†Cmp0 Pair â‰¥âŠ‘Pair
    câ€¿râ†ğ•¨SMâ—‹â‰ ğ•©
    lâ†ğ•¨{
      iâ†0+Â´Ã—`ğ•¨=_eachdğ•©
      mâ†1Ã—Â´iâ†•âŠ¸âŠğ•¨
      {kâ€¿lâ†SMÂ´ğ•©â‹„câ†©kâ‹„mÃ—â†©l}âˆ˜(<âŠ‘âŒœğ•¨â€¿ğ•©Ë™)âŸ(râŠ¸>)i
      m
    }â—‹{(ğ•©âŠ‘Ëœ(Â¯1+â‰ ğ•©)âŠ¸-)âŒœâ†•r}ğ•©
    âŸ¨c,lâŸ©
  }ğ•©
}
_getCellCmp â† {
  Ciâ†ğ”½â‹„câ†ğ•¨âŠ£0â‹„lâ†ğ•©
  Ccâ†{
    aâ†ğ•¨â‹„bâ†ğ•©
    Sâ†(lâŠ¸=)â—¶{Sâˆ˜(1+ğ•©)âŸ(0âŠ¸=)a Ciâ—‹(ğ•©âŠ¸+)b}â€¿c
    S 0
  }
  (ğ•¨ âŠ¢âŠ˜{ğ•¨âŸ(0âŠ¸=)ğ•} ciË™)âŸ(1=l) cc
}
Cmp â† +â—‹IsArrayâ—¶âŸ¨
  Cmp0
  IsArrayâˆ˜âŠ£â—¶âŸ¨Cmp1,-Cmp1ËœâŸ©
  {
    lcâ†ğ•¨CmpLenâ—‹â‰¢ğ•©
    cc â† (âŠ‘âŸœ(â¥Šğ•¨))âŠ¸CmpâŸœ(âŠ‘âŸœ(â¥Šğ•©)) _getCellCmpÂ´ lc
    CcËœ0
  }
âŸ©

_grade â† {
  gt â† ğ•—
  cmps â† {ğ•Ëœ}âŒœâŸğ•—âŸ¨Cmp,Cmp0,Cmpâ‰¤0Ë™,â‰¤âŸ©
  0 Fill {
    "â‹ğ•©: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
    lâ†â‰ ğ•©
    (2â‰¤l)â—¶âŸ¨â†•âˆ˜l,{
      m1â†1=mâ†1Ã—Â´1 Cell ğ•©
      ğ•©â†©â¥Šğ•©
      a0â†1â‹„tsâ†0â‹„{a0Ã—â†©1â‰¤ğ•©â‹„ts+â†©ğ•©}âˆ˜TypeâŒœğ•©
      csâ†a0+2Ã—m1
      Merge â† { # Merge sort
        le â† m {(ğ• _getCellCmp m)â‰¤0Ë™}âŸ(1-m1) ğ•©{ğ•â—‹(âŠ‘âŸœğ•—)} csâŠ‘cmps
        Bâ†lâŠ¸â‰¤â—¶âŠ¢â€¿l
        (â†•l){
          iâ†-dâ†ğ•¨ â‹„ jâ†eiâ†ejâ†0
          eâ†3 â‹„ Gâ†LEâ—‹(âŠ‘âŸœ(mâŠ¸Ã—âŒœâŸ(1-m=1)ğ•©)) â‹„ câ†âŸ¨1-G,0,1,2âŸ©
          sâ†(8â‰¤d)âŠ‘âŸ¨+,{(ğ•©-1){ğ•©â‹„eâ†©2â‹„jâ†©iâ‹„iâ†©ğ•©}âŸGâŸ(1-e)ğ•©}âŸ©
          Nâ†{iâ†©d+ğ•¨â‹„ejâ†©B d+eiâ†©B jâ†©d+ğ•©â‹„eâ†©lâ‰¤jâ‹„S eiâ‹„i R j}
          Râ†{ğ•¨eâ—¶cğ•©}â—¶{e+â†©2Ã—ei=iâ†©1+ğ•¨â‹„ğ•¨}â€¿{e+â†©ej=jâ†©1+ğ•©â‹„ğ•©}â€¿N
          {(i R j)âŠ‘ğ•©}âŸœğ•©âŒœğ•©
        }Â´(2â‹†ni-1+âŠ¢)âŒœâ†•niâ†âŒˆ2 Log l+l=0
      }
      # Counting sort for small-range ints
      blâ†buâ†0 â‹„ Countâ†{GroupLenâŠ¸GroupOrd (gtâŠ‘âŸ¨-âŸœbl,buâŠ¸-âŸ©)âŒœğ•©}
      srâ†((3=cs)Ã—ts=l)â—¶âŸ¨0,(1Ã—Â´âŒŠâŠ¸=âŒœ)â—¶0â€¿{((buâ†©âŒˆÂ´ğ•©)-blâ†©âŒŠÂ´ğ•©)â‰¤2Ã—l}âŸ©ğ•©
      srâ—¶Mergeâ€¿Count ğ•©
    }âŸ©ğ•©
  }
}
_binSearch â† {
  B â† ğ”½
  {
    Râ†{ğ•¨{aâ†B mâ†ğ•©+hâ†âŒŠğ•¨Ã·2â‹„(h+aÃ—ğ•¨-2Ã—h)R aâŠ‘ğ•©â€¿m}âŸ(>âŸœ1)ğ•©}
    1+(ğ•©+1)R Â¯1
  }âŸ(0âŠ¸<)
}
_binsâ†{
  câ†1-Ëœ=ğ•¨
  "â‹ or â’: Rank of ğ•¨ must be at least 1" ! 0â‰¤c
  "â‹ or â’: Rank of ğ•© must be at least cell rank of ğ•¨" ! câ‰¤=ğ•©
  ğ•©â†©ToArray ğ•©
  lwâ†1Ã—Â´swâ†1 Cell ğ•¨
  cwâ†ğ”½â—‹(âŠ‘âŸœ(â¥Šğ•¨)) _getCellCmp lw
  "â‹ or â’: ğ•¨ must be sorted" ! 0âŠ¸<â—¶âŸ¨1,1Ã—Â´Â·(cwâ‰¤0Ë™)âŸœ(lwâŠ¸+)âˆ˜(lwâŠ¸Ã—)âŒœâ†•âˆ˜-âŸœ1âŸ©â‰ ğ•¨
  cxâ†c-Ëœ=ğ•©
  sxâ†cx Cell ğ•© â‹„ lcâ†sw CmpLen sx
  cc â† (âŠ‘âŸœ(â¥Šğ•¨))âŠ¸ğ”½âŸœ(âŠ‘âŸœ(â¥Šğ•©)) _getCellCmpÂ´ lc
  Bâ†(1Ã—Â´sw)âŠ¸Ã—âŠ¸Ccâ‰¤0Ë™
  0 Fill (â‰ ğ•¨)âŠ¸{BâŸœğ•© _binSearch ğ•¨}âŒœ (1Ã—Â´sx)âŠ¸Ã—âŒœ â¥ŠâŸœ(â†•1Ã—Â´âŠ¢)âŠ‘âŸœ(â‰¢ğ•©)âŒœâ†•cx
}

â‹ â† 0 _grade âŠ˜ (Cmp  _bins)
â’ â† 1 _grade âŠ˜ (CmpËœ _bins)

# Searching
_searchâ†{ # 0 for âˆŠËœ, 1 for âŠ
  ind â† ğ•—
  red â† ğ•—âŠ‘âŸ¨1-Ã—Â´,+Â´Ã—`âŸ©
  0 Fill {
    câ†1-Ëœ=ğ•¨
    "pâŠğ•© or ğ•¨âˆŠp: p must have rank at least 1" ! 0â‰¤c
    "pâŠn or nâˆŠp: Rank of n must be at least cell rank of p" ! câ‰¤=ğ•©
    nâ†â‰ ğ•¨ â‹„ kâ†1Ã—Â´sâ†1 Cell ğ•¨ â‹„ cxâ†c-Ëœ=ğ•©
    lxâ†1Ã—Â´shâ†cxâ†‘â‰¢ğ•©
    sh â¥Š ğ•¨ (0<n)â—¶âŸ¨0,s MatchS cxâŠ¸CellâŸ©â—¶{ğ•©â‹„(indÃ—n)âŒœâ†•lx}â€¿{
      cc â† (âŠ‘âŸœ(â¥Šğ•¨))âŠ¸(1-Match)âŸœ(âŠ‘âŸœ(â¥Šğ•©)) _getCellCmp k
      ğ•¨ Ã—â—‹(8<â‰ âˆ˜â¥Š)â—¶{ğ•©
        iâ€¿jâ†(kâŠ¸Ã—âŒœâ†•)âŒœnâ€¿lx â‹„ {Red CCâŸœğ•©âŒœi}âŒœj
      }â€¿{
        gâ†Reverseâ’ğ•¨
        iâ†(gâŠ‘Ëœ0âŒˆ-âŸœ1)âŒœ(gâŠğ•¨)â‹ğ•©
        adjâ†indâŠ‘âŸ¨1âŠ¸-,âŠ£--âŸœnâŠ¸Ã—âŸ©
        âŠ‘âŸœiâŠ¸(âŠ£ Adj CCâ—‹(kâŠ¸Ã—))âŒœâ†•lx
      } ğ•©
    } ToArrayğ•©
  }
}

Indicesâ†{
  "/: Replication argument must have rank 1" ! 1==ğ•©
  lâ†â‰ ğ•©
  0 Fill {
    "/: Amounts to replicate must be natural numbers" ! 1Ã—Â´NatâŒœğ•©
    kâ†l-1
    N â† ((âŠ¢+-Ã—0=ğ•©âŠ‘ËœâŠ¢)`kâŠ¸-âŒœâ†•l)âŠ‘Ëœk-âŠ¢  # Next nonzero
    E â† âŠ‘âŸœ(+`ğ•©)
    eiâ†E iâ†N 0
    {{eiâ†©E iâ†©Nğ•©+1â‹„i}âŸ(ğ•©=ei)i}âŒœâ†•E k
  }âŸ(0<l)ğ•©
}
Rep â† IndicesâŠ¸âŠ

Transposeâ†(0<=)â—¶âŸ¨ToArray,{
  lâ†â‰ ğ•© â‹„ mâ†1Ã—Â´câ†1 Cell ğ•©
  (câ¥Šâ†•m)(+âŸœ(mâŠ¸Ã—)âŠ‘(â¥Šğ•©)Ë™)âŒœâ†•l
}_fillBy_âŠ¢âŸ©
TransposeInvâ†{
  râ†1-Ëœ=ğ•© â‹„ sâ†â‰¢ğ•© â‹„ lâ†râŠ‘s â‹„ câ†âŠ‘âŸœsâŒœâ†•r
  (â†•l)(+âŸœ(lâŠ¸Ã—)âŠ‘(â¥Šğ•©)Ë™)âŒœcâ¥Šâ†•1Ã—Â´c
}_fillBy_âŠ¢âŸ{IX IsArrayğ•©â‹„0<=ğ•©}

Reverseâ†{
  "âŒ½ğ•©: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  lâ†â‰ ğ•©
  ((l-1)âŠ¸-âŒœâ†•l) âŠ ğ•©
}
Rotâ†{
  "ğ•¨âŒ½ğ•©: ğ•¨ must consist of integers" ! Intğ•¨
  lâ†â‰ ğ•© â‹„ ğ•¨-â†©lÃ—âŒŠğ•¨Ã·l+l=0 â‹„ ((ğ•¨+âŠ¢-lÃ—(l-ğ•¨)â‰¤âŠ¢)âŒœâ†•l) âŠ ğ•©
}

Prefixesâ†{
  "â†‘ğ•©: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  0âŠ¸âŠ‘âŠ¸Fill â†•âŠ¸âŠâŸœğ•©âŒœ â†•1+â‰ ğ•©
}
Suffixesâ†{
  "â†“ğ•©: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  lâ†â‰ ğ•©
  lâŠ¸âŠ‘âŠ¸Fill {ğ•©âŠ¸+âŒœâ†•l-ğ•©}âŠ¸âŠâŸœğ•©âŒœ â†•1+l
}

NormIndPâ€¿NormIndSâ†{
  eiâ€¿erâ†ğ•© â‹„ _crâ†{âŠ¢âŠ£er!ğ”½}
  0âŠ¸â‰¤â—¶âŸ¨0âŠ¸â‰¤_cr+, >_crâŸ© âŠ£ ei!Intâˆ˜âŠ¢
}âŒœâŸ¨
  "ğ•¨âŠ‘ğ•©: Indices in ğ•¨ must consist of integers"â€¿"ğ•¨âŠ‘ğ•©: Index out of range"
  "ğ•¨âŠğ•©: Indices in ğ•¨ must be integers"â€¿"ğ•¨âŠğ•©: Indices out of range"
âŸ©
Pick0â†{
  "ğ•¨âŠ‘ğ•©: ğ•© must be a list when ğ•¨ is a number" ! 1==ğ•©
  ğ•©âŠ‘Ëœ(â‰ ğ•©)NormIndPğ•¨
}
Pick1â†{
  "ğ•¨âŠ‘ğ•©: Indices in compound ğ•¨ must be lists" ! 1==ğ•¨
  "ğ•¨âŠ‘ğ•©: Index length in ğ•¨ must match rank of ğ•©" ! ğ•¨=â—‹â‰ sâ†â‰¢ğ•©
  iâ†0â‹„(âŠ‘âŸœğ•¨{iâ†©(ğ•©NormIndPğ•¨)+ğ•©Ã—i}âŠ‘âŸœs)âŒœâ†•â‰ ğ•¨
  iâŠ‘Deshapeğ•©
}âŸœToArray
Pickdâ†(0<0+Â´IsArrayâŒœâˆ˜â¥Šâˆ˜âŠ£)â—¶Pick1â€¿{PickdâŸœğ•©âŒœğ•¨}
Pickâ†IsArrayâˆ˜âŠ£â—¶Pick0â€¿Pickd

FirstCellâ†{
  "âŠğ•©: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  "âŠğ•©: ğ•© cannot have length 0" ! 0<â‰ ğ•©
  (<0) âŠ ğ•©
}
SelSubâ†{
  "ğ•¨âŠğ•©: ğ•¨ must be an array" ! IsArray ğ•¨
  ğ•¨ (â‰ ğ•©)âŠ¸NormIndSâŒœâŠ¸âŠ ğ•©
}
First â† IsArrayâ—¶âŸ¨âŠ¢, (0<â‰ )â—¶âŸ¨Fill,0âŠ¸âŠ‘âŸ©â¥ŠâŸ©

IsPure â† {dâ†Decomposeğ•© â‹„ 2âŠ¸â‰¤â—¶âŸ¨â‰¤âŸœ0, 1(ğ•ŠdâŠ‘Ëœ1âŠ¸+)âŠ¸Ã—Â´Â·â†•1-Ëœâ‰ âˆ˜dâŸ©0âŠ‘d}
_fillByPure_â†{
  ğ•˜ (3â‰¤Typeâˆ˜âŠ£)â—¶âŸ¨{ğ•¨Fillğ•},{(ğ•¨HomFilğ•©)_fillBy_ğ•¨}âŸ(IsPureâŠ£)âŸ© ğ•—
}

StructErrâ†{ğ•©}
IsStructErr â† (3=Type)â—¶âŸ¨0,StructErrË™âŠ¸=âŸ©
_under_â†{
  valâ†ğ•¨ğ”½â—‹ğ”¾ğ•©
  # Construct indices
  Inds â† IsArrayâ—¶âŸ¨0,â¥ŠâŸœ(â†•1Ã—Â´âŠ¢)â‰¢âŸ© ğ•© âŠ‘âŸœâ¥ŠâŸ(IsArrayâŠ¢)Â´ Reverse
  _s_ â† {
    fâ†ğ•—
    stâ€¿dâ€¿oâ†ğ•©
    gâ†ğ•¨ St Indsâˆ˜{fâ†©f(IsArrayâŠ£)â—¶âŸ¨âŸ©â€¿âˆ¾âŸ¨ğ•©âŸ©}âŸ(d>IsArray) ğ•˜
    {f _s_ ğ•©}âŸo g
  }
  IsStruct â† (5=0âŠ¸âŠ‘)â—¶âŸ¨0,sË™=2âŠ¸âŠ‘âŸ© Decompose
  sf â† isStruct StructFn ğ•˜ â‹„ SR â† Â¯1 _s_ 0
  rootâ€¿ind â† IsStructâ—¶âŸ¨0â€¿StructErr,1â€¿3âŠDecomposeâŸ© SF sr

  # Traverse indices ğ•© and values ğ•¨.
  # Return flat lists âŸ¨indices,valuesâŸ©, or structErr if ğ•¨ doesn't capture ğ•©.
  GetInsertsâ†{
    countâ†0â‹„depthâ†{IsArrayâ—¶âŸ¨{ğ•©â‹„count+â†©1â‹„0},1+0âŒˆÂ´ğ•ŠâŒœâˆ˜â¥ŠâŸ©ğ•©}ğ•©
    ğ•© (2âŒŠdepth)â—¶(Pairâ—‹Pair)â€¿(StructConformâ—¶âŸ¨StructErrË™,Pairâ—‹â¥ŠâŸ©)â€¿{
      Failâ†{ğ•Šâ€¿0}
      # ğ• is parent traversal; ğ•© is current components of ind and val
      Travâ†(IsArray 0âŠ‘âŠ¢)â—¶âŸ¨Pair, StructConformÂ´âˆ˜âŠ¢â—¶Failâ€¿{
        Parentâ†ğ• â‹„ nâ†â‰ 0âŠ‘aâ†â¥ŠâŒœğ•© â‹„ jâ†Â¯1
        Childâ†TravâŸœ{ğ•©âŠ¸âŠ‘âŒœa}
        { j+â†©1 â‹„ fâ†nâŠ¸â‰¤â—¶âŸ¨ğ•ŠË™âŠ¸Child,ParentË™âŸ©j â‹„ F 0 }
      }âŸ©
      next â† 0 Trav ğ•¨â€¿ğ•©
      res â† {nâ€¿oâ†Nextğ•©â‹„nextâ†©nâ‹„o}âŒœ â†•count
      (next=fail)â—¶âŸ¨0âŠ¸âŠ‘âŒœ Pair 1âŠ¸âŠ‘âŒœ, StructErrË™âŸ© res
    } ğ•¨
  }âŸ(1-IsStructErrâˆ˜âŠ¢)
  Structâ†{
    iâ€¿vâ†ğ•¨
    Set1â†ğ•¨âŠ¸{
      ğ•©â†©ToArrayğ•©
      sâ†â‰¢ğ•©â‹„lâ†â‰ dâ†â¥Šğ•©
      glâ†l GroupLen i â‹„ gâ†gl GroupOrd i
      Selâ†vâŠ‘ËœâŠ‘âŸœg
      jâ†0â‹„Advâ†Sel{(j+â†©ğ•©)-1}
      CMâ†"âŒ¾: Incompatible result elements in structural Under"!MatchâŸœSel
      sâ¥Š2âŠ¸âŒŠâ—¶âŸ¨âŠ‘âŸœd,Adv,Adv{(ğ•¨CM(j-ğ•©)âŠ¸+)âŒœâ†•ğ•©-1â‹„ğ•¨}âŠ¢âŸ©âŸœ(âŠ‘âŸœgl)âŒœâ†•l
    }
    _at_ â† {ğ”½âŸ((ğ”¾ğ•©)=âŠ£)âŸœ(âŠ‘âŸœğ•©)âŒœ â†•â‰ ğ•©}
    Set â† 0âŠ¸{ (ğ•¨â‰¥â‰ root)â—¶âŸ¨â‰¢â¥Š(1+ğ•¨)âŠ¸ğ•Š_at_(ğ•¨âŠ‘rootË™)âˆ˜â¥Š, Set1âŸ© ğ•© }
    IsArrayâˆ˜rootâ—¶âŸ¨0âŠ‘vË™, SetâŸ© ğ•©
  } _fillBy_ âŠ¢
  IsStructErrâ—¶âŸ¨StructâŸœ(ğ•©Ë™), {ğ•val}Â·Inverseğ”¾Ë™âŸ© val GetInserts ind
}

MatchS â† 1Ã—Â´=_eachd
matchâ†{(0âŠ‘ğ•¨)â—¶(1âŠ‘ğ•¨)â€¿ğ•©}Â´âŸ¨
  âŸ¨=â—‹IsArray, 0âŸ©
  âŸ¨IsArrayâˆ˜âŠ¢, =âŸ©
  âŸ¨=â—‹=      , 0âŸ©
  âŸ¨MatchSâ—‹â‰¢ , 0âŸ©
  {1Ã—Â´â¥Šğ•¨ Match _eachd ğ•©}
âŸ©
structConform â† {ğ•â—¶0â€¿ğ•}Â´âŸ¨IsArrayâŠ¢, =â—‹=, MatchSâ—‹â‰¢âŸ©
Depthâ†IsArrayâ—¶0â€¿{1+0âŒˆÂ´DepthâŒœâ¥Šğ•©}

â‰¡ â† Depth          âŠ˜ Match
â‰¢ â†© IsArrayâ—¶âŸ¨âŸ©â€¿â‰¢   âŠ˜ (1-Match)
Â¨ â† {ğ•¨ğ”½âŒœâŠ˜(ğ”½_eachd)_fillByPure_ğ”½â—‹ToArrayğ•©}

IF â† âŠ¢âŠ£!âˆ˜â‰¡  # Intersect fill
IEFâ† (0<â‰ )â—¶âŸ¨âŠ¢_fillBy_ Fill, âŠ¢_fillBy_ IFÂ´âŸ©âˆ˜â¥Š
_fillMerge_ â† {(0<â‰ âˆ˜â¥Š)â—¶âŸ¨(ğ”¾â—‹â‰¢â¥ŠâŸ¨âŸ©Ë™)_fillBy_âŠ¢âŸœFill, ğ”½ âŠ£_fillBy_âŠ¢ IEFâŸ©}
Mergeâ†{
  câ†â‰¢0âŠ‘â¥Šğ•©
  (">ğ•©: Elements of ğ•© must have matching shapes" ! c =â—‹â‰ â—¶0â€¿MatchS â‰¢)âŒœâ¥Šğ•©
  (DeshapeâŒœğ•©)âŠ‘ËœâŒœcâ¥Šâ†•1Ã—Â´c
}_fillMerge_âˆ¾âŸIsArray

Join1â†{
  # List of lists
  iâ†jâ†Â¯1 â‹„ eâ†âŸ¨âŸ© â‹„ aâ†ğ•©
  {{eâ†©aâŠ‘Ëœiâ†©ğ•©â‹„jâ†©Â¯1}âŸ(1-iâŠ¸=)ğ•©â‹„(jâ†©j+1)âŠ‘e}âŒœIndicesâ‰ âŒœğ•©
}
JoinMâ†{
  # Multidimensional
  nâ†â‰ zâ†â¥Šğ•© â‹„ sâ†â‰¢âŒœz â‹„ dâ†â‰ 0âŠ‘s â‹„ râ†=ğ•©
  "âˆ¾ğ•©: Elements of ğ•© must all have the same rank" ! 1Ã—Â´(d=â‰ )âŒœs
  "âˆ¾ğ•©: ğ•© element rank must be at least argument rank" ! dâ‰¥r
  _s0â†{sâ†ğ•¨â‹„Fâ†ğ”½â‹„{oâ†sâ‹„s Fâ†©ğ•©â‹„o}âŒœğ•©}
  shâ†â‰¢ğ•© â‹„ pâ†1 â‹„ iâ†jâ†<0
  (Reverse 1Ã—_s0 Reverse sh){
    qâ†ğ•¨
    aâ†ğ•©âŠ‘sh
    mâ†ğ•©âŠ¸âŠ‘âŒœs
    lâ†(qâŠ¸Ã—âŠ‘mË™)âŒœâ†•a
    "âˆ¾ğ•©: ğ•© element shapes must be compatible" ! 1Ã—Â´m=Â¨â¥Š(â†•p)âŠ¢âŒœlâŠ£âŒœâ†•q
    k â† Indices l
    c â† -âŸœ(âŠ‘âŸœ(k âŠ 0+_s0 l))âŒœ â†•â‰ k
    i â†© (i Ã—âŸœ(âŠ‘âŸœl)âŒœ k) +Â¨ iâŠ¢âŒœc
    j â†© j Ã—âŸœaâŠ¸+âŒœ k
    pÃ—â†©a
  }Â¨â†•r
  Gâ†(â¥ŠâŒœz){ğ•¨âŠ‘ğ•©âŠ‘ğ•—}Â¨
  i (r<d)â—¶Gâ€¿{
    Drâ†((râŠ¸+)âŒœâ†•d-r)âŠ¸âŠ
    tâ†Dr 0âŠ‘s
    "âˆ¾ğ•©: ğ•© element trailing shapes must match" ! 1Ã—Â´(Ã—Â´t=Â¨Dr)âŒœs
    tiâ†tâ¥Šâ†•tpâ†Ã—Â´tâ‹„(ğ•¨tpâŠ¸Ã—âŠ¸+âŒœti)Gğ•©âŠ£âŒœti
  } j
}
Joinâ†(2âŒŠ=)â—¶âŸ¨
  Merge, (1Ã—Â´(1==)âŒœ)â—¶JoinMâ€¿Join1, JoinM
âŸ©_fillMerge_{
  râ†â‰ ğ•¨ â‹„ dâ†â‰ ğ•©
  "âˆ¾ğ•©: empty ğ•© fill rank must be at least argument rank" ! dâ‰¥r
  (râ‰¤âŠ£)â—¶âŸ¨âŠ‘âŸœğ•¨âŠ¸Ã—,âŠ¢âŸ©âŸœ(âŠ‘âŸœğ•©)âŒœâ†•d
} âŠ£ "âˆ¾ğ•©: ğ•© must be an array"!IsArray

Recompose â† âŠ£â—¶âŸ¨
  âŠ¢                  # 0 primitive
  âŠ¢                  # 1 block
  {ğ•ğ•}Â´âŠ¢             # 2-train
  {Fâ€¿Gâ€¿Hâ†ğ•©â‹„F G H}    # 3-train
  {Fâ€¿mâ†ğ•©â‹„F _m}       # 4 1-modifier
  {Fâ€¿mâ€¿Gâ†ğ•©â‹„F _m_ G}  # 5 2-modifier
âŸ©
structFn â† {
  Eâ†StructErrË™
  _errIfâ†{âŠ¢âŠ˜Ã—â—‹(1-ğ”½)â—¶âŸ¨StructErrË™,ğ•âŸ©}
  SE â† IsStructErr _errIfâŸ(3â‰¥Type)

  _sfn_ â† {(ğ•âŠ¢)â—¶âŸ¨ğ•, ğ•©â€¿ğ•—â€¿ğ•˜{ğ•¨ğ•ğ•—}âŸ©}
  Monâ†{ğ•âŠ˜E} â‹„ Dyâ†{EâŠ˜ğ•}
  kâ€¿v â† Split2 âŸ¨
    "âŠ¢âŠ£Ëœâˆ˜â—‹âŠ¸âŸœâŠ˜â—¶",  âŠ¢
    "=â‰ â‰¢",        Mon 1 _sfn_ 0
    "<",          Mon 0 _sfn_ 1
    "â‰",          Mon 1 _sfn_ 1  # Dyad combines
    "â†•/Â»Â«âŠ”",      Dy  1 _sfn_ 1
    "â¥Šâ†‘â†“âŒ½â‰âŠâŠ‘",        1 _sfn_ 1
  # ">",          Mon 2 _sfn_ 1
  # "âˆ¾",          Mon 2 _sfn_ 1  # Dyad combines
  # "Ë˜â‰Â¨âŒœ",
  # "âš‡",
  âŸ©
  SP â† (Join1 k)_glyphLookup_((kâ‰ âŒœâŠ¸Rep v)âˆ¾âŸ¨{
    NS â† ğ• _errIf
    (Type-3Ë™)â—¶âŸ¨NS, {mâ†ğ•©â‹„{NS(ğ•—_m)Ë™0}}, {mâ†ğ•©â‹„{NS(ğ•—_m_ğ•˜)Ë™0}}âŸ© ğ•©
  }âŸ©)
  StructPrim â† {pâ†SPğ•©â‹„ğ•¨Pğ•©}

  0âŠ¸â‰¤â—¶âŸ¨3,2âŠ¸â‰¤â—¶âŠ¢â€¿2âŸ©âˆ˜(0âŠ‘âŠ¢)â—¶âŸ¨
    SE âŠ£ StructPrim 1âŠ‘âŠ¢             #  0 primitive
    StructErrË™Ë™                     #  1 block
    0âŠ¸âŠ‘ Recompose {ğ•¨Ë™âŠ¸StructFnâŒœ1â†“ğ•©} #    other operation
    SE 1âŠ‘âŠ¢                          # Â¯1 constant
  âŸ©âŸœ{Decomposeğ•©}
}

_takeDropâ†{
  âŸ¨gl,Noop,_indsâŸ©â†ğ•—
  pre â† "ğ•¨"âˆ¾glâˆ¾"ğ•©: ğ•¨ must "
  ernk â† "have rank at most 1"
  eint â† "consist of integers"
  {
    ernk ! 1â‰¥=ğ•¨
    ğ•¨ â†© Deshape ğ•¨
    eint ! 1Ã—Â´IntâŒœğ•¨
    r â† â‰ ğ•¨
    s â† r {(1âŒœâˆ˜â†•ğ•¨-â‰ ğ•©)âˆ¾ğ•©}âŸ(>âŸœâ‰ ) â‰¢ğ•©
    _c â† { (Ã—âŸœğ•—âŒœğ•¨) +âŒœ ğ•© }
    iâ†<0 â‹„ kâ†1 â‹„ UIkâ†{ i (kÃ—ğ•¨)_câ†© k â†•âŠ¸(ğ•¨_c)âŸ(1-=âŸœ1) ğ•© â‹„ kâ†©1 â‹„ â‰ ğ•© }
    doFilâ†0
    sh â† (âŠ‘âŸœs Noopâ—¶{kÃ—â†©ğ•¨â‹„ğ•¨}â€¿(âŠ£ UIk {ğ•©â‹„doFilâ†©1}_inds) âŠ‘âŸœğ•¨)âŒœ â†•r
    (0<=i)â—¶(sâŠ¸â¥Š)â€¿{
      sh âˆ¾â†© t â† (sâŠ‘ËœrâŠ¸+)âŒœâ†•(â‰ s)-r
      {i ğ•©_câ†© â†•ğ•©}âŸ(1-1âŠ¸=) kÃ—Â´t
      Sel â† âŠ‘âŸœ(â¥Šğ•©)
      ğ•©{Selâ†©0âŠ¸â‰¤â—¶âŸ¨(Fillğ•¨)Ë™,SelâŸ©}âŸâŠ¢doFil
      SelâŒœ sh â¥Š i
    }_fillBy_âŠ¢ ToArray ğ•©
  }
}
Take â† âŸ¨"â†‘" â‹„ 1-=âŸœ| â‹„ { ğ”½âŸ(ğ•¨âŠ¸<)aâ†|ğ•© â‹„ (0<ğ•©)â—¶âŸ¨Â¯âˆâŸ(<âŸœ0)âŒœ+âŸœ(ğ•¨+ğ•©)âŒœ, Â¯âˆâŸ(ğ•¨âŠ¸â‰¤)âŒœâŸ©â†•a }âŸ©_takeDrop
Drop â† âŸ¨"â†“" â‹„ 1-0âŠ¸= â‹„ { ğ”½ â‹„ 0âŠ¸<â—¶âŸ¨â†•0âŒˆ+,<âˆ˜âŠ¢+âŒœÂ·â†•0âŒˆ-âŸ© }âŸ©_takeDrop

ShiftCheckâ†{
  "Â« or Â»: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  dâ†ğ•©-â—‹=ğ•¨
  "Â« or Â»: ğ•¨ must not have higher rank than ğ•©" ! 0â‰¤d
  "Â« or Â»: Rank of ğ•¨ must be at least rank of ğ•© minus 1" ! 1â‰¥d
  sâ†1 Cell ğ•©
  "Â« or Â»: ğ•¨ must share ğ•©'s major cell shape" ! 1Ã—Â´(âŠ‘âŸœs=+âŸœ(1-d)âŠ‘(â‰¢ğ•¨)Ë™)âŒœâ†•â‰ s
  1Ã—Â´s
}
ShiftBeforeâ†{
  câ†ğ•¨ ShiftCheck ğ•©
  nâ†cÃ—(ğ•©â‰¤â—‹=âŠ¢)â—¶1â€¿â‰ ğ•¨
  (â‰¢ğ•©)â¥ŠnâŠ¸â‰¤â—¶âŸ¨âŠ‘âŸœ(Deshapeğ•¨),-âŸœnâŠ‘(â¥Šğ•©)Ë™âŸ©âŒœâ†•cÃ—â‰ ğ•©
}
ShiftAfterâ†{
  câ†ğ•¨ ShiftCheck ğ•©
  lâ†cÃ—â‰ ğ•©
  nâ†cÃ—(ğ•©â‰¤â—‹=âŠ¢)â—¶1â€¿â‰ ğ•¨
  mâ†l-n
  (â‰¢ğ•©)â¥ŠmâŠ¸â‰¤â—¶âŸ¨+âŸœnâŠ‘(â¥Šğ•©)Ë™,-âŸœmâŠ‘(Deshapeğ•¨)Ë™âŸ©âŒœâ†•l
}
FCâ†{ # Fill cell
  "Â« or Â»: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  (Fill ğ•©)âŒœ â¥ŠâŸœ(â†•1Ã—Â´âŠ¢) 1 Cell ğ•©
}

Rangeâ†{
  Iâ†{"â†•ğ•©: ğ•© must consist of natural numbers"!Natğ•©â‹„â†•ğ•©}
  Mâ†{"â†•ğ•©: ğ•© must be a number or list"!1==ğ•©â‹„(0âŒœğ•©)Fill(<âŸ¨âŸ©)PairâŠ¸âˆ¾âŒœÂ´IâŒœğ•©}
  IsArrayâ—¶Iâ€¿M ğ•©
}
Windowsâ†{
  "ğ•¨â†•ğ•©: ğ•¨ must have rank at most 1" ! 1â‰¥=ğ•¨
  râ†â‰ ğ•¨â†©Deshape ğ•¨
  ğ•¨{
    "ğ•¨â†•ğ•©: Length of ğ•¨ must be at most rank of ğ•©" ! râ‰¤=ğ•©
    "ğ•¨â†•ğ•©: ğ•¨ must consist of natural numbers" ! Ã—Â´NatâŒœğ•¨
    sâ†â‰¢ğ•©
    lâ†(1+âŠ‘âŸœs-âŠ‘âŸœğ•¨)âŒœâ†•r
    "ğ•¨â†•ğ•©: Window length ğ•¨ must be at most axis length plus one" ! Ã—Â´0âŠ¸â‰¤âŒœl
    kâ†1Ã—Â´tâ†(râŠ¸+âŒœâ†•sâ‰ âŠ¸-r)âŠs
    str â† Reverse Ã—`âŸ¨kâŸ©âˆ¾{(sâŠ‘Ëœğ•©âŠ¸-)âŒœâ†•ğ•©}r-1
    âŠ‘âŸœ(â¥Šğ•©)âŒœ k +âŒœâŸœ(tâ¥Šâ†•)ËœâŸ(1-=âŸœ1) l +âŒœâ—‹(+âŒœÂ´str{ğ•¨âŠ¸Ã—âŒœâ†•ğ•©}Â¨âŠ¢) ğ•¨
  }_fillBy_âŠ¢âŸ(0<r)ğ•©
}

Ë˜ â† {ğ•¨ ğ”½ _rankOp_ Â¯1 ğ•©}
_onAxes_â†{
  Fâ†ğ”½
  (ğ”¾<â‰¡)âˆ˜âŠ£â—¶{ # One axis
    "First-axis primitive: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
    ğ•¨Fğ•©
  }â€¿{ # Multiple axes
    "Multi-axis primitive: ğ•¨ must have rank at most 1" ! 1â‰¥=ğ•¨
    "Multi-axis primitive: Length of ğ•¨ must be at most rank of ğ•©" ! ğ•¨â‰¤â—‹â‰ â‰¢ğ•©
    lâ†â‰ ğ•¨ â‹„ Wâ†âŠ‘âŸœ(â¥Šğ•¨)
    0{(Wğ•¨)F(1+ğ•¨)âŠ¸ğ•ŠË˜âŸ(ğ•¨<l-1)ğ•©}âŸ(0<l)ğ•©
  }âŸœToArray
}

Replicate â† (0<=âˆ˜âŠ£)â—¶{
  ğ•¨â†©(0âŠ‘â¥Š)âŸIsArrayğ•¨
  "/: Amounts to replicate must be natural numbers" ! Nat ğ•¨
  eâ†râ†ğ•¨
  ({e+â†©râ‹„1+ğ•©}âŸ{e=ğ•¨}Ëœ`â†•rÃ—â‰ ğ•©) âŠ ğ•©
}â€¿{
  "ğ•¨/ğ•©: Lengths of components of ğ•¨ must match ğ•©" ! ğ•¨=â—‹â‰ ğ•©
  ğ•¨ Rep ğ•©
} _onAxes_ (1-0=â‰ ) _fillBy_ âŠ¢

PermInv â† 1Â¨âŠ¸GroupOrd
_selfâ†{
  "âˆŠğ•© or âŠğ•©: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  gâ†â‹ğ•©
  0 Fill (PermInv g) âŠ g ğ”½ 0âŠ¸<â—¶âŸ¨1,-âŸœ1â‰¢â—‹(âŠ‘âŸœ(gâŠ<Ë˜âŸ(1<=)ğ•©))âŠ¢âŸ©âŒœâ†•â‰ ğ•©
}
SelfClas â† (PermInvâˆ˜â‹âˆ˜(IndicesâŠ¸âŠ)ËœâŠËœÂ¯1+`âŠ¢) _self

ReshapeT â† "âˆ˜âŒŠâŒ½â†‘"_glyphLookup_(â†•5)
Reshapeâ†{
  "ğ•¨â¥Šğ•©: ğ•¨ must have rank at most 1" ! 1â‰¥=ğ•¨
  sâ†Deshape ğ•¨
  spâ†0+Â´pâ†(1-Nat)âŒœs
  "ğ•¨â¥Šğ•©: ğ•¨ must consist of natural numbers" ! 1â‰¥sp
  nâ†â‰ dâ†Deshape ğ•©
  lâ†spâ—¶(1Ã—Â´âŠ¢)â€¿{
    lpâ†1Ã—Â´pâŠ£â—¶âŠ¢â€¿1Â¨ğ•©
    "ğ•¨â¥Šğ•©: Can't compute axis length when rest of shape is empty" ! 0<lp
    iâ†0+Â´âŠ‘âŸœpâŠ¸Ã—âŒœâ†•â‰ p
    tâ†ReshapeT iâŠ‘s
    "ğ•¨â¥Šğ•©: ğ•¨ must consist of natural numbers or âˆ˜ âŒŠ âŒ½ â†‘" ! t<4
    Chk â† âŠ¢ âŠ£ "ğ•¨â¥Šğ•©: Shape must be exact when reshaping with âˆ˜" ! âŒŠâŠ¸=
    aâ†(2âŒŠt)â—¶âŸ¨Chk,âŒŠ,âŒˆâŸ©nÃ·lp
    sâ†©pâŠ£â—¶âŠ¢â€¿aÂ¨s
    {dâˆ¾â†©(Fill d)âŒœâ†•ğ•©-nâ‹„n}âŸ(nâŠ¸<)âŸ(3=t)lpÃ—a
  } s
  sâ¥Š{
    ğ•©(0<n)â—¶âŸ¨<âˆ˜FillâŠ¸(âŠ£âŒœ)â‹„{iâ†Â¯1â‹„mâ†n-1â‹„{ğ•©â‹„(i+â†©1-nÃ—i=m)âŠ‘d}âŒœğ•©}âŸ©â†•l
  }_fillBy_âŠ¢âŸ(1-l=n)d
}
â¥Š â†© Deshape        âŠ˜ â¥Š

_groupâ†{
  "âŠ”: Grouping argument must consist of integers" ! 1Ã—Â´IntâŒœğ•©
  "âŠ”: Grouping argument values cannot be less than Â¯1" ! 1Ã—Â´Â¯1âŠ¸â‰¤âŒœğ•©
  GLâ†GroupLenâ‹„ğ•©â†©ğ•¨(-ËœâŸœâ‰ {GLâ†©(ğ•¨âŠ‘ğ•©)GLâŠ¢â‹„ğ•¨â†‘ğ•©}âŠ¢)âŸ(0âŠ˜âŠ£)ğ•©
  dâ†(lâ†GLğ•©)GroupOrdğ•©
  iâ†0â‹„(ğ”½{ğ•©â‹„(iâ†©i+1)âŠ¢iâŠ‘d}âŒœâˆ˜â†•)âŒœl
}
GroupIndsâ†{
  "âŠ”ğ•©: ğ•© must be a list" ! 1==ğ•©
  Gâ†âŠ¢_group
  (1<â‰¡)â—¶âŸ¨
    â†•âˆ˜0             Fill G
    ((âŠ¢Fillâ¥ŠâŸœâŸ¨âŸ©)0âŒœ) Fill (<<âŸ¨âŸ©) âˆ¾âŒœâŒœÂ´ {âŠâŸœ(â¥ŠRangeâ‰¢ğ•©)âŒœ Gâ¥Šğ•©}âŒœ
  âŸ© ğ•©
}
Group1â†ToArrayâŠ¸{
  nâ†=ğ•¨
  "ğ•¨âŠ”ğ•©: Rank of simple ğ•¨ must be at most rank of ğ•©" ! nâ‰¤=ğ•©
  ldâ†(â‰¢ğ•¨)-Â¨nâ†‘sâ†â‰¢ğ•©
  drâ†(1=n)â—¶âŸ¨0,1=0âŠ¸âŠ‘âŸ©ld
  "ğ•¨âŠ”ğ•©: Lengths of ğ•¨ must equal to ğ•©, or one more only in a rank-1 component" ! drâ—¶âŸ¨1Ã—Â´0âŠ¸=âŒœ,1âŸ©ld
  SXâ†((n==ğ•©)â—¶{câ†1Ã—Â´tâ†nâ†“sâ‹„(ğ•©âŠ‘ËœcâŠ¸Ã—âŠ¸+)âŒœâŸœ(tâ¥Šâ†•c)}â€¿{âŠ‘âŸœğ•©âŒœ} â¥Šğ•©)âˆ˜âŠ£ _fillBy_ âŠ¢âŸœğ•©
  (SXâŸ¨âŸ©) Fill dr SX _group â¥Šğ•¨
}
GroupGenâ†{
  "ğ•¨âŠ”ğ•©: ğ•© must be an array" ! IsArray ğ•©
  ğ•¨(2â‰¤â‰¡ğ•¨)â—¶Group1â€¿GroupMğ•©
}

Ã· â†© Ã· _perv
â‹† â†© â‹† _perv
âˆš â† â‹†âŸœ(Ã·2)   âŠ˜ (â‹†âŸœÃ·Ëœ)
| â† (|       âŠ˜ {ğ•©-ğ•¨Ã—âŒŠğ•©Ã·ğ•¨}) _perv
âŒŠ â†© (âŒŠ       âŠ˜ {(ğ•¨>ğ•©)âŠ‘ğ•¨â€¿ğ•©}) _perv
âŒˆ â†© (-âˆ˜âŒŠâˆ˜-   âŠ˜ {(ğ•¨<ğ•©)âŠ‘ğ•¨â€¿ğ•©}) _perv
âˆ§ â† â‹âŠ¸âŠ      âŠ˜ (Ã— _perv)
âˆ¨ â† â’âŠ¸âŠ      âŠ˜ ((+-Ã—) _perv)
Ã— â†© (0âŠ¸(<->) âŠ˜ Ã—) _perv
< â†© Box      âŠ˜ ((1-â‰¥) _perv)
> â†© Merge    âŠ˜ ((1-â‰¤) _perv)
â‰  â†© â‰         âŠ˜ ((1-=) _perv)
= â†© =        âŠ˜ (= _perv)
â‰¥ â† ("â‰¥: No monadic form"!0Ë™) âŠ˜ (â‰¥ _perv)
â‰¤ â†© ("â‰¤: No monadic form"!0Ë™) âŠ˜ (â‰¤ _perv)
+ â†© + _perv
- â†© - _perv
Â¬ â† 1+-
HomFil â† {((ğ•0) Fill ğ•)âŠ˜ğ•}âŸ(+Â´âŸ¨=,â‰ ,â‰¡,â‰¢âŸ©=âŠ£)

ValidateRanksâ†{
  "â‰ or âš‡: ğ”½ result must have rank at most 1" ! 1â‰¥=ğ•©
  ğ•©â†©â¥Šğ•©
  "â‰ or âš‡: ğ”½ result must have 1 to 3 elements" ! (1âŠ¸â‰¤âˆ§â‰¤âŸœ3)â‰ ğ•©
  "â‰ or âš‡: ğ”½ result must consist of integers" ! 1âˆ§Â´IntâŒœğ•©
  ğ•©
}
_ranks â† {âŸ¨2âŸ©âŠ˜âŸ¨1,0âŸ© ((âŠ£-1+|)ËœâŸœâ‰ âŠ‘Â¨<âˆ˜âŠ¢) ValidateRanksâˆ˜ğ”½}
_depthOp_â†{
  negâ†0>nâ†ğ•¨ğ”¾_ranksğ•© â‹„ Fâ†ğ”½
  _dâ†{
    Râ†(ğ•—+neg)_d
    ğ•¨(Ã—âŸœ2âŠ¸+Â´2 Reshape (negâˆ§ğ•—â‰¥0)âˆ¨(0âŒˆğ•—)â‰¥Pairâ—‹â‰¡)â—¶âŸ¨RÂ¨â‹„RâŸœğ•©âŒœâˆ˜âŠ£â‹„(ğ•¨RâŠ¢)âŒœâˆ˜âŠ¢â‹„FâŸ©ğ•©
  }
  ğ•¨ n _d ğ•©
}
_rankOp_â†{
  kâ†ğ•¨(Pairâ—‹= (0â‰¤âŠ¢)â—¶âŸ¨âŒŠâŸœ-,0âŒˆ-âŸ©Â¨ ğ”¾_ranks)ğ•©
  Encâ†{
    fâ†(â†•ğ•¨)âŠâ‰¢ğ•©
    câ†1Ã—Â´sâ†ğ•¨Cellğ•©â‹„iâ†sâ¥Šâ†•c
    (fâ¥Š((â¥Šğ•©)âŠËœi+cÃ—âŠ¢)âŒœâ†•1Ã—Â´f)Ë™_fillBy_{(<ğ•©)âŒœi} ğ•©
  }
  Encâ†©(>âŸœ0Ã—1+â‰¥âŸœ=)â—¶âŸ¨<âŠ¢,Enc,<âŒœâŠ¢âŸ©
  > ((0âŠ‘k)Encğ•¨) ğ”½Â¨ ((1-Ëœâ‰ )âŠ¸âŠ‘k)Encğ•©
}
_insertâ†{
  "Ë: ğ•© must have rank at least 1" ! 1â‰¤=ğ•©
  Fâ†ğ”½
  Id â† {
    s â† 1â†“â‰¢ğ•©
    JoinSh â† {"Ë: Identity does not exist"!0<â‰ ğ•¨ â‹„ ğ•¨Ã—0<â†•â‰ ğ•¨}
    s Â¬âˆ˜IsJoinâˆ˜âŠ¢â—¶âŸ¨JoinShâ¥Šğ•©Ë™, ReshapeâŸœIdentityâŸ© f
  }
  ğ•¨ (0<â‰ )âŠ˜1â—¶Idâ€¿{ğ•¨FÂ´<Ë˜ğ•©} ğ•©
}

JoinToâ†âˆ¨â—‹(1<=)â—¶(âˆ¾â—‹â¥Š)â€¿{
  sâ†ğ•¨Pairâ—‹â‰¢ğ•©
  aâ†1âŒˆÂ´kâ†â‰ âŒœs
  "ğ•¨âˆ¾ğ•©: Rank of ğ•¨ and ğ•© must differ by at most 1" ! 1âˆ§Â´1â‰¥a-k
  câ†(kÂ¬a)+âŸœ(â†•a-1)âŠ¸âŠÂ¨s
  "ğ•¨âˆ¾ğ•©: Cell shapes of ğ•¨ and ğ•© must match" ! MatchSÂ´c
  lâ†0+Â´(a=k)âŠ£â—¶1â€¿(0âŠ‘âŠ¢)Â¨s
  (âŸ¨lâŸ©âˆ¾0âŠ‘c)â¥Šğ•¨âˆ¾â—‹â¥Šğ•©
} _fillBy_ IF

_repeat_â†{
  Fâ†ğ”½ â‹„ bâ†ğ•¨{ğ•âŠ£}Ë™âŠ˜{ğ•¨Ë™{ğ”½ğ•âŠ£}}0
  nâ†ğ•¨ğ”¾ğ•©
  Multiâ†{
    lâ†uâ†0
    {"âŸ: Repetition numbers in ğ•¨ğ”¾ğ•© must be integers"!Intğ•©â‹„lâ†©lâŒŠğ•©â‹„uâ†©uâŒˆğ•©}_perv n
    iâ†âŸ¨ğ•©âŸ©â‹„Pâ†BâŠ¸{ğ•`iâˆ¾â†•ğ•©}
    posâ†f P u
    negâ†f 0âŠ¸<â—¶âŸ¨i,InverseâŠ¸PâŸ© -l
    (|âŠ‘<âŸœ0âŠ‘posâ€¿negË™)_perv n
  }
  (Nat n)â—¶Multiâ€¿{ğ•©(B f)âˆ˜âŠ¢Â´â†•n} ğ•©
}

â†• â†© Range          âŠ˜ Windows
âŒ½ â† Reverse        âŠ˜ (Rot _onAxes_ 0)
/ â† Indices        âŠ˜ Replicate
Â» â† FCâŠ¸ShiftBefore âŠ˜ ShiftBefore _fillBy_ (âŠ¢âŠ˜IF)
Â« â† FCâŠ¸ShiftAfter  âŠ˜ ShiftAfter  _fillBy_ (âŠ¢âŠ˜IF)

GroupMâ†{
  "ğ•¨âŠ”ğ•©: Compound ğ•¨ must be a list" ! 1==ğ•¨
  nâ†0+Â´râ†=âŒœğ•¨
  "ğ•¨âŠ”ğ•©: Total rank of ğ•¨ must be at most rank of ğ•©" ! nâ‰¤=ğ•©
  ldâ†(Joinâ‰¢âŒœğ•¨)-nâ†‘â‰¢ğ•©
  "ğ•¨âŠ”ğ•©: Lengths of ğ•¨ must equal to ğ•©, or one more only in a rank-1 component" ! 1âˆ§Â´(0âŠ¸â‰¤âˆ§â‰¤âŸœ(r/1=r))ld
  drâ†râŒŠ(0Â»+`r)âŠldâˆ¾âŸ¨0âŸ©
  lâ†dr-Ëœâ‰ âŒœğ•¨â†©â¥ŠâŒœğ•¨ â‹„ LSâ†âˆ¾âŸœ(n Cell ğ•©) Reshape ğ•©Ë™
  Sâ†âŠâŸœ(LSâŸ¨1Ã—Â´lâŸ©)
  (LS 0âŒœğ•¨) Fill dr (1â‰ â‰ âˆ˜âŠ¢)â—¶âŸ¨S _groupâ—‹(0âŠ¸âŠ‘), SâŒœ Â·+âŒœâŒœÂ´ (âŒ½Ã—`1Â»âŒ½l) Ã— âŠ¢_groupÂ¨âŸ© ğ•¨
}

â†‘ â†© Prefixes       âŠ˜ Take
â†“ â†© Suffixes       âŠ˜ Drop
âŠ” â† GroupInds      âŠ˜ GroupGen
âŠ â† SelfClas       âŠ˜ (1 _search)
âˆŠ â† âŠ¢_self         âŠ˜ (0 _searchËœ)
â‰ â† _rankOp_

Findâ†{
  râ†=ğ•¨
  "â·ğ•©: Rank of ğ•¨ cannot exceed rank of ğ•©" ! râ‰¤=ğ•©
  0 Fill ğ•¨ â‰¡â‰r ((1+r-âŠ¸â†‘â‰¢ğ•©)âŒŠâ‰¢ğ•¨)âŠ¸â†•â‰r ğ•©
}â—‹ToArray

OccurrenceCount â† 0 Fill âŠËœ(âŠ¢-âŠ)â‹âˆ˜â‹
ProgressiveIndexOf â† 0 Fill {
  câ†1-Ëœ=ğ•¨
  "âŠ’: Rank of ğ•¨ must be at least 1" ! 0â‰¤c
  "âŠ’: Rank of ğ•© must be at least cell rank of ğ•¨" ! câ‰¤=ğ•©
  ğ•¨âŠâ—‹(PairÂ¨âŸœ(â‰¢â¥ŠOccurrenceCountâˆ˜â¥Š) ğ•¨âŠ¸âŠ)ğ•©
}

ReorderChkâ†{
  "ğ•¨â‰ğ•©: ğ•¨ must have rank at most 1" ! 1â‰¥=ğ•¨
  "ğ•¨â‰ğ•©: Length of ğ•¨ must not exceed rank of ğ•©" ! ğ•¨â‰¤â—‹â‰ â‰¢ğ•©
  "ğ•¨â‰ğ•©: ğ•¨ must consist of natural numbers" ! 1âˆ§Â´NatâŒœâ¥Šğ•¨
}
ReorderAxesSubâ†{
  (ğ•¨âŠ¸âŠPickğ•©Ë™)âŒœâ†•âŒŠÂ´âŒœğ•¨âŠ”â‰¢ğ•©
} _fillBy_ âŠ¢
ReorderAxesâ†{
  ğ•¨ ReorderChk ğ•©
  ğ•¨â†©â¥Šğ•¨
  râ†(=ğ•©)-0+Â´Â¬âˆŠğ•¨
  "ğ•¨â‰ğ•©: Skipped result axis" ! 1âˆ§Â´ğ•¨<r
  (ğ•¨âˆ¾ğ•¨(Â¬âˆ˜âˆŠËœ/âŠ¢)â†•r) ReorderAxesSub ğ•©
}
ReorderAxesInvâ†{
  ğ•¨ ReorderChk ğ•©
  ğ•¨â†©â¥Šğ•¨
  râ†=ğ•©
  IA 1âˆ§Â´(âˆŠâˆ§<âŸœr)ğ•¨
  (PermInv ğ•¨âˆ¾ğ•¨(Â¬âˆ˜âˆŠËœ/âŠ¢)â†•r) ReorderAxesSub ğ•©
}

â¼ â† {Inverse ğ•—}
_inv_ â† {ğ•˜â‹„ğ•¨ğ”½ğ•©}
_undo â† {ğ•— (â‰¢âˆ§INFË™âŠ¸â‰¢)â—¶0â€¿((5=0âŠ¸âŠ‘)â—¶1â€¿(invË™â‰¢(â‰ -2Ë™)âŠ¸âŠ‘)âˆ˜DecomposeâŠ¢)â—¶âŠ¢â€¿{ğ•_inv_(ğ•_invChk_ğ•)} Inverse ğ•—}
IsConstant â† (3â‰¤Type)â—¶âŸ¨1 â‹„ (4=0âŠ¸âŠ‘)â—¶0â€¿('Ë™'_isGlyph(â‰ -1Ë™)âŠ¸âŠ‘)âˆ˜{Decomposeğ•©}âŠ¢âŸ©
AtopInverse â† {(ğ•ğ•)âŠ˜(ğ•âŸœğ•)}â—‹{Inverseğ•©}
TrainInverse â† {
  tâ€¿fâ€¿gâ€¿hâ†ğ•©
  Kâ†Â¬IsConstant
  f Kâˆ˜âŠ£â—¶âŸ¨{ğ•â¼{ğ•¨ğ”½ğ”¾ğ•©}(ğ•¨Gâ¼âŠ¢)},Kâˆ˜âŠ¢â—¶âŸ¨{ğ•â¼ğ•©G{SwapInverseğ•—}âŠ¢},INFË™âŸ©âŸ© h
}
FuncInverse â† (0âŠ¸âŠ‘ âŠ£â—¶âŸ¨
  {PrimInverseğ•©} 1âŠ¸âŠ‘                     # 0 primitive
  ("Cannot currently invert blocks"!0Ë™)Ë™ # 1 block
  1âŠ¸âŠ‘ AtopInverse 2âŠ¸âŠ‘                    # 2-train
  TrainInverse                           # 3-train
  1âŠ¸âŠ‘    {ğ•ğ•¨}âŸœ{Mod1Inverseğ•©} 2âŠ¸âŠ‘         # 4 1-modifier
  1â€¿3âŠ¸âŠ {ğ•Â´ğ•¨}âŸœ{Mod2Inverseğ•©} 2âŠ¸âŠ‘         # 5 2-modifier
âŸ© âŠ¢) {Decomposeğ•©}
Inverse â† Typeâ—¶(3â€¿1â€¿2/{âŠ¢âŠ£ğ•©IXâˆ˜â‰¡âŠ¢}â€¿FuncInverseâ€¿("Cannot invert modifier"!0Ë™))

âˆ¾ â†© Join           âŠ˜ JoinTo
IA â† "â¼: Inverse failed"âŠ¸!
IX â† "â¼: Inverse does not exist"âŠ¸!
INFâ† "â¼: Inverse not found"!0Ë™
_invChk_ â† {iâ†ğ•¨ğ”½ğ•©â‹„IX ğ•©â‰¡ğ•¨ğ”¾iâ‹„i}
GroupIndsInv â† {
  IA 2=â‰¡ğ•©
  IX 1âˆ§Â´1==âŒœğ•©
  jâ†âˆ¾ğ•©
  IX 1âˆ§Â´NatâŒœj
  IX 1âˆ§Â´j>âˆ¾Â¯1Â»Â¨ğ•©
  gâ†GroupLen j
  IX 1âˆ§Â´gâ‰¤1
  oâ†/Â¬g
  (â‹jâˆ¾o)âŠ(/â‰ Â¨ğ•©)âˆ¾Â¯1Â¨o
}
GroupInv â† {
  IA 1==ğ•¨
  IA 1âˆ§Â´NatâŒœğ•¨
  iâ†âŠ”ğ•¨
  IX iâ‰¡â—‹(â‰ Â¨)ğ•©
  i â‹âŠ¸âŠâ—‹âˆ¾ ğ•©
}
âŠ â†© FirstCell      âŠ˜ (ToArrayâŠ¸(SelSub _onAxes_ 1)) _fillBy_ âŠ¢
PrimInverse â† INF _lookup_ âŸ¨
  '+', +âŠ˜(-Ëœ)
  '-', -
  'Ã—', âŠ¢_invChk_Ã—âŠ˜(Ã·Ëœ)
  'Ã·', Ã·
  'â‹†', Log _perv
  'âˆš', Ã—ËœâŠ˜(â‹†Ëœ)
  'âˆ§', âŠ¢_invChk_âˆ§âŠ˜(Ã·Ëœ)
  'âˆ¨', âŠ¢_invChk_âˆ¨âŠ˜(-ËœÃ·1-âŠ£)
  'Â¬', Â¬
  '<', {IX IsArrayğ•©â‹„IX 0==ğ•©â‹„0âŠ‘â¥Šğ•©}âŠ˜(IAâˆ˜0)
  'âŠ¢', âŠ¢
  'âŠ£', âŠ¢âŠ˜(âŠ¢âŠ£IXâˆ˜â‰¡)
  'âˆ¾', IAâˆ˜0 âŠ˜ {dâ†ğ•©-â—‹=ğ•¨â‹„IX(0âŠ¸â‰¤âˆ§â‰¤âŸœ1)dâ‹„lâ†dâ—¶1â€¿â‰ ğ•¨â‹„IX lâ‰¤â‰ ğ•©â‹„IX ğ•¨â‰¡dâ—¶âŸ¨âŠ,lâŠ¸â†‘âŸ©ğ•©â‹„lâ†“ğ•©}
  'â‰', {IX 1=â‰ ğ•©â‹„âŠğ•©} âŠ˜ {IX 2=â‰ ğ•©â‹„IX ğ•¨â‰¡âŠğ•©â‹„1âŠğ•©}
  'â†‘', Â¯1âŠ¸âŠ‘_invChk_â†‘ âŠ˜ (IAâˆ˜0)
  'â†“',  0âŠ¸âŠ‘_invChk_â†“ âŠ˜ (IAâˆ˜0)
  'â†•', â‰¢_invChk_â†• âŠ˜ (IAâˆ˜0)  # Should trace edge and invChk
  'âŒ½', âŒ½ âŠ˜ (-âŠ¸âŒ½)
  'â‰', TransposeInv âŠ˜ ReorderAxesInv
  '/', {IA 1==ğ•©â‹„IA 1âˆ§Â´NatâŒœğ•©â‹„IX(1âˆ§Â´Â¯1âŠ¸â†“â‰¤1âŠ¸â†“)ğ•©â‹„GroupLenğ•©}âŠ˜(IAâˆ˜0)
  'âŠ”', GroupIndsInv âŠ˜ GroupInv
âŸ©
SwapInverse â† INF _lookup_ âŸ¨
  '+', Ã·âŸœ2âŠ˜(-Ëœ)
  '-', IAâˆ˜0âŠ˜+
  'Ã—', âˆšâŠ˜(Ã·Ëœ)
  'Ã·', IAâˆ˜0âŠ˜Ã—
  'â‹†', IAâˆ˜0âŠ˜âˆš
  'âˆš', IAâˆ˜0âŠ˜(Ã·Log)
  'âˆ§', âˆšâŠ˜(Ã·Ëœ)
  'âˆ¨', (Â¬âˆšâˆ˜Â¬)âŠ˜(-ËœÃ·1-âŠ£)
  'Â¬', IAâˆ˜0âŠ˜(+-1Ë™)
âŸ©
âŒœ â†© {ğ•¨ğ”½âŒœ_fillByPure_ğ”½â—‹ToArrayğ•©}
Mod1Inverse â† INFË™ _lookup_ âŸ¨
  'Ëœ', SwapInverse
  'Â¨', {ğ•â¼Â¨                     âŠ£Â·IX 0<â‰¡âˆ˜âŠ¢}
  'âŒœ', {ğ•â¼âŒœâŠ˜(IAâˆ˜0)              âŠ£Â·IX 0<â‰¡âˆ˜âŠ¢}
  'Ë˜', {(IXâˆ˜IsArrayâŠ¸âŠ¢ğ•â¼)Ë˜       âŠ£Â·IX 0<=âˆ˜âŠ¢}
  '`', {(âŠâˆ¾Â¯1âŠ¸â†“ğ•1âŠ¸â†“)âŸ(1<â‰ )âŠ˜(Â»ğ•âŠ¢)âŠ£Â·IX 0<=âˆ˜âŠ¢}âˆ˜{ğ•â¼Â¨}
âŸ©
âŸ â†© _repeat_
âŒ¾ â† _under_
Mod2Inverse â† INFË™ _lookup_ âŸ¨
  'âˆ˜', AtopInverse
  'â—‹', {Fiâ†ğ•â¼â‹„ğ•â¼ FiâŠ˜(ğ•âŠ¸Fi)}
  'âŒ¾', {ğ•â¼âŒ¾ğ•}  # Need to verify for computation Under
  'âŸ', Intâˆ˜âŠ¢â—¶âŸ¨IAâˆ˜0Ë™,0âŠ¸â‰¤â—¶{ğ•âŸ(-ğ•©)_invChk_(ğ•âŸğ•©)}â€¿{ğ•âŸ(-ğ•©)}âŸ©
  'âŠ˜', {(ğ•â¼)âŠ˜(ğ•â¼)}
  'âŠ¸', IsConstantâˆ˜âŠ£ âŠ£â—¶{INFâŠ˜ğ•}â€¿âŠ¢ {ğ•âŠ¸(ğ•â¼)}
  'âŸœ', {(ğ•¨IsConstantâˆ˜âŠ¢â—¶âŸ¨IAâˆ˜0Ë™,{ğ•©ğ•{SwapInverseğ•—}âŠ¢}âŸ©ğ•©)âŠ˜(ğ•â¼ğ•â¼)}
âŸ© { invË™âŠ¸=â—¶âŸ¨ğ”½,{ğ•_inv_ğ•}Ë™âŸ© }

Ë â† _insert
â¼ â†© _undo
âŠ‘ â†© First          âŠ˜ Pick
â—¶ â†© {ğ•¨((ğ•¨ğ”½ğ•©)âŠ‘ğ•˜){ğ”½}ğ•©}  # Same definition, new Pick
âš‡ â† _depthOp_
â¥Š â†© Deshape        âŠ˜ Reshape
â‰ â† >âˆ˜Pair _fillBy_ (âŠ¢âŠ˜IF)
â‰ â† Transpose      âŠ˜ ReorderAxes
âŠ’ â† OccurrenceCountâŠ˜ ProgressiveIndexOf
â· â† âˆŠâŠ¸/            âŠ˜ Find
