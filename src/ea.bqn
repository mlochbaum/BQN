# Syntax highlighting utilities for e.bqn; copied from ../md.bqn
# It should be getting this information from the tokenizer instead

Modify â† { âŸ¨include,add,posâŸ©â†ğ•¨
  ((/include)âˆ¾(â‰ Â¨add)/pos) â‹âŠ¸âŠ (include/ğ•©)âˆ¾âˆ¾add
}

# Return BQN highlights for an string ğ•©, as an âŸ¨add,posâŸ© list for Modify
# (include will be all 1s).
lf â† @+10
FindGroup â† {
  i â† (âˆ¾ğ•¨) âŠ ğ•©  # Index in all cells of ğ•¨
  e â† +`â‰ Â¨ğ•¨     # Index past the end of each group of ğ•¨
  e â‹ i         # How many end-indices does each element pass?
}
Trace â† {
  # ğ•¨ is a list with one index for each possible start, giving a later
  # start that is known to be enabled if that one is.
  # ğ•© is a mask of all starts known to be enabled.
  # A "stop" position that follows all expressions tells when to stop.
  # At each step the distance from a start to its successor in ğ•¨ is
  # doubled, so the maximum number of steps is about 2â‹†â¼â‰ ğ•©.
  En â† {
    ğ•© â†© 1Â¨âŒ¾((ğ•©/ğ•¨)âŠ¸âŠ)ğ•©  # Starts following from an enabled one are enabled
    ğ•¨ â†© âŠËœ ğ•¨           # Double the number of steps in ğ•¨
    ğ•¨ En ğ•©             # Repeat
  }âŸ{0=Â¯1âŠ‘ğ•©}           #        until the stop is enabled

  g â† â‹ğ•¨               # Order expressions by starting index
  start â† gâŠğ•¨
  end   â† gâŠğ•©
  next â† start â‹ end   # An expression's successor starts after it ends
  next âˆ¾â†© â‰ next        # The stop node is its own successor
  enabled â† Â¯1 â†“ next En (â‰ next)â†‘1  # Search and remove the stop
  enabled / startâ‰Ë˜end # List of enabled starts and ends
}
idChars â† âŸ¨
  ('0'+â†•10)âˆ¾"Â¯.Ï€âˆ"
  "ğ•£"âˆ¾Ëœ'a'+â†•26
  'A'+â†•26
  "_"
âŸ©
GetHighlights â† {
  # Characters used by BQN, and the HTML class they are associated with.
  classesâ€¿chars â† <Ë˜ â‰ âˆ˜â€¿2â¥ŠâŸ¨
    0             , " "âˆ¾@+9â€¿10  # Should never be highlighted
    "Value"       , Â¯1âŠË˜5â€¿2â¥Š"ğ•¨ğ•©ğ•—ğ•˜ğ•¤"# Hack around UTF-16
    "Function"    , "+-Ã—Ã·â‹†âˆšâŒŠâŒˆ|Â¬âˆ§âˆ¨<>â‰ =â‰¤â‰¥â‰¡â‰¢âŠ£âŠ¢â¥Šâˆ¾â‰â†‘â†“â†•Â«Â»âŒ½â‰/â‹â’âŠâŠ‘âŠâŠ’âˆŠâ·âŠ”!"âˆ¾Â¯1âŠË˜5â€¿2â¥Š"ğ•ğ•ğ”½ğ”¾ğ•Š"
    "Modifier"    , "Ë™ËœË˜Â¨âŒœâ¼Â´Ë`"
    "Modifier2"   , "âˆ˜â—‹âŠ¸âŸœâŒ¾âŠ˜â—¶â‰âš‡âŸâŠ"
    "Number"      , âˆ¾idChars       # Will be classified among â†‘â†‘ later
    "Gets"        , "â†â‡â†©â†’"
    "Paren"       , "()"
    "Bracket"     , "âŸ¨âŸ©"
    "Brace"       , "{}"
    "Ligature"    , "â€¿"
    "Nothing"     , "Â·"
    "Separator"   , "â‹„,"
    "String"      , "'""@"
    "Comment"     , "#"
  âŸ©
  # Turn non-whitespace classes into âŸ¨open,closeâŸ© html tags.
  classTag â† ""â€¿"" âˆ¾ > {âŸ¨"<span class='"âˆ¾ğ•©âˆ¾"'>","</span>"âŸ©}Â¨ 1â†“classes

  # Find each character's group, sending unknowns to 1.
  col â† (â‰ chars) (âŠ¢--âŸœ1Ã—=) chars FindGroup ğ•©

  # Locate comments and strings.
  c â† ğ•©='#'
  leâ† /(ğ•©=lf)âˆ¾1
  # Line endings (le) end every comment (/c) on the line, so take a copy
  # for each # before that line but not the previous.
  ceâ† le /Ëœ -âŸœÂ» c/âŠ¸â‹le
  # A single quote can only be used if there's another two places down.
  s â† /0â€¿0âŠ¸Â«âŠ¸âˆ§ğ•©='''
  d â† /ğ•©='"'
  css â† âŸ¨ s   â‹„ Â¯1â†“d â‹„ /c âŸ© # Comment or string start
  cse â† âŸ¨ 2+s â‹„  1â†“d â‹„ ce âŸ© # Corresponding end indices
  # Now b is a table of (start,end) pairs
  b â† css Traceâ—‹âˆ¾ cse
  # Given a list of pairs, get a mask indicating included regions
  ToMask â† (â‰ `âˆ¨âŠ¢) (â‰ ğ•©)â†‘/â¼âˆ˜âˆ¾
  # Split rows and group into textâ€¿comments
  tc â† ((âŠË˜b)âŠc) 2{ğ•—â†‘âŠ”â—‹(âˆ¾âŸœğ•—)} <Ë˜b
  # Color with "String" and "Comment"
  col âŒˆâ†© +Â´ (2â€¿1-Ëœâ‰ classes) Ã— ToMaskÂ¨ tc

  # UTF-16 hack: first half of a special name needs to match the second
  colâ†© (Â«col) âŠ£âŒ¾((ğ•©=âŠ‘"ğ•©")âŠ¸/) col

  # Color numeric literals and identifiers
  id â† col=5                 # â†â†’ ğ•©âˆŠidChars
  w  â† Â»âŠ¸< id                # Word (identifier or number) beginning mask
  wt â† idChars FindGroup w/ğ•© # Type based on first character
  wt+â†© '_' = (Â«âŠ¸<id)/ğ•©       # Modifier1 to Modifier2 based on word end
  wt+â†© 5Ã—0=wt                # Shift 0 to Number
  wi â† 1-Ëœ+`id/w             # Index of word containing each of /id
  colâ†©(wiâŠwt)âŒ¾(idâŠ¸/) col

  # Tags are placed at boundaries between different colors
  boundary â† Â¯1âŠ¸Â»âŠ¸â‰  col
  bcol â† boundary / col
  # Windows gives us rows of start,end where the end position of one
  # color is the start of the next
  # Subtract one to place before the starting character
  pos â† 2 â†• 1-Ëœ/boundaryâˆ¾1
  # Remove class 0 regions, as these don't use tags
  (â¥Š (0<bcol)âŠ¸/)Â¨ âŸ¨bcolâŠclassTag, posâŸ©
}
