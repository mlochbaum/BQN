# Compiles the twice-simplified compiler
# This file isn't part of the bootstrapping chain as its syntax is
# more complicated than boot2. It shows how boot2 can be compiled.
{
  charSetâ†âˆ¾charsâ†âŸ¨
    "+-Ã—Ã·â‹†âˆšâŒŠâŒˆ|Â¬âˆ§âˆ¨<>â‰ =â‰¤â‰¥â‰¡â‰¢âŠ£âŠ¢â¥Šâˆ¾â‰â‹ˆâ†‘â†“â†•Â«Â»âŒ½â‰/â‹â’âŠâŠ‘âŠâŠ’âˆŠâ·âŠ”!" # Function
    "Ë™ËœË˜Â¨âŒœâ¼Â´Ë`"           # 1-modifier
    "âˆ˜â—‹âŠ¸âŸœâŒ¾âŠ˜â—¶â‰âš‡âŸâŠ"         # 2-modifier
    "â‹„,"âˆ¾lfâ†@+10          # Separator
    "â†â†©"                  # Gets
    "(){}âŸ¨âŸ©"              # Bracket
    "ğ•Šğ•©ğ•¨"                 # Input
    "Â¯Ï€âˆ"                 # Numeric
    (âŠ‘"0")+â†•10            # Digit
    â¥Š"aA"+âŒœâ†•naâ†26         # Alphabetic
    " "                   # Whitespace
    scâ†"#""@"             # Preprocessed characters
  âŸ©
  cmâ†â‹ˆÂ¨ËœâŸœ(0Â»+`)cglâ†â‰ Â¨chars
  bSâ†3âŠ‘cmâ‹„bGâ†4âŠ‘cmâ‹„bBâ†5âŠ‘cmâ‹„bIâ†6âŠ‘cmâ‹„bNâ†7âŠ‘cmâ‹„bAâ†9âŠ‘cmâ‹„bWâ†10âŠ‘cm
  Mâ†1âŠ¸âŠ‘(0âŠ¸â‰¤âˆ§>)-âŸœâŠ‘   # âˆŠ for an init,length pair ğ•© as above
  sepâ†âŠ‘bS
  viâ†âŠ‘bN  # Start of identifier numbering
  charRoleâ†âˆ¾cglâ¥ŠÂ¨âŸ¨1,2,3,Â¯1,Â¯3,âŸ¨Â¯1,0âŸ©,âŸ¨1,0,0âŸ©,0,0,26/âŸ¨0,1âŸ©,4,0âŸ©
  TTâ†âŒˆ`Ã— â‹„ ITâ†â†•âˆ˜â‰ âŠ¸TT

  # Comments and strings
  sâ†â‰ `ddâ†ğ•©=1âŠ‘scâ‹„ssâ†sâˆ§dd                     # Strings; string start
  fâ†s<(s<ğ•©=âŠ‘sc)â‰¤â—‹((1+â†•âˆ˜â‰ )âŠ¸TT)ğ•©=lf           # Filter comments
  chrâ†@Â¨ciâ†/fâˆ§ğ•©=2âŠ‘sc                        # Characters (indices ci)
  strâ†ğ•©âŠ”Ëœ1-Ëœ(+`ssâˆ¾1)Ã—(ss<s)âˆ¾1               # Strings

  # Extract words: identifiers and numbers
  tâ†charSetâŠf/ğ•©                             # Tokens
  râ†tâŠcharRole                              # Role
  wâ†Â»âŠ¸<lâ†t M bN(âŠ£â‹ˆ-Ëœ)â—‹âŠ‘bW                   # Word chars l, start w
  wiâ†(âŠ‘bA)â‰¤w/t                              # Type: 0 number, 1 identifier
  tâ†©t-naÃ—lâˆ§r=1                              # Case-insensitive
  nâ†lâˆ§(+`w)âŠ0âˆ¾Â¬wi                           # Number mask
  ideâ†(1-Ëœ(l>n)Ã—+`w>n)âŠ”tâŠcharSet            # Identifiers

  # Numbers, at most 2 digits
  ntâ†(âˆ¨âŸœÂ«0âˆ¾n)/0âˆ¾tÃ—l                         # Number tokens separated by 0
  nnâ†nt=âŠ‘bNâ‹„nmâ†Â¬nnâˆ¨0=nt                     # Mask for Â¯; digits
  nlâ†(0âˆ¾âŸ¨Ï€,âˆâŸ©âˆ¾â†•10)âŠËœnmÃ—nt-âŠ‘bN               # Digit lookup
  nsâ†âŸ¨1,Â¯1âŸ©âŠËœ(>âŸœÂ»nm)/Â»nn                    # Negate if Â¯
  numâ†nsÃ—(>âŸœÂ«nm)/(10Ã—Â»)âŠ¸+nl                 # Numeric values

  # Deduplicate literals and identifiers; other cleanup
  # Identifiers then literal tokens are numbered starting at vi
  kiâ†(wiâ’âŠ¸âŠ/w)âˆ¾(ciâˆ¾/ss)âŠ+`Â»f                # Indices in t
  kâ†âŸ¨ide,âŸ¨âŸ©,num,chr,strâŸ©                    # Constants
  kâ†©k(âŠ¢>Â¯1Â»âŒˆ`)âŠ¸/Â¨Ëœjâ†âŠÂ¨k                     # IDs j into uniques k
  wrâ†wâˆ¨Â¬lâˆ¨t M bWâ‹„râ†©wr/r
  tâ†©wr/(âˆ¾j++`viÂ»â‰ Â¨k)âŒ¾(kiâŠ¸âŠ)t                # Add IDs; remove words/whitespace
  tâ†©t-t(MÃ—-âŸœâŠ‘)bS                            # Separators are equivalent
  pbâ†â‰ `1Â¨sbâ†Â¯1â†“1â†“/1(âˆ¾â‰ âˆ¾Ëœ)t=sep              # Separator group boundaries (excludes leading and trailing)
  ebâ†âŸ¨3,5âŸ©+âŠ‘bB                              # End brackets that allow separators
  skâ†sb/Ëœpb>âˆ¨âŸœÂ«ebâˆŠËœpb+(sb-pb)âŠt             # Keep the first of each group that's not just inside a bracket
  srâ†(tâ‰ âŠ¸â†‘/â¼sk)âˆ¨tâ‰ sepâ‹„râ†©sr/râ‹„tâ†©sr/t         # Remove the rest
  ğ•©â†©tâ‹„nvâ†â‰ âŠ‘k
  # End of tokenization!

  # Bracket roles
  # Open brackets initially have role Â¯1 and closed ones have role 0
  gbâ†â‹+`pâ†(Â¯1-2Ã—r)Ã—ğ•© M bB                   # Paren (actually any bracket type) depth and grade
  râ†©r+ğ•©=3+âŠ‘bB                               # Assume blocks are functions
  cpâ†ğ•©=1+âŠ‘bB                                # Closed paren
  irâ†(IT cpâŠ¸â‰¤)âŠ¸âŠ0<r                         # Role of the expression ending at each position
  râ†©r+cpÃ—Â»ir                                # Roles at cp were 0; set them now

  # Reverse each expression: *more* complicated than it looks
  revâ†â‹+`Â¯1â†“(Â¯1âˆ¾gb)(âŠ£â‹âŠ¸âŠâŠËœâŸœâ‹Â¬âŠËœ)â‹+`âŠ¸+1âˆ¾gbâŠr=Â¯1

  # Lexical resolution, no nesting
  rxâ†revâŠğ•©
  ivâ†/(rxâ‰¥âŠ‘bI)âˆ§rx<vi+nv                     # Variable indices
  vvâ†(ivâŠrx)-vi                             # Variable name
  iiâ†3â†“âŠ(Â¯3+â†•3)âˆ¾vv                          # Slot within frame
  vbâ†bG MËœ vaâ†ivâŠÂ»rx                        # Variable assignment, if it's there
  idorâ†âˆ¾3/âŸ¨ivâŸ©                              # Identifier bytecode ordering
  idocâ†âŸ¨32+vb,0Â¨ii,iiâŸ©                      # Identifier bytecode: instruction, depth, slot
  dnâ†âŸ¨âŸ¨âŸ©,(va=âŠ‘bG)/vvâŸ©                       # Identifier name ID, per-block

  # Parsing
  grâ†revâŠËœgâ†â‹+`revâŠp                        # Order by bracket depth
  ğ•©â†©grâŠğ•©â‹„râ†©grâŠrâ‹„irâ†©grâŠir
  atâ†/aaâ†Â»aâ†Â¯3=r                            # Assignment target
  aoâ†(a/ğ•©)-âŠ‘bG                              # Assignment opcode
  trâ†irâŠËœITÂ»psâ†a<r<0                        # tr: train or modifier expression, ps: part separator
  oaâ†âŒ½/opâ†r=2                               # op: active modifiers; op: mod or right operand
  xsâ†ğ•©=sepâ‹„foâ†ğ•©=2+âŠ‘bB                       # Separators, function open {
  lsâ†xsâˆ§fo<â—‹IT loâ†ğ•©=4+âŠ‘bB                   # List Separators: after âŸ¨lo, not {fo
  taâ†trâˆ§2(>âˆ¨|)ps(âŠ¢-TT)+`Â¬op                 # Train argument (first-level)
  faâ†/(taâˆ¨opâˆ¨aa)<(r=1)âˆ¨Â»op                  # Active functions
  dyâ†faâŠÂ«(trâˆ§râ‰¥0)âˆ¨op<r=0                    # Dyadic
  prâ†ğ•©âŠËœpiâ†/ğ•©<sepâ‹„obâ†prâŠËœuâ†âˆ§â·pr             # Objects to be loaded
  cnâ†piâˆ¾ltâ†/ğ•©â‰¥clâ†vi+nvâ‹„obâ†©obâˆ¾(cl-Ëœâ‰ u)+ltâŠğ•©  # Constants
  bkâ†/ğ•©=2+âŠ‘bB                               # Block loads
  lbâ†/ğ•©=5+âŠ‘bB                               # List starts
  llâ†(Â¬lo/1Â«ps)+-âŸœÂ»1â†“(loâˆ¾1)/+`lsâˆ¾0          # List Length
  drâ†/xs>lsâ‹„rtâ†/fo                          # Drop (block separator) and return
  osâ†âŒ½â†•âˆ˜â‰ âŠ¸(âŠ£-TT)âŒ½Â¬op                        # Operator skip: distance rightward to derived function start
  flâ†(dyÃ—âŠâŸœos)âŠ¸+fa+dy                       # Function application site

  # Object code generation: numbers oc ordered by source location (after rev) oi
  fscâ†3Ã—fxâ†â†•2                               # Body immediacy Â¬fx, special name count
  orâ†â‹idorâˆ¾gâŠËœâˆ¾âŸ¨cn,cn,bk,bk,2/lb,at,dr,oa+1âŒˆoaâŠos,fl,rtâŸ©
  ocâ†orâŠâˆ¾idocâˆ¾âŸ¨0Â¨cn,ob,1Â¨bk,1+â†•â‰ bk,â¥Šâ‰(11+lbâŠaa)â‰ll,48+ao,6Â¨dr
               24+oaâŠr,16+dy+4Ã—faâŠtr,Â¯1â†“rcâ†7Â¨fxâŸ©
  # Output
  fzâ†âŸ¨0Â¨fx,Â¬fx,â†•â‰ fxâŸ©                        # Per-function data
  czâ†âŸ¨/1âˆ¾orâ‰¥oc-â—‹â‰ rt,fsc+â‰ Â¨dn,dn,0Â¨Â¨dnâŸ©      # Per-body data
  âŸ¨ocâˆ¾Â¯1âŠ‘rc,âˆ¾âŸ¨uâŠğ•¨âŸ©âˆ¾1â†“k,<Ë˜â‰>fz,<Ë˜â‰>czâŸ©       # Overall output
}
