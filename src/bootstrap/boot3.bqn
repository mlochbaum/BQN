# Compiles the twice-simplified compiler
# This file isn't part of the bootstrapping chain as its syntax is
# more complicated than boot2. It shows how boot2 can be compiled.
{
  charSetâ†âˆ¾charsâ†âŸ¨
    "+-Ã—Ã·â‹†âˆšâŒŠâŒˆ|Â¬âˆ§âˆ¨<>â‰ =â‰¤â‰¥â‰¡â‰¢âŠ£âŠ¢â¥Šâˆ¾â‰â‹ˆâ†‘â†“â†•Â«Â»âŒ½â‰/â‹â’âŠâŠ‘âŠâŠ’âˆŠâ·âŠ”!" # Function
    "Ë™ËœË˜Â¨âŒœâ¼Â´Ë`"           # 1-modifier
    "âˆ˜â—‹âŠ¸âŸœâŒ¾âŠ˜â—¶â‰âš‡âŸâŠ"         # 2-modifier
    "â‹„,"âˆ¾lfâ†@+10          # Separator
    "â†â†©"                  # Gets
    "(){}âŸ¨âŸ©"              # Bracket
    "ğ•Šğ•©ğ•¨"                 # Input
    "Â¯Ï€âˆ"                 # Numeric
    (âŠ‘"0")+â†•10            # Digit
    â¥Š"aA"+âŒœâ†•naâ†26         # Alphabetic
    " "                   # Whitespace
    scâ†"#""@"             # Preprocessed characters
  âŸ©
  cmâ†â‹ˆÂ¨ËœâŸœ(0Â»+`)cglâ†â‰ Â¨chars
  bSâ†3âŠ‘cmâ‹„bGâ†4âŠ‘cmâ‹„bBâ†5âŠ‘cmâ‹„bIâ†6âŠ‘cmâ‹„bNâ†7âŠ‘cmâ‹„bAâ†9âŠ‘cmâ‹„bWâ†10âŠ‘cm
  Mâ†1âŠ¸âŠ‘(0âŠ¸â‰¤âˆ§>)-âŸœâŠ‘   # âˆŠ for an init,length pair ğ•© as above
  viâ†âŠ‘bN  # Start of identifier numbering
  charRoleâ†âˆ¾cglâ¥ŠÂ¨âŸ¨1,2,3,Â¯1,Â¯3,âŸ¨Â¯1,0âŸ©,âŸ¨1,0,0âŸ©,0,0,26/âŸ¨0,1âŸ©,4,0âŸ©
  TTâ†âŒˆ`Ã— â‹„ ITâ†â†•âˆ˜â‰ âŠ¸TT

  # Comments and strings
  sâ†â‰ `ddâ†ğ•©=1âŠ‘scâ‹„ssâ†sâˆ§dd                     # Strings; string start
  fâ†s<(s<ğ•©=âŠ‘sc)â‰¤â—‹((1+â†•âˆ˜â‰ )âŠ¸TT)ğ•©=lf           # Filter comments
  chrâ†@Â¨ciâ†/fâˆ§ğ•©=2âŠ‘sc                        # Characters (indices ci)
  strâ†ğ•©âŠ”Ëœ1-Ëœ(+`ssâˆ¾1)Ã—(ss<s)âˆ¾1               # Strings

  # Extract words: identifiers and numbers
  tâ†charSetâŠf/ğ•©                             # Tokens
  râ†tâŠcharRole                              # Role
  wâ†Â»âŠ¸<lâ†t M bN(âŠ£â‹ˆ-Ëœ)â—‹âŠ‘bW                   # Word chars l, start w
  wiâ†(âŠ‘bA)â‰¤w/t                              # Type: 0 number, 1 identifier
  tâ†©t-naÃ—lâˆ§r=1                              # Case-insensitive
  nâ†lâˆ§(+`w)âŠ0âˆ¾Â¬wi                           # Number mask
  ideâ†(1-Ëœ(l>n)Ã—+`w>n)âŠ”tâŠcharSet            # Identifiers

  # Numbers, at most 2 digits
  ntâ†(âˆ¨âŸœÂ«0âˆ¾n)/0âˆ¾tÃ—l                         # Number tokens separated by 0
  nnâ†nt=âŠ‘bNâ‹„nmâ†Â¬nnâˆ¨0=nt                     # Mask for Â¯; digits
  nlâ†(0âˆ¾âŸ¨Ï€,âˆâŸ©âˆ¾â†•10)âŠËœnmÃ—nt-âŠ‘bN               # Digit lookup
  nsâ†âŸ¨1,Â¯1âŸ©âŠËœ(>âŸœÂ»nm)/Â»nn                    # Negate if Â¯
  numâ†nsÃ—(>âŸœÂ«nm)/(10Ã—Â»)âŠ¸+nl                 # Numeric values

  # Deduplicate literals and identifiers; other cleanup
  # Identifiers then literal tokens are numbered starting at vi
  kiâ†(wiâ’âŠ¸âŠ/w)âˆ¾(ciâˆ¾/ss)âŠ+`Â»f                # Indices in t
  kâ†âŸ¨ide,âŸ¨âŸ©,num,chr,strâŸ©                    # Constants
  kâ†©k(âŠ¢>Â¯1Â»âŒˆ`)âŠ¸/Â¨Ëœjâ†âŠÂ¨k                     # IDs j into uniques k
  wrâ†wâˆ¨Â¬lâˆ¨t M bWâ‹„râ†©wr/r                     # Remove words/whitespace
  tâ†©wr/(âˆ¾j++`viÂ»â‰ Â¨k)âŒ¾(kiâŠ¸âŠ)t                # Add IDs
  pbâ†â‰ `1Â¨sbâ†Â¯1â†“1â†“/1(âˆ¾â‰ âˆ¾Ëœ)tsâ†t M bS          # Separator group boundaries (excludes leading and trailing)
  ebâ†âŸ¨3,5âŸ©+âŠ‘bB                              # End brackets that allow separators
  skâ†sb/Ëœpb>âˆ¨âŸœÂ«ebâˆŠËœpb+(sb-pb)âŠt             # Keep the first of each group that's not just inside a bracket
  srâ†tsâ‰¤tâ‰ âŠ¸â†‘/â¼skâ‹„râ†©sr/râ‹„tâ†©sr/t              # Remove the rest
  ğ•©â†©tâ‹„evâ†vi+â‰ âŠ‘k

  # Bracket roles
  # Open brackets initially have role Â¯1 and closed ones have role 0
  gbâ†â‹+`pâ†(Â¯1-2Ã—r)Ã—ğ•© M bB                   # Paren (actually any bracket type) depth and grade
  râ†©r+ğ•©=3+âŠ‘bB                               # Assume blocks are functions
  cpâ†ğ•©=1+âŠ‘bB                                # Closed paren
  râ†©r+cpÃ—Â»(IT cpâŠ¸â‰¤)âŠ¸âŠ0<r                    # Propagate functions through parens

  # Reverse each expression: *more* complicated than it looks
  revâ†â‹+`Â¯1â†“(Â¯1âˆ¾gb)(âŠ£â‹âŠ¸âŠâŠËœâŸœâ‹Â¬âŠËœ)â‹+`âŠ¸+1âˆ¾gbâŠr=Â¯1
  grâ†revâŠËœgâ†â‹+`revâŠp                        # Then order by bracket depth
  ğ•©â†©grâŠğ•©â‹„râ†©grâŠr

  # Constants
  uâ†âˆ§â·prâ†ğ•©âŠËœpiâ†/ğ•©<âŠ‘bSâ‹„ltâ†/ğ•©â‰¥ev              # Primitives and literals
  cnâ†piâˆ¾ltâ‹„obâ†(uâŠpr)âˆ¾(ev-Ëœâ‰ u)+ltâŠğ•©          # Locations and object numbers
  # Blocks and lists
  xsâ†ğ•© M bSâ‹„psâ†r=Â¯1                         # Separator token; part separator includes {âŸ¨
  bkâ†/ğ•©=2+âŠ‘bBâ‹„rtâ†bk                         # Block load and return
  lbâ†/ğ•©=5+âŠ‘bB                               # List starts
  lsâ†xsâˆ§âˆ¨`loâ†ğ•©=4+âŠ‘bB                        # List Separators after âŸ¨lo
  drâ†/ls<xs                                 # Drop at block separators
  llâ†(Â¬lo/1Â«ps)+-âŸœÂ»1â†“(loâˆ¾1)/+`lsâˆ¾0          # List Length
  # Assignment
  atâ†/aaâ†Â»aâ†r=Â¯3                            # Assignment target
  aoâ†(a/ğ•©)-âŠ‘bG                              # Assignment opcode
  vâ†/(ğ•©â‰¥âŠ‘bI)âˆ§ğ•©<ev                           # Variable indices
  vsâ†(vâŠğ•©)-âŠ‘bI                              # Variable slot
  # Functions and modifiers
  trâ†0<râŠËœITÂ»ps                             # Train
  oaâ†/opâ†r=2                                # Modifier
  taâ†trâˆ§2(>âˆ¨|)ps(âŠ¢-TT)+`Â¬op                 # Train argument (first-level)
  faâ†/(taâˆ¨opâˆ¨aa)<(r=1)âˆ¨Â»op                  # Active function
  osâ†âŒ½â†•âˆ˜â‰ âŠ¸(âŠ£-TT)âŒ½Â¬op                        # Operator skip: distance rightward to derived function start
  dyâ†faâŠÂ«(trâˆ§râ‰¥0)âˆ¨op<r=0                    # Dyadic
  flâ†(dyÃ—âŠâŸœos)âŠ¸+fa+dy                       # Function application site
  olâ†âŠâŸœosâŠ¸+oa                               # Modifier application site

  # Object code generation: numbers oc ordered by source location after rev
  fscâ†3Ã—fxâ†â†•2                               # Body immediacy Â¬fx, special name count
  orâ†â‹gâŠËœâˆ¾âŸ¨v,v,v,cn,cn,bk,bk,lb,lb,at,dr,ol,fl,rtâŸ©
  ocâ†orâŠ âˆ¾âŸ¨32+vâŠaa,0Â¨v,vs,0Â¨cn,ob,1Â¨bk,1+â†•â‰ bk,11+lbâŠaa,ll,48+ao,6Â¨dr
           24+oaâŠr,16+dy+4Ã—faâŠtr,Â¯1â†“rcâ†7Â¨fxâŸ©
  # Output
  fzâ†âŸ¨0Â¨fx,Â¬fx,â†•â‰ fxâŸ©                        # Per-function data
  lcâ†0â‹ˆ+Â´0=ao                               # Body locals count
  czâ†âŸ¨/1âˆ¾orâ‰¥oc-â—‹â‰ rt,fsc+lc,â†•Â¨lc,â¥ŠâŸœ0Â¨lcâŸ©     # Per-body data
  âŸ¨ocâˆ¾Â¯1âŠ‘rc,âˆ¾âŸ¨uâŠğ•¨âŸ©âˆ¾1â†“k,<Ë˜â‰>fz,<Ë˜â‰>czâŸ©       # Overall output
}
