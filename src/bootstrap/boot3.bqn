# Compiler simplified three times
# Suitable for compiling twice-simplified compiler
# Probably not any easier to compile, but it's shorter
{
  charSetâ†âˆ¾charsâ†âŸ¨
    "+-Ã—Ã·â‹†âˆšâŒŠâŒˆ|Â¬âˆ§âˆ¨<>â‰ =â‰¤â‰¥â‰¡â‰¢âŠ£âŠ¢â¥Šâˆ¾â‰â‹ˆâ†‘â†“â†•Â«Â»âŒ½â‰/â‹â’âŠâŠ‘âŠâŠ’âˆŠâ·âŠ”!" # Function
    "Ë™ËœË˜Â¨âŒœâ¼Â´Ë`"           # 1-modifier
    "âˆ˜â—‹âŠ¸âŸœâŒ¾âŠ˜â—¶â‰âš‡âŸâŠ"         # 2-modifier
    "â‹„,"âˆ¾lfâ†@+10          # Separator
    "â†â†©"                  # Gets
    "(){}âŸ¨âŸ©"              # Bracket
    "ğ•Šğ•©ğ•¨"                 # Input
    "Â¯Ï€âˆ"                 # Numeric
    (âŠ‘"0")+â†•10            # Digit
    â¥Š"aA"+âŒœâ†•naâ†26         # Alphabetic
    " "                   # Whitespace
    scâ†@+âŸ¨35,34,64âŸ©       # Preprocessed characters: hash, double quote, @
  âŸ©
  cmâ†((0Â»+`)â‹ˆÂ¨âŠ¢)cglâ†â‰ Â¨chars
  bSâ†3âŠ‘cmâ‹„bGâ†4âŠ‘cmâ‹„bBâ†5âŠ‘cmâ‹„bIâ†6âŠ‘cmâ‹„bNâ†7âŠ‘cmâ‹„bAâ†9âŠ‘cmâ‹„bWâ†10âŠ‘cm
  sepâ†âŠ‘bS
  viâ†âŠ‘bN  # Start of identifier numbering
  charRoleâ†âˆ¾cglâ¥ŠÂ¨âŸ¨1,2,3,Â¯1,Â¯3,âŸ¨Â¯1,0âŸ©,âŸ¨1,0,0âŸ©,0,0,26/âŸ¨0,1âŸ©,4,0âŸ©
  TTâ†âŒˆ`Ã— â‹„ ITâ†(â†•â‰ )TTâŠ¢ â‹„ I1Tâ†(1+(â†•â‰ ))TTâŠ¢

  # Comments and strings
  sâ†â‰ `ddâ†ğ•©=1âŠ‘scâ‹„ssâ†sâˆ§dd                     # Strings; string start
  fâ†s<(I1T s<ğ•©=âŠ‘sc)â‰¤I1Tğ•©=lf                 # Filter comments
  chrâ†@Â¨ciâ†/fâˆ§ğ•©=2âŠ‘sc                        # Characters (indices ci)
  strâ†ğ•©âŠ”Ëœ1-Ëœ(+`ssâˆ¾1)Ã—(ss<s)âˆ¾1               # Strings

  # Extract words: identifiers and numbers
  tâ†charSetâŠf/ğ•©                             # Tokens
  râ†tâŠcharRole                              # Role
  lâ†(tâ‰¥âŠ‘bN)âˆ§t<âŠ‘bWâ‹„wâ†l>Â»l                    # Word chars l, start w
  wiâ†(âŠ‘bA)â‰¤w/t                              # Type: 0 number, 1 identifier
  tâ†©t-naÃ—lâˆ§r=1                              # Case-insensitive
  nâ†lâˆ§(+`w)âŠ0âˆ¾Â¬wi                           # Number mask
  ideâ†(1-Ëœ(l>n)Ã—+`w>n)âŠ”tâŠcharSet            # Identifiers

  # Numbers, at most 2 digits
  ntâ†((âŠ¢âˆ¨Â«)0âˆ¾n)/0âˆ¾tÃ—l                       # Number tokens separated by 0
  nnâ†nt=âŠ‘bNâ‹„mâ†Â¬nnâˆ¨0=nt                      # Mask for Â¯; digits
  nlâ†(0âˆ¾âŸ¨Ï€,âˆâŸ©âˆ¾â†•10)âŠËœmÃ—nt-âŠ‘bN                # Digit lookup
  nsâ†âŸ¨1,Â¯1âŸ©âŠËœ(m>Â»m)/Â»nn                     # Negate if Â¯
  numâ†nsÃ—(m>Â«m)/nl+10Ã—Â»nl                   # Numeric values

  # Deduplicate literals and identifiers; other cleanup
  # Identifiers then literal tokens are numbered starting at vi
  kiâ†((â’wi)âŠ/w)âˆ¾(ciâˆ¾/ss)âŠ+`Â»f               # Indices in t
  kâ†âŸ¨ide,âŸ¨âŸ©,num,chr,strâŸ©                    # Constants
  kâ†©k/Â¨Ëœ(âŠ¢>Â¯1Â»âŒˆ`)Â¨jâ†âŠÂ¨k                     # IDs j into uniques k
  wrâ†wâˆ¨Â¬lâˆ¨t=âŠ‘bWâ‹„râ†©wr/râ‹„câ†â‰ t
  tâ†©wr/(câ†‘â‹(âŠ¢+cÃ—âŠ’)kiâˆ¾â†•c)âŠ(âˆ¾j++`viÂ»â‰ Â¨k)âˆ¾t    # Add IDs; remove words/whitespace
  tâ†©t-(t<+Â´bS)Ã—(âŠ¢Ã—0â‰¤âŠ¢)t-âŠ‘bS                 # Separators are equivalent
  pbâ†â‰ `1Â¨sbâ†Â¯1â†“1â†“/1(âˆ¾â‰ âˆ¾Ëœ)t=sep              # Separator group boundaries (excludes leading and trailing)
  ebâ†âŸ¨3,5âŸ©+âŠ‘bB                              # End brackets that allow separators
  skâ†sb/Ëœpb>(âŠ¢âˆ¨Â«)ebâˆŠËœpb+(sb-pb)âŠt           # Keep the first of each group that's not just inside a bracket
  srâ†((â‰ t)â†‘/â¼sk)âˆ¨tâ‰ sepâ‹„râ†©sr/râ‹„tâ†©sr/t        # Remove the rest
  ğ•©â†©tâ‹„nvâ†â‰ âŠ‘k
  # End of tokenization!

  # Bracket roles
  # Open brackets initially have role Â¯1 and closed ones have role 0
  gbâ†â‹+`pâ†(Â¯1-2Ã—r)Ã—(ğ•©â‰¥âŠ‘bB)âˆ§ğ•©<+Â´bB           # Paren (actually any bracket type) depth and grade
  râ†©r+ğ•©=3+âŠ‘bB                               # Assume blocks are functions
  cpâ†ğ•©=1+âŠ‘bB                                # Closed paren
  irâ†((IT cpâ‰¤âŠ¢)âŠâŠ¢)0<r                       # Role of the expression ending at each position
  râ†©r+cpÃ—Â»ir                                # Roles at cp were 0; set them now

  # Reverse each expression: *more* complicated than it looks
  revâ†â‹+`Â¯1â†“(Â¯1âˆ¾gb)((â‹âŠ£)âŠ((â‹âŠ¢)âŠâŠ£)Â¬âŠËœ)â‹(+`+âŠ¢)1âˆ¾gbâŠr=Â¯1

  # Lexical resolution, no nesting
  rxâ†revâŠğ•©
  ivâ†/(rxâ‰¥âŠ‘bI)âˆ§rx<vi+nv                     # Variable indices
  vvâ†(ivâŠrx)-vi                             # Variable name
  iiâ†3â†“âŠ(Â¯3+â†•3)âˆ¾vv                          # Slot within frame
  vaâ†ivâŠÂ»rxâ‹„vbâ†(vaâ‰¥âŠ‘bG)âˆ§va<+Â´bG             # Variable assignment, if it's there
  idorâ†âˆ¾3/âŸ¨ivâŸ©                              # Identifier bytecode ordering
  idocâ†âŸ¨32+vb,0Â¨ii,iiâŸ©                      # Identifier bytecode: instruction, depth, slot
  dnâ†âŸ¨âŸ¨âŸ©,(va=âŠ‘bG)/vvâŸ©                       # Identifier name ID, per-block

  # Parsing
  grâ†revâŠËœgâ†â‹+`revâŠp                        # Order by bracket depth
  ğ•©â†©grâŠğ•©â‹„râ†©grâŠrâ‹„irâ†©grâŠir
  atâ†/aaâ†Â»aâ†Â¯3=r                            # Assignment target
  aoâ†(a/ğ•©)-âŠ‘bG                              # Assignment opcode
  trâ†irâŠËœITÂ»psâ†a<r<0                        # tr: train or modifier expression, ps: part separator
  oaâ†âŒ½/opâ†r=2                               # op: active modifiers; op: mod or right operand
  xsâ†ğ•©=sepâ‹„foâ†ğ•©=2+âŠ‘bB                       # Separators, function open {
  lsâ†xsâˆ§(IT fo)<IT loâ†ğ•©=4+âŠ‘bB               # List Separators: after âŸ¨lo, not {fo
  taâ†trâˆ§2(>âˆ¨|)ps(âŠ¢-TT)+`Â¬op                 # Train argument (first-level)
  faâ†/(taâˆ¨opâˆ¨(Â«âˆ¨âŠ¢)ps<aa)<(r=1)âˆ¨Â»op          # Active functions
  dyâ†faâŠÂ«(trâˆ§râ‰¥0)âˆ¨op<r=0                    # Dyadic
  prâ†ğ•©âŠËœpiâ†/ğ•©<sepâ‹„obâ†prâŠ/Â¯1(âŠ¢-Â»)uâ†â·âˆ§pr      # Objects to be loaded
  cnâ†piâˆ¾ltâ†/ğ•©â‰¥clâ†vi+nvâ‹„obâ†©obâˆ¾(cl-Ëœâ‰ u)+ltâŠğ•©  # Constants
  bkâ†/ğ•©=2+âŠ‘bB                               # Block loads
  lbâ†/ğ•©=5+âŠ‘bB                               # List starts
  llâ†(Â¬lo/1Â«ps)+(âŠ¢-Â»)1â†“(loâˆ¾1)/+`lsâˆ¾0        # List Length
  drâ†/xs>lsâ‹„rtâ†/fo                          # Drop (block separator) and return
  osâ†âŒ½(â†•â‰ op)(âŠ£-TT)âŒ½Â¬op                      # Operator skip: distance rightward to derived function start
  flâ†(âŠ¢+dyÃ—âŠ¢âŠosË™)fa+dy                      # Function application site

  # Object code generation: numbers oc ordered by source location (after rev) oi
  fscâ†3Ã—fxâ†â†•2                               # Body immediacy Â¬fx, special name count
  orâ†â‹idorâˆ¾gâŠËœâˆ¾âŸ¨cn,cn,bk,bk,2/lb,at,dr,oa+1âŒˆoaâŠos,fl,rtâŸ©
  ocâ†orâŠâˆ¾idocâˆ¾âŸ¨0Â¨cn,ob,1Â¨bk,1+â†•â‰ bk,â¥Šâ‰(11+lbâŠaa)â‰ll,48+ao,6Â¨dr
               24+oaâŠr,16+dy+4Ã—faâŠtr,Â¯1â†“rcâ†7Â¨fxâŸ©
  # Output
  fzâ†âŸ¨0Â¨fx,Â¬fx,â†•â‰ fxâŸ©                        # Per-function data
  czâ†âŸ¨/1âˆ¾orâ‰¥(â‰ oc)-â‰ rt,fsc+â‰ Â¨dn,dn,0Â¨Â¨dnâŸ©    # Per-body data
  âŸ¨ocâˆ¾Â¯1âŠ‘rc,âˆ¾âŸ¨uâŠğ•¨âŸ©âˆ¾1â†“k,<Ë˜â‰>fz,<Ë˜â‰>czâŸ©       # Overall output
}
