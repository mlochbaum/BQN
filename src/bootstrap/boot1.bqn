# Comiler simplified once
# Full compiler minus error checking and index tracking
# Syntax simplified to avoid _ Â· â€¿ ' ğ•ğ•ğ”½ğ”¾ğ•— and double quote in comment
# Already didn't have . [] :;? â‡ ğ•£ğ•¤ğ•˜
# Blocks are functions; no empty list literals; no useless parentheses
naâ†Â¯1âŠ‘â‰¢alphâ†("aA"+âŒœâ†•26)âˆ¾Ë˜"Ã Ã€"+âŒœ(â†•23)âˆ¾24+â†•7
lfâ†@+âŸ¨10,13âŸ©
âŸ¨charSet,cglâŸ©â†(âˆ¾ â‹ˆ â‰ Â¨)âŸ¨
  "+-Ã—Ã·â‹†âˆšâŒŠâŒˆ|Â¬âˆ§âˆ¨<>â‰ =â‰¤â‰¥â‰¡â‰¢âŠ£âŠ¢â¥Šâˆ¾â‰â‹ˆâ†‘â†“â†•Â«Â»âŒ½â‰/â‹â’âŠâŠ‘âŠâŠ’âˆŠâ·âŠ”!" # Function
  mod1â†"Ë™ËœË˜Â¨âŒœâ¼Â´Ë`"      # 1-modifier
  "âˆ˜â—‹âŠ¸âŸœâŒ¾âŠ˜â—¶â‰âš‡âŸâŠ"         # 2-modifier
  "â‹„,"âˆ¾lf               # Separator
  ":;?"                 # Header punctuation
  "â‡â†â†©"                 # Gets
  "(){}âŸ¨âŸ©[]"            # Bracket
  "â€¿"                   # Ligature
  "Â·"                   # nOthing
  "ğ•Šğ•ğ•ğ”½ğ”¾ğ•¤ğ•©ğ•¨ğ•£ğ•—ğ•˜"         # Input
  ".Â¯Ï€âˆ"                # Numeric
  (âŠ‘"0")+â†•10            # Digit
  "_"âˆ¾Ëœâ¥Šalph            # Alphabetic
  "â€¢ "âˆ¾@+9              # Whitespace
  âŸ¨cc,qs,qd,ncâŸ©â†"#'""@" # Preprocessed characters
âŸ©
âŸ¨bF,b1,b2,bS,bH,bG,bB,bL,bO,bX,bN,bD,bA,bW,bPâŸ©â†â‹ˆÂ¨ËœâŸœ(0Â»+`)cgl
Mâ†1âŠ¸âŠ‘(0âŠ¸â‰¤âˆ§>)-âŸœâŠ‘   # âˆŠ for an init,length pair ğ•© as above
sepâ†âŠ‘bS
predâ†2+âŠ‘bH
bIâ†bX+â‹ˆâŸœ-5â‹„bRâ†8+âŠ‘bX
# Convert characters to numbers, mostly the same as tokens
cgfâ†(cgrâ†â‹charSet)âŠcharSet
CharCodeâ†cgrâŠËœ1-Ëœ1âŒˆcgfâ‹âŠ¢
swapundoâ†CharCodeâˆŠâŸœmod1âŠ¸/"Ëœâ¼"

vdâ†1+viâ†âŠ‘bN  # Start of identifier numbering (plus dot)
charRoleâ†4âˆ¾Ëœâˆ¾â¥ŠÂ¨ËœâŸœ(â‰ â†‘cglË™)âŸ¨1,2,3,Â¯1,Â¯1,Â¯3,âŸ¨Â¯1,0âŸ©,Â¯2,0,Â¬/âŸ¨5,6âŸ©âŸ© # For first vd chars
Tâ†âŒˆ`Ã— â‹„ ITâ†â†•âˆ˜â‰ âŠ¸T â‹„ I1Tâ†(1+â†•âˆ˜â‰ )âŠ¸T
PNâ†1(âˆ¾/âˆ¾Ëœ)(âˆ¨/âŠ£)  # Partitioned-none: partitions where ğ•¨<ğ•© is never 1

# Source to âŸ¨tokens, roles, number of identifiers, literalsâŸ©
# Identifiers then literal tokens are numbered starting at vi
Tokenizeâ†{âŸ¨System,varsâŸ©â†ğ•¨
  # Resolve comments and strings
  câ†ğ•©=ccâ‹„sâ†/âŸ¨0,0âŸ©âŠ¸Â«âŠ¸âˆ§smâ†ğ•©=qsâ‹„dâ†/dmâ†ğ•©=qd
  gâ†â‹qâ†âˆ¾âŸ¨  sâ‹„Â¯1â†“dâ‹„/câŸ© â‹„qâ†©gâŠq                # Open indices
  eâ† gâŠâˆ¾âŸ¨2+sâ‹„ 1â†“dâ‹„-âŸœÂ»âˆ˜âŠâŸœ(0âˆ¾+`c)âŠ¸//(ğ•©âˆŠlf)âˆ¾1âŸ© # Matching close indices
  Seâ†â‰ (>/âŠ¢)âˆ¾âŸœâ‰ {(âŠËœğ•¨)ğ•ŠâŸ(â‰ â—‹(Â¯1âŠ¸âŠ‘))ğ•©âˆ¾ğ•©âŠğ•¨}âŸ¨0âŸ©Ë™  # Find reachable openings
  Stâ†(â‰ ğ•©)â†‘(/â¼(Se qâ‹e)âŠ¸âŠ)                    # All indices â†’ reached mask
  aâ†St qâ‹„bâ†St eâ‹„fâ†1â‰ `abâ†aâˆ¨b                 # Open/close masks; filter

  # Extract character and string literals
  uâ†fâˆ§ğ•©=ncâ‹„ciâ†/uâˆ¨Â»aâˆ§sm
  chrâ†(âŠâŸœğ•©-(nc-@)Ã—âŠâŸœu)ci                    # Characters (indices ci)
  f>â†©qeâ†dmâˆ§Â«aâˆ§â†©dm                           # Quote Escape
  strâ†ğ•©âŠ”Ëœ1-Ëœ(siâ†a>Â»qe)(âŠ£+`âŠ¸Ã—â—‹(âˆ¾âŸœ1)<)â‰ `dmâˆ§ab # Strings (indices /si)

  # Extract words: identifiers and numbers
  tâ†CharCode f/ğ•©
  ndâ†(t=âŠ‘bN)>Â«t M bDâ‹„rrâ†t=bR                # Namespace dot; ğ•£
  wâ†Â»âŠ¸<lâ†rrâˆ¨nd<t M bN(âŠ£â‹ˆ-Ëœ)â—‹âŠ‘bW             # Word chars l, start w
  usâ†t=Â¯1++Â´bAâ‹„syâ†t=âŠ‘bW                     # Underscore, system dot
  wkâ†(Â¬w/rr)Ã—naâŒŠâˆ˜Ã·Ëœ(âŠ‘bA)-Ëœw/t               # Kind of word from first char
  t-â†©naÃ—lâˆ§tâ‰¥na+âŠ‘bA                          # Case-insensitive
  wâ‰ â†©Â»âŠ¸âˆ¨sy                                  # Start system word at dot
  wiâ†0<wtâ†(2Ã—wkâ‰¥0)(Ã—âŸœÂ¬+âŠ¢)w/sy               # Type: 0 number, 1 system, 2 identifier
  iâ†l>nâ†lâˆ§(+`w)âŠ0âˆ¾Â¬wi                       # Identifier/Number masks
  numâ†ReadNumsâ—‹(((0âˆ¾us)<âˆ¨âŸœÂ«0âˆ¾n)/0âŠ¸âˆ¾) tÃ—l    # Numbers
  irâ†(us/ËœÂ«âŠ¸<i)(âŠ¢+âˆ§âŸœ(2âŠ¸=))wi/wk             # Identifier role
  ifâ†(Â»âŒˆ`)âŠ¸<igâ†(i>us)Ã—+`w>n                 # Identifier groups and first character
  frâ†(1=wi/wt)<if/rr                        # Identifier is ğ•£-based
  wâ†©ifâˆ¨nâˆ§wâ‹„wsâ†1=0âŠ¸<âŠ¸/wt/Ëœâ†©Â¬w/rr             # Don't produce an identifier for ğ•£
  igâŠâ†©1-Ëœ0âˆ¾+`âŠ¸Ã—Â¬fr
  idâ†varsâŠ¸âˆ¾âŒ¾âŠ‘(wsâˆ¾2)âŠ”igâŠ”tâŠcharSet            # âŸ¨Identifiers, system valuesâŸ©

  # Deduplicate literals and identifiers; other cleanup
  kiâ†(wtâ’âŠ¸âŠ/w>rr)âˆ¾(ciâˆ¾/si)âŠ+`Â»f             # Indices in t
  kâ†idâˆ¾âŸ¨num,chr,strâŸ©â‹„k(âŠ¢>Â¯1Â»âŒˆ`)âŠ¸/Â¨Ëœâ†©jâ†âŠÂ¨k   # IDs j into uniques k
  kâ†©SystemâŒ¾(1âŠ¸âŠ‘)k                           # System value lookup
  wfâ†Â¬lâˆ¨t M bW                              # Index management for...
  tâ†©(wâˆ¨wf)/(varsâ‰ âŠ¸â†“âˆ¾j++`vdÂ»kkâ†â‰ Â¨k)âŒ¾(kiâŠ¸âŠ)t  # Add IDs; remove words/whitespace
  t-â†©t(MÃ—-âŸœâŠ‘)bS                             # Separators are equivalent
  pâ†â‰ `1Â¨sbâ†Â¯1â†“1â†“/1(âˆ¾â‰ âˆ¾Ëœ)t=sep               # Separator group boundaries (excludes leading and trailing)
  ebâ†âŸ¨3,5,7âŸ©+âŠ‘bB                            # End brackets that allow separators
  skâ†sb/Ëœp>âˆ¨âŸœÂ«(MâŸœbHâˆ¨ebâˆŠËœpâŠ¸+)(sb-p)âŠt        # Keep the first of each group that's not just inside a bracket
  t/Ëœâ†©1Â¨âŒ¾(skâŠ¸âŠ)tâ‰ sep      # Remove the rest
  imâ†(t=bR)âˆ¨t M vdâ‹ˆ+Â´2â†‘kk                   # Identifier (or ğ•£) mask
  râ†irâŒ¾(imâŠ¸/)(vdâŒŠt)âŠcharRoleâˆ¾0              # Role
  t+â†©(âŠ‘bX)((âŠ¢Mâ‹ˆâŸœ5)Ã—5+3âŠ¸+âŠ¸â‰¤)t                # Case-insensitive special names
  t-â†©vi(<+10Ã—=)t                            # Shift . to bX and variables back one
  âŸ¨t,r,kâŸ©
}

# ğ•© is a list of tokens that contains the numeric literals, each
# preceded by 0. Return the numbers.
ReadNumsâ†{
  âŸ¨e,d,n,p,iâŸ©â†=âŸœğ•©Â¨((âŠ‘bA)+-Â´"ea")âˆ¾+âŸœâ†•Â´bN     # Masks for e.Â¯Ï€âˆ
  câ†eâˆ¨zâ†0=ğ•©â‹„mâ†Â¬nâˆ¨c
  fâ†(17â‰¥Â¬(âŠ¢-T)+`)âŠ¸âˆ§gâ†(Â«â‰¤(d<ğ•©â‰ âŠ‘bD)>â—‹I1TÂ¬)âŠ¸âˆ§m # No leading 0s; max 17 digits
  lâ†(Â¯1âˆ¾âŸ¨Ï€,1âŸ©âˆ¾â†•10)âŠËœ(Â¬d)/fÃ—ğ•©-1+âŠ‘bN          # Digit lookup, with âˆ as 1 to avoid âˆÃ—0
  vâ†(>âŸœÂ«0â‰¤l)/0(0âŠ¸â‰¤Ã—Ã—âŸœ10âŠ¸+)`l                # Numeric valuesâ€”mantissas and exponents
  vÃ—â†©âŸ¨1,Â¯1âŸ©âŠËœ(râ†>âŸœÂ»m)/Â»n                    # Negate if Â¯
  vmâ†c/z                                    # Mask of mantissas in l
  dpâ†vm/f(--Â»âŠ¸-(<Ã—âŠ¢)âŠâŸœ(I1TÂ«d)âŠ¸-)â—‹(/>âŸœÂ«)g    # Decimal position
  tâ†10â‹†|eeâ†dp-Ëœvm/Â«vÃ—Â¬vm                    # Power of 10
  tÃ·ËœâŒ¾((0>ee)âŠ¸/)tÃ—âŒ¾((0<ee)âŠ¸/)vm/vÃ—(r/i)âŠ1â‹ˆâˆ # Correct âˆ then Ã—10â‹†ee
}


Parse â† {âŸ¨r,vn,defâŸ©â†ğ•¨â‹„nvâ†â‰ vn
  # Bracket and ligature validation and handling
  # Open brackets have role Â¯1 and closed ones have role 0
  gâ†â‹+`pâ†(Â¯1-2Ã—r)Ã—ğ•© M bB                    # Paren (actually any bracket type) depth and grade
  dlâ†Â«âŠ¸âˆ¨dcâ†r=4                              # Dot left
  r-â†©(ğ•©=âŠ‘bG)>Â«dc<0â‰¤r+p                      # Role Â¯4 for exports: âŠ‘bG is â‡
  srâ†Â»âŒ¾(((â‹âŠâŸœdl)âŠ¸âŠg)âŠ¸âŠ)slâ†Â«âŠ¸âˆ¨r=Â¯2â‹„nsâ†Â¬slâˆ¨sr # Strand right and left; not stranded
  cpâ†ğ•©=1+âŠ‘bB                                # Closed paren
  nrâ†(ITÂ¬cp)âŠ(ğ•©=2+âŠ‘bI)+2Ã—ğ•©=âŠ‘bO              # Nothingness role: 1 for ğ•¨, 2 for Â·
  nxâ†0
  gâŠËœâ†©â‹gâŠsdlâ†slâˆ¨dl                          # Avoid reordering strands and dots in rev
  rpâ†â‰ âŠ¸Â»âŒ¾(gâŠ¸âŠ)â†•â‰ r                           # Position of previous, for roles
  # Permutation to reverse each expression: *more* complicated than it looks
  revâ†â‹+`Â¯1â†“(Â¯1âˆ¾g)(âŠ£â‹âŠ¸âŠâŠËœâŸœâ‹Â¬âŠËœ)â‹+`âŠ¸+1âˆ¾gâŠsdlâˆ¨r=Â¯1
  gfâ†â‹fdâ†+`brâ†revâŠpÃ—ğ•©MâŸ¨2+âŠ‘bB,2âŸ©             # Order by brace depth fd to de-nest blocks
  revâŠËœâ†©gfâ‹„fdâŠËœâ†©gfâ‹„brâŠËœâ†©gf
  ğ•©âŠËœâ†©revâ‹„dcâŠËœâ†©rev

  # Compute parsing ordering grâ‰¡gâŠrev
  BEâ†=âˆ¨+âŸœ2âŠ¸=                                # Bracket equals: match âŸ¨[ or âŸ©] given âŸ¨ or âŸ© only
  gâ†©â‹+`pâ†©br-ËœrevâŠpâ‹„bpâ†0(<â‹ˆâ—‹(/âŸœg)>)gâŠp       # Order by non-brace bracket depth
  gâŠËœâ†©â‹gâŠÂ«âŠ¸âˆ¨dcâ‹„grâ†gâŠrev                     # Now by dots
  sllâ†1+2Ã·Ëœ0(<-â—‹/>)grâŠsr-slâ‹„lâ†/gâŠğ•©BEËœ5+âŠ‘bB  # Strand length; list starts
  bâ†br>0â‹„câ†/br<0â‹„bpâˆ¾Â¨â†©âŸ¨/b,câŸ©                # Block Begin (mask) and Close (index), in matching order
  gâŠËœâ†©gsâ†â‹grâŠslâ‹„grâ†©gâŠrevâ‹„giâ†â‹g              # Send strand prefixes *â€¿ to the end

  # Headers
  hhâ†ğ•©=âŠ‘bHâ‹„csâ†ğ•©=1+âŠ‘bH                       # Case header : and separator ;
  fiâ†+`cbâ†bâˆ¨csâ‹„Hâ†cbÂ¬âˆ˜PNâŠ¢                    # Body index fi; which bodies Have a property
  cqâ†(Hğ•©=pred)âˆ¨châ†H hh                      # ch: body has : header ; cq: or ? predicate
  cfâ†1âˆ¾Â¬coâ†cb/csâ‹„cmâ†0âˆ¾âˆ¨âŸœÂ«co                 # cf: body is first; cm: body is one of multiple
  ccâ†(â‹â‹Â«co)âŠcâˆ¾/cs                          # Case close
  hiâ†/hfâ†hhâŠËœâŸœITâŒ¾((âŒ½g)âŠ¸âŠ)cbâˆ¨hh              # Header component indices
  unâ†0=usâ†swapundo(â‰ âˆ˜âŠ£-âŠ)hiâŠğ•©
  utâ†un/Â»usâ‹„hi/Ëœâ†©0=us                       # Undo type: 0 normal, 1 â¼, 2 Ëœâ¼
  hrâ†(âŠâŸœnsÃ—âŠâŸœr)revâŠËœhi                      # Header component roles
  hlâ†2=hnâ†(1âŠ¸Â»+Â«)hcâ†Â¯1=hr                   # hl: is label, hc: is :
  hoâ†(Â»âˆ¨(Â«(hr=3)âˆ§âŠ¢))hl<2â‰¤hr                 # Header operands
  hmâ†Â¬hoâˆ¨haâ†ho<(0=hr)âˆ§1=hn                  # Mask for main name; header arguments
  hkâ†3|1-Ëœ(+`bIâˆ¾nv)â‹hiâŠğ•©Ã—Â¬revâŠsr            # Kind: 0 special, 1 name, 2 compound
  hmaâ†hm>hlaâ†hlâˆ§(0=hr)âˆ§1â‰ hkâ‹„hr+â†©hlaâ‹„hl>â†©hla # Lone non-name subject is ğ•© with ğ•Š omitted
  hvâ†(hla+haÃ—1+Â«hc)+(hoÃ—4+Â«3=hr)+hmaÃ—3Ã—1-Ëœ2âŒŠhr # Special name for position
  hkÃ—â†©Â¬hcâˆ¨hlâˆ§0=hr                           # Treat subject labels like special names
  hm>â†©hcâ‹„hr/Ëœâ†©hmâ‹„hxâ†(1Â»hc)/ha               # Header-derived role hr and immediacy Â¬hx
  ut-â†©-âŸœÂ»utÃ—ho                              # Shift â¼ from right operand to main name
  ut/Ëœâ†©hmâ‹„hxâˆ¨â†©1=hr
  cwhâ†hc/Â»hlâŒˆhaÃ—1+heâ†0â‰ hk                   # Body ğ•¨ for just headers
  ut2â†2=ut
  cwâ†(cwhâŒˆ2Ã—ut2)âŒ¾(châŠ¸/)1+-âŸœÂ«(Â»cq)<1(âŠ¢<Â«)cf  # Body ğ•¨: 0 no, 1 allowed, 2 required
  hl/Ëœâ†©hmâ‹„huâ†(Â¬he)âŒ¾(hiâŠ¸âŠ)hf                 # hu: mask of header special names
  hjâ†giâŠËœhe/hiâ‹„hdâ†2=he/hk                   # hj: header assignments; hd: which ones destructure

  # Block properties
  ssâ†âŸ¨0,3,5,6âŸ©â‹(âŠ¢+(0<hk)Ã—hvâŠ¸-)âŒ¾(hiâŠ¸âŠ)ğ•©-âŠ‘bI  # Special name
  ss+â†©(revâŠr=3)âˆ§ğ•©=3+âŠ‘bI                     # Treat _ğ•£_ as 3, like ğ•˜
  HSâ†(Â¯1+`cf)âŠbÂ¬âˆ˜PN=âŸœssâ‹„spâ†/hu<ğ•© M bI       # Has-special (ğ•¤ğ•©ğ•¨/ğ•£ğ•—/ğ•˜); indices of specials
  fxâ†HS 1â‹„frâ†(fxâˆ¨0âŠ¸<)âŠ¸+ftâ†2(âŠ£âŒˆ2Ã—âŠ¢)â—‹HS 3     # Body immediacy Â¬fx, type ft, role fr
  ftâŒˆâ†©1-Ëœfrâ†©hrâŒ¾(châŠ¸/)frâ‹„fxâ†©hxâŠ¸âŒˆâŒ¾(châŠ¸/)fx
  fscâ†(ftâŠâŸ¨0,2,3âŸ©)+3Ã—fx                     # Special name count
  hv-â†©(Â»+`hc)âŠ3Ã—Â¬ch/fx                      # Header variable slot

  # Propagate roles through parentheses
  # ir is the role of the expression ending at each position (truncated to the right)
  râ†©sl-ËœnsÃ—(1â†“cf/fr)âŒ¾((câŠrev)âŠ¸âŠ)r           # Add block roles; make strand elements Â¯1
  ptâ†cpâˆ§ns                                  # Pass-through parentheses: not in strands
  ppâ†ptâˆ§Â»esâ†rpâŠ1âˆ¾Ëœr<0                       # Parens enclosing one object (maybe with assignment) don't change roles
  irâ†((rpâŠ0âˆ¾Ëœ(1+es)Ã—3=âŠ¢)âŒˆâŠ¢-es<2â‰¤âŠ¢)r+ppÃ—(ITÂ¬pp)âŠr # Propagate modifier roles
  irâŒˆâ†©(ITÂ¬ptâˆ§ir=0)((âŠ-âŠ¢)âŸœ(+`Â¬pp)(âŠ¢âŒŠ1âŒˆ+)âŠ)ir # ...and function roles
  r+â†©ptÃ—Â»ir                                 # Roles at pt were 0; set them now
  nrÃ—â†©Â¬nxâˆ¨â†©(0â‰ ir)âˆ§1=nr                      # Assume ğ• can't be Nothing
  irâ†©(irÃ—0=nr)-nr                           # Include nothingness
  r-â†©(r=Â¯4)âˆ§1Â»r=Â¯1                          # Lone â‡ to role Â¯5
  r(Ã—âŸœÂ¬-âŠ¢)â†©dl                               # Namespace and dot to Â¯1

  # Reorder for parsing
  xvâ†ğ•©-vi                                   # Save for lexical resolution
  ğ•©âŠËœâ†©gâ‹„hgâ†gâŠhfâ‹„râŠËœâ†©grâ‹„nsâŠËœâ†©grâ‹„irâŠËœâ†©gr
  lâ†©(l0â†lâŠâ‹gs)âˆ¾/grâŠsr>sl                    # Indices of list literals
  lmâ†(0Â¨sll)âˆ¾Ëœ(5+âŠ‘bB)-Ëœl0âŠğ•©                 # List merge, adding 2 for []

  # Parsing part 1
  aâ†(Â¯5âŠ¸<âˆ§â‰¤âŸœÂ¯3)râ‹„psâ†a<r<0                   # a: assignment, ps: part separator
  trâ†1â‰¤erâ†irâŠËœITÂ»ps                         # er: expression role; tr: train or modifier expression
  noâ†0âŒˆ-irâ‹„neâ†0âŒˆ-erâ‹„nxâŠËœâ†©gr                 # Nothing value; expression
  nxâŒˆâ†©neÃ—a
  nxâŒˆâ†©neÃ—ğ•©=pred
  oaâ†âŒ½/hg<opâ†(er<2)âˆ§râ‰¥2â‹„roâ†opâˆ¨Â«opâˆ§m2â†r=3    # op: active modifiers; ro: mod or right operand
  nxâŒˆâ†©opÃ—2(Â«âŒˆm2Ã—Â»)noâŒˆ2Ã—m2â‰¥roâˆ¨râˆŠâ†•2
  sâ†ğ•©=sepâ‹„foâ†ğ•©âˆŠâŸ¨2+âŠ‘bB,1+âŠ‘bHâŸ©                # Separators, function open { or ;
  lsâ†sâˆ§fo<â—‹IT loâ†ğ•©BEËœ4+âŠ‘bB                  # List Separators: after âŸ¨lo, not {fo
  mmâ†ğ•©=2+âŠ‘bGâ‹„maâ†tr<mmâˆ§Â«irâ‰¥1â‹„mmâˆ§â†©1Â»ps        # Modified assignment; monadic modified
  osâ†â†•âˆ˜â‰ âŠ¸(âŠ£-T)âŒ¾âŒ½Â¬roâˆ¨ma                      # Operator skip: distance rightward to derived function start
  atâ†1+âŠâŸœosâŠ¸+aiâ†/a                          # Assignment target
  afâ†Â¯4â‰ aiâŠrâ‹„arâ†atâŠr                        # af for actual (non-export) assignment; assignment role
  akâ†af+(0â‰¤ar)+(aiâŠma)+(âŠ‘bG)-ËœaiâŠğ•©          # Class of assignment: 1â‡ 2â‡? 3â†? 4â†©? 5+â†©?
  atâˆ¾â†©hjâ‹„acâ†Â«âŠ¸-(akâˆ¾6Â¨hj)âŒ¾(atâŠ¸âŠ)0Â¨ğ•©          # Header assignment is 6 temporarily
  aaâ†0<gacâ†gâŠacâ†©Â»+`(1âŠ¸Â»âŠ¸âˆ¨0=+`)âŠ¸Ã—giâŠac       # Broadcast ac to the entire target
  apiâ†/(ğ•©=âŠ‘bO)âˆ§apâ†aaâˆ§2=no                   # Assignment placeholder
  nxâŒˆâ†©noÃ—ap<nsâ‰¤Â»loâˆ¨ls
  ac-â†©3Ã—6=acâ‹„ahâ†6=gac                       # Assignment is header; 6â†’3
  nxâŒˆâ†©aaÃ—1=no                               # Prevent assignment to ğ•¨ if it's Â·
  nfâ†H ac<xv=vi-ËœâŠ‘bG                        # Namespace bodies
  fwâ†H giâŠnx                                # Bodies where ğ•¨ must be defined
  fwâŒˆâ†©nfÂ¬âŠ¸Ã—(1-Ëœ0âˆ¾ccâŠrev)âŠnr
  fwâ‰¥â—‹I1Tâ†©cf                                # If a body fails on ğ•¨, later ones won't see ğ•¨
  cwâŒˆâ†©2Ã—fwâ‹„cwÃ—â†©fx
  nnâ†gâŠfiâŠ2=cwâ‹„no(âŠ£-=)â†©nnâ‹„ne(âŠ£-=)â†©nn        # 2=cw indicates ğ•¨ is never Nothing
  hqâ†/ahâˆ§ğ•©â‰¥nv+vi                            # Header constant
  af>â†©almâ†aiâŠaaâ‹„alâ†alm/ai                   # aliases al
  ai/Ëœâ†©afâ‹„at/Ëœâ†©afâˆ¾1Â¨hj

  # Lexical resolution (independent of parsing part 2 below)
  diâ†/dmâ†Â»dc                                # Dots aren't scoped
  idâ†/(huâˆ¨dmâˆ¨giâŠÂ«aaâˆ§a)<(0âŠ¸â‰¤âˆ§<âŸœnv)xv         # Identifier indices in xv
  saâ†0<spâŠacâ‹„dâ†(icâ†idâŠac)MâŸ¨2,2âŸ©             # Which accesses are definitions
  idfâ†idâŠfiâ‹„idvâ†idâŠxv                       # Function index and name ID
  dpâ†dâˆ§(0=idf)âˆ§idv<â‰ def                     # Definitions of vars in def
  dpfâ†(dp/idv)âŠdef
  dâ†©(0â‰¤dpf)âŒ¾(dpâŠ¸/)dâ‹„zdaâ†0Â¨daâ†/defâ‰¤0         # Turn def Â¯1 â† into â†©
  dnâ†(dgâ†zdaâˆ¾(dfâ†d/idf)âˆ¾â‰ fsc)âŠ”daâˆ¾dvâ†d/idv   # Identifier name ID, per-block
  # Order every referenced identifier, and an undeclaration for each declaration
  ixfâ†((1=ic)+idfâŠÂ¯1âˆ¾cb/gf)âˆ¾dfâŠ(â‰ ğ•©)âˆ¾1-ËœccâŠgf# First order by block index, open for real and closed for virtual
  igâ†(â‹âŠâŸœ(idvâˆ¾dv))âŠ¸âŠâ‹ixf                    # Then order by name
  igâ†©<âŸœ(â‰ d)âŠ¸/(â‹dsâ†+`igâŠdâˆ¾Â¯1Â¨dv)âŠig          # Last order by declaration depth
  dâŠËœâ†©igâ‹„idâŠËœâ†©igâ‹„icâŠËœâ†©ig
  duâ†+Â´Â¬Â»âŠ¸âˆ¨0<dsâ‹„uvâ†(duâ†‘ig)âŠidv              # Number undefined (always sorted to front)
  ixâ†(ic<3)âˆ§iaâ†0<ic                         # Which are exports, assignments
  iddâ†(âŠ¢-(uvâŠdedâ†-0âŒˆdef)âˆ¾(duâ†“IT d)âŠ¸âŠ)idâŠfd  # Identifier frame depth
  dxâ†dgâŠ”zdaâˆ¾(digâ†â‹d/ig)âŠixaâ†d(/â‰¥1â†“PN)ix     # Exported identifier mask
  idiâ†(uvâŠ¸âŠâˆ¾(Â¯1+`duâ†“d)âŠdigâ‹âŠ¸âŠdaâ‰ âŠ¸â†“âŠ¢)(âŠâŸœfsc+âŠ’)dedâˆ¾df # Slot within frame
  uuâ†(ia<1Â«d)âˆ§d(âŠ£+`âŠ¸âŠ(1âˆ¾ixa)<PN)0<idd       # Unused marker
  spiâ†((spfâ†spâŠfi)âŠ3Ã—fx)+3+spâŠxv            # Special name index
  uuâˆ¾â†©âˆŠâŒ¾âŒ½spi+6Ã—spf                          # and unused marker
  idorâ†âˆ¾âŸ¨3,2,3âŸ©/âŸ¨1+gâŠËœhj-1, di, idâˆ¾spâŸ©      # Identifier bytecode ordering
  idoâ†32+uu(âŠ¢+2Ã—>)iaâˆ¾sa                     # Opcode
  idocâ†âŸ¨32Â¨hj,0Â¨hj,he/hv
        64Â¨di,diâŠxv, ido,iddâˆ¾0Â¨sp,idiâˆ¾spiâŸ©  # Identifier bytecode: instruction, depth, slot

  # Parsing part 2
  taâ†trâˆ§2(>âˆ¨|)ps(âŠ¢-T)+`Â¬ro                  # Train argument (first-level)
  faâ†/(hgâˆ¨taâˆ¨roâˆ¨Â«âŠ¸âˆ¨ps<aa)<(r=1)âˆ¨Â»op         # Active functions: cases fe are excluded
  dyâ†2â‰ nyâ†faâŠ2Â«noâŒˆ2Ã—Â¬(trâˆ§râ‰¥0)âˆ¨ro<r=0        # Dyadic
  obâ†prâŠËœuâ†âˆ§â·prâ†ğ•©âŠËœpiâ†/hg<ğ•©<sep             # Objects to be loaded
  cnâ†piâˆ¾ltâ†/ğ•©â‰¥clâ†vi+nvâ‹„obâˆ¾â†©(cl-Ëœâ‰ u)+ltâŠğ•©    # Constants
  bkâ†câŠgi                                   # Block loads
  llâ†sllâˆ¾Ëœ(Â¬lo/1Â«ps)+-âŸœÂ»1â†“(loâˆ¾1)/+`lsâˆ¾0     # List Length
  drâ†(hdÂ¬âŠ¸/hj)âˆ¾/s>(2=ne)âˆ¨lsâˆ¨Â»r=Â¯5â‹„rtâ†/fo    # Drop (block separator) and return
  qpâ†/ğ•©=pred                                # Predicate
  flâ†(dyÃ—âŠâŸœos)âŠ¸+fa+dy                       # Function application site
  drâˆ¾â†©((1+dy)Ã—fnâ†2=fmâ†faâŠne)/fl             # Turn function applications on Â· to drops
  fnâ†©Â¬fnâ‹„fa/Ëœâ†©fnâ‹„fl/Ëœâ†©fn                    # And remove them

  # Object code generation: numbers oc ordered by source location (after rev) oi
  aoâ†48+(0âŒˆ(1+âŠ‘bG)-ËœaiâŠğ•©+ma+mm)âˆ¾-hd         # Assignment opcode
  orâ†â‹idorâˆ¾gâŠËœâˆ¾âŸ¨cn,cn,bk,bk,hq,api,2/l,at,dr,qp,al+1,al+1,oa+1âŒˆoaâŠos,fl,rtâŸ©
  ocâ†orâŠâˆ¾idocâˆ¾âŸ¨0Â¨cn,ob,1Â¨bk,1+â†•â‰ bk,43Â¨hq,44Â¨api,â¥Šâ‰(11+lm+lâŠaa)â‰ll,ao,6Â¨dr,42Â¨qp,66Â¨al,vi-Ëœ(al-1)âŠğ•©
               24+oaâŠr,16+(fn/dy+2Ã—fmâŒˆ1=ny)+4Ã—0<faâŠer,Â¯1â†“rcâ†7+nfâŸ©
  # Indices for multi-body blocks
  cmâˆ¨â†©(fxâˆ§1â‰ cw)âˆ¨0<utâ†©utâŒ¾(châŠ¸/)ch            # Dyad- and inverse-only generate as multiple
  cjâ†/cvâ†1+1=ciwâ†cwâŠËœciâ†/cm                 # Number of copies
  ckâ†4âŒŠ(2Ã—ciâŠut)+1<ciw                      # Position
  cgâ†Â¯1+`cifâ†ciâŠcf                          # Which block
  cktâ†(2-Â¬(cfâˆ§cm)/fx)âŒˆ(cif/â‹âˆ˜âŠâŸœcg)âŠ¸âŠâˆ˜â’âŠ¸âŠcv+ck
  ciâ†©ckt/âŠ¸âŠ”(Â¯1(â†‘âˆ¾Ëœcj(âŠ’âˆ˜âŠ£+âŠ)ck+cgâŠâ†“)0âˆ¾+`ckt)âŠ”cjâŠci
  # Output
  fzâ†âŸ¨cf/ft,cf/Â¬fx,ciâŒ¾((cf/cm)âŠ¸/)/cfâŸ©       # Per-function data
  czâ†âŸ¨/1âˆ¾orâ‰¥oc-â—‹â‰ rt,fsc+â‰ Â¨dn,dn,dxâŸ©         # Per-body data
  âŸ¨ocâˆ¾Â¯1âŠ‘rc,u,fz,czâŸ©                        # Overall output
}

Compileâ†{
  defaultsâ†âŸ¨â†•0,(!âˆ˜"System values not supported"Â¨),â†•0,â†•0âŸ©
  âŸ¨prims,Sys,vars,redefâŸ© â† âˆ¾âŸœ(â‰ â†“defaultsË™) â‹ˆâŸ(4<â‰ )ğ•¨
  âŸ¨tok,role,valâŸ©â†âŸ¨sys,varsâŸ© Tokenize ğ•©
  âŸ¨oc,prim,blk,bdyâŸ©â†âŸ¨role,âŠ‘val,redefÂ»0Â¨varsâŸ© Parse tok
  âŸ¨oc, âˆ¾âŸ¨primâŠprimsâŸ©âˆ¾1â†“val, <Ë˜â‰>blk, <Ë˜â‰>bdyâŸ©
}
