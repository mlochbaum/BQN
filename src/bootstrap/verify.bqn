glyphs â† â€¢Import "../glyphs.bqn"
gl â† ("âŸ¨"âˆ¾"âŸ©"Â«âˆ¾","âŠ¸âˆ¾Â¨'"'(âŠ£âˆ¾âˆ¾Ëœ)Â¨glyphs)      # Has to replace â€¢args in c.bqn

f â† âŸ¨"../c.bqn"âŸ©âˆ¾("boot"âˆ¾âˆ¾âŸœ".bqn")Â¨'1'+â†•3   # Files to test
c â† (1â€¿3/âŸ¨glyphsâŠ¸â€¢Import,â€¢ImportâŸ©) {ğ•ğ•©}Â¨ f  # Resulting compilers
c â†© (âˆ¾glyphs){ğ•—âŠ¸ğ•}Â¨ c
t â† (âˆ¾âˆ¾âŸœ(@+10)Â¨)Â¨ (Â¯5âŠ¸â†“âˆ¾glË™)âŒ¾âŠ‘âŒ¾âŠ‘ â€¢FLinesÂ¨ f # Compiler source

# Check that compiler ğ•© compiles ğ•©-1 same as full compiler
Ver â† {
  norm â† {ğ•ğ•}ËœÂ´ ğ•© â†‘ âŸ¨
    4âŠ¸â†‘                  # Strip source info, always
    â‹ˆâ¼âˆ˜âˆ¾âŸ=Â¨âŒ¾(2âŠ‘Â¨2âŠ¸âŠ‘)     # Turn only-dyadic functions to ambivalent if â‰¥2
    NormVarâŒ¾(âŠ‘â‹ˆ2âŠ‘Â¯1âŠ‘3âŠ‘âŠ¢) # Normalize variable opcodes if =3, defined below
  âŸ©
  ! â‰¡â—‹NormÂ´ (0â€¿ğ•©âŠc) {ğ•ğ•©}Â¨ (ğ•©-1)âŠt
  â€¢Out âˆ¾âŸ¨"Boot -",'0'+ğ•©," verified!"âŸ©
}
NormVar â† {
  ba â† /Â´'0'-ËœâŸ¨ # For each instruction, number of:
    "11411311121111111315114131131111=111"  # Codes until next opcode
    "111000111100000000002221100000000111"  # Arguments
  âŸ©
  Seâ†â‰ (>/âŠ¢)âˆ¾âŸœâ‰ {(âŠËœğ•¨)ğ•ŠâŸ(â‰ â—‹(Â¯1âŠ¸âŠ‘))ğ•©âˆ¾ğ•©âŠğ•¨}âŸ¨0âŸ©Ë™
  m â† (â‰ ğ•©)â†‘/â¼ Se (â†•â‰ ğ•©)+1+ba(âŠ£âŠËœâ‰ âŠ¸>Ã—âŠ¢)ğ•©  # Mask of opcode starts
  ğ•© (âŠ¢-mâˆ§2Ã—34âŠ¸=)â†© # VARU to VARO
  âŸ¨âŠâŸœ((â†•âŠ¸-3)âˆ¾ğ•¨)âŒ¾((0â€¿0Â»mâˆ§ğ•©âˆŠ32â€¿33)âŠ¸/) ğ•©,â†•â‰ ğ•¨âŸ©
}ËœÂ´

VerÂ¨ 1+â†•3

â€¢Out ""
â€¢Out "Compile times, in milliseconds:"
â€¢Show 1e3Ã·ËœâŒŠ1e6Ã— (âˆ¨â—‹(3âŠ¸>)âˆ§1â‰¥-)â—¶âˆâ€¿{30(ğ•¨âŠ‘c)â€¢_timedğ•©âŠ‘t}âŒœËœ â†•â‰ c
