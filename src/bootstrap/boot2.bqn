# Compiler simplified twice
# Suitable for compiling once-simplified compiler
# Single-scope; no modified or list assignment; no 2-modifiers
{
  charSetâ†âˆ¾charsâ†âŸ¨
    "+-Ã—Ã·â‹†âˆšâŒŠâŒˆ|Â¬âˆ§âˆ¨<>â‰ =â‰¤â‰¥â‰¡â‰¢âŠ£âŠ¢â¥Šâˆ¾â‰â‹ˆâ†‘â†“â†•Â«Â»âŒ½â‰/â‹â’âŠâŠ‘âŠâŠ’âˆŠâ·âŠ”!" # Function
    "Ë™ËœË˜Â¨âŒœâ¼Â´Ë`"           # 1-modifier
    "âˆ˜â—‹âŠ¸âŸœâŒ¾âŠ˜â—¶â‰âš‡âŸâŠ"         # 2-modifier
    "â‹„,"âˆ¾lfâ†@+10          # Separator
    "â†â†©"                  # Gets
    "(){}âŸ¨âŸ©"              # Bracket
    "ğ•Šğ•©ğ•¨"                 # Input
    "Â¯Ï€âˆ"                 # Numeric
    (âŠ‘"0")+â†•10            # Digit
    â¥Š"aA"+âŒœâ†•naâ†26         # Alphabetic
    " "                   # Whitespace
    scâ†@+âŸ¨35,34,64âŸ©       # Preprocessed characters: hash, double quote, @
  âŸ©
  cmâ†((0Â»+`)â‹ˆÂ¨âŠ¢)cglâ†â‰ Â¨chars
  bSâ†3âŠ‘cmâ‹„bGâ†4âŠ‘cmâ‹„bBâ†5âŠ‘cmâ‹„bNâ†7âŠ‘cmâ‹„bAâ†9âŠ‘cmâ‹„bWâ†10âŠ‘cm
  sepâ†âŠ‘bS
  viâ†âŠ‘bN  # Start of identifier numbering
  charRoleâ†âˆ¾cglâ¥ŠÂ¨âŸ¨1,2,3,Â¯1,Â¯3,âŸ¨Â¯1,0âŸ©,âŸ¨1,0,0âŸ©,0,0,26/âŸ¨0,1âŸ©,4,0âŸ©
  TTâ†âŒˆ`Ã— â‹„ ITâ†(â†•â‰ )TTâŠ¢ â‹„ I1Tâ†(1+(â†•â‰ ))TTâŠ¢

  # Comments and strings
  sâ†â‰ `ddâ†ğ•©=1âŠ‘sc
  fâ†s<(I1T s<ğ•©=âŠ‘sc)â‰¤I1Tğ•©=lf                 # Filter comments
  chrâ†@Â¨ciâ†/fâˆ§ğ•©=2âŠ‘sc                        # Characters (indices ci)
  fâ†©f>qeâ†ddâˆ§Â«sdâ†sâˆ§dd                        # Quote Escape
  siâ†sd>Â»qe                                 # String indices
  strâ†ğ•©âŠ”Ëœ1-Ëœ(+`siâˆ¾1)Ã—(si<s)âˆ¾1               # Strings

  # Extract words: identifiers and numbers
  tâ†charSetâŠf/ğ•©                             # Tokens
  râ†tâŠcharRole                              # Role
  lâ†(tâ‰¥âŠ‘bN)âˆ§t<âŠ‘bWâ‹„wâ†l>Â»l                    # Word chars l, start w
  wiâ†(âŠ‘bA)â‰¤w/t                              # Type: 0 number, 1 identifier
  tâ†©t-naÃ—lâˆ§r=1                              # Case-insensitive
  nâ†lâˆ§(+`w)âŠ0âˆ¾Â¬wi                           # Number mask
  ideâ†(1-Ëœ(l>n)Ã—+`w>n)âŠ”tâŠcharSet            # Identifiers

  # Numbers, at most 2 digits
  ntâ†((âŠ¢âˆ¨Â«)0âˆ¾n)/0âˆ¾tÃ—l                       # Number tokens separated by 0
  nnâ†nt=âŠ‘bNâ‹„mâ†Â¬nnâˆ¨0=nt                      # Mask for Â¯; digits
  nlâ†(0âˆ¾âŸ¨Ï€,âˆâŸ©âˆ¾â†•10)âŠËœmÃ—nt-âŠ‘bN                # Digit lookup
  nsâ†âŸ¨1,Â¯1âŸ©âŠËœ(m>Â»m)/Â»nn                     # Negate if Â¯
  numâ†nsÃ—(m>Â«m)/nl+10Ã—Â»nl                   # Numeric values

  # Deduplicate literals and identifiers; other cleanup
  # Identifiers then literal tokens are numbered starting at vi
  kiâ†((â’wi)âŠ/w)âˆ¾(ciâˆ¾/si)âŠ+`Â»f               # Indices in t
  kâ†âŸ¨ide,âŸ¨âŸ©,num,chr,strâŸ©                    # Constants
  kâ†©k/Â¨Ëœ(âŠ¢>Â¯1Â»âŒˆ`)Â¨jâ†âŠÂ¨k                     # IDs j into uniques k
  wrâ†wâˆ¨Â¬lâˆ¨t=âŠ‘bWâ‹„râ†©wr/râ‹„câ†â‰ t
  tâ†©wr/(câ†‘â‹(âŠ¢+cÃ—âŠ’)kiâˆ¾â†•c)âŠ(âˆ¾j++`viÂ»â‰ Â¨k)âˆ¾t    # Add IDs; remove words/whitespace
  tâ†©t-(t<+Â´bS)Ã—(âŠ¢Ã—0â‰¤âŠ¢)t-âŠ‘bS                 # Separators are equivalent
  pbâ†â‰ `1Â¨sbâ†Â¯1â†“1â†“/1(âˆ¾â‰ âˆ¾Ëœ)t=sep              # Separator group boundaries (excludes leading and trailing)
  ebâ†âŸ¨3,5âŸ©+âŠ‘bB                              # End brackets that allow separators
  skâ†sb/Ëœpb>(âŠ¢âˆ¨Â«)ebâˆŠËœpb+(sb-pb)âŠt           # Keep the first of each group that's not just inside a bracket
  srâ†((â‰ t)â†‘/â¼sk)âˆ¨tâ‰ sepâ‹„râ†©sr/râ‹„tâ†©sr/t        # Remove the rest
  ğ•©â†©tâ‹„nvâ†â‰ âŠ‘k
  # End of tokenization!

  # Bracket roles
  # Open brackets initially have role Â¯1 and closed ones have role 0
  gbâ†â‹+`pâ†(Â¯1-2Ã—r)Ã—(ğ•©â‰¥âŠ‘bB)âˆ§ğ•©<+Â´bB           # Paren (actually any bracket type) depth and grade
  râ†©r+ğ•©=3+âŠ‘bB                               # Assume blocks are functions
  cpâ†ğ•©=1+âŠ‘bB                                # Closed paren
  rpâ†(â‹gb)âŠ(â‰ gb)Â»gb                         # Position of previous, for roles
  irâ†((IT cpâ‰¤âŠ¢)âŠâŠ¢)(rpâŠ0âˆ¾Ëœ3=r)âˆ¨0<r           # Role of the expression ending at each position
  râ†©r+cpÃ—Â»ir                                # Roles at cp were 0; set them now

  # Reorder for parsing
  # Permutation to reverse each expression: *more* complicated than it looks
  revâ†â‹+`Â¯1â†“(Â¯1âˆ¾gb)((â‹âŠ£)âŠ((â‹âŠ¢)âŠâŠ£)Â¬âŠËœ)â‹(+`+âŠ¢)1âˆ¾gbâŠr=Â¯1
  gfâ†â‹fdâ†+`brâ†revâŠpÃ—ğ•©âˆŠâŸ¨2,3âŸ©+âŠ‘bB             # Order by brace depth fd to de-nest blocks
  revâ†©gfâŠrevâ‹„fdâ†©gfâŠfdâ‹„brâ†©gfâŠbr
  xvâ†revâŠğ•©-vi                               # Save for lexical resolution
  gâ†â‹+`br-ËœrevâŠp                            # Order by non-brace bracket depth
  grâ†gâŠrevâ‹„giâ†â‹g                            # Final parsing ordering
  bâ†br>0â‹„bcâ†/br<0                           # Block Begin (mask) and Close (index), in matching order
  ğ•©â†©grâŠğ•©â‹„râ†©grâŠrâ‹„irâ†©grâŠir

  # Parsing part 1
  aâ†r=Â¯3â‹„psâ†r=Â¯1                            # a: assignment, ps: part separator
  trâ†irâŠËœITÂ»ps                              # tr: train or modifier expression
  oaâ†âŒ½/opâ†râ‰¥2â‹„roâ†opâˆ¨Â«opâˆ§r=3                 # op: active modifiers; ro: mod or right operand
  xsâ†ğ•©=sepâ‹„foâ†ğ•©=2+âŠ‘bB                       # Separators, function open {
  lsâ†xsâˆ§(IT fo)<IT loâ†ğ•©=4+âŠ‘bB               # List Separators: after âŸ¨lo, not {fo
  maâ†tr<(ğ•©=1+âŠ‘bG)âˆ§Â«irâ‰¥1                     # Modified assignment
  osâ†âŒ½(â†•â‰ ro)(âŠ£-TT)âŒ½Â¬roâˆ¨ma                   # Operator skip: distance rightward to derived function start
  atâ†1+(âŠ¢+osâŠËœâŠ¢)aiâ†/a                       # Assignment target
  aoâ†(âŠ‘bG)-ËœaiâŠğ•©+ma                         # Assignment opcode
  akâ†giâŠ(Â«-âŠ¢)(â‹â·atâˆ¾â†•â‰ ğ•©)âŠ(â‰ ğ•©)â†‘1+ao           # Class of assignment: 1â†? 2â†©? 3+â†©?
  aaâ†0<gâŠacâ†Â»+`akÃ—1(Â»âˆ¨âŠ¢)0=+`ak              # Broadcast ak to the entire target

  # Lexical resolution (independent of parsing part 2 below)
  idâ†/(0â‰¤xv)âˆ§xv<nv                          # Identifier indices in xv
  spâ†/(Â¯3â‰¤xv)âˆ§xv<0                          # Special name indices
  dâ†1=idâŠac                                 # Which accesses are definitions
  fiâ†+`bâ‹„fscâ†3Ã—fxâ†0âˆ¾1Â¨bc                    # Body index fi, immediacy Â¬fx, special name count
  idfâ†idâŠfiâ‹„idvâ†idâŠxv                       # Function index and name ID
  dnâ†((dfâ†d/idf)âˆ¾â‰ fx)âŠ”dvâ†d/idv              # Identifier name ID, per-block
  # Order every referenced identifier, and an undeclaration for each declaration
  ixfâ†(idfâŠÂ¯1âˆ¾b/gf)âˆ¾dfâŠ(â‰ ğ•©)âˆ¾1-ËœbcâŠgf        # First order by block index, open for real and closed for virtual
  igâ†((â‹(idvâˆ¾dv)âŠËœâŠ¢)âŠâŠ¢)â‹ixf                 # Then order by name
  igâ†©(âŠ¢/Ëœ(â‰ d)>âŠ¢)(â‹+`igâŠdâˆ¾Â¯1Â¨dv)âŠig          # Last order by declaration depth
  dâ†©igâŠdâ‹„idâ†©igâŠid
  iaâ†0<(idâˆ¾sp)âŠac                           # Which are assignments
  iddâ†(âŠ¢-(IT d)âŠâŠ¢)idâŠfd                     # Identifier frame depth
  idiâ†((Â¯1+`d)âŠ(â‹â‹d/ig)âŠâŠ¢)(âŠ’+âŠ¢âŠfscË™)df      # Slot within frame
  spiâ†3+spâŠxv                               # Special name index
  uuâ†(1Â«d)âˆ§d((+`âŠ£)âŠ1(âˆ¾/âˆ¾Ëœ)(âˆ¨/âŠ£))0<idd       # Unused marker
  uuâ†©uuâˆ¾âŒ½âˆŠâŒ½spi+6Ã—spâŠfi                      # ...for special names
  idorâ†âˆ¾3/âŸ¨idâˆ¾spâŸ©                           # Identifier bytecode ordering
  idocâ†âŸ¨32+uu(âŠ¢+2Ã—>)ia,iddâˆ¾0Â¨sp,idiâˆ¾spiâŸ©    # Identifier bytecode: instruction, depth, slot

  # Parsing part 2
  taâ†trâˆ§2(>âˆ¨|)ps(âŠ¢-TT)+`Â¬ro                 # Train argument (first-level)
  faâ†/(taâˆ¨roâˆ¨(Â«âˆ¨âŠ¢)ps<aa)<(r=1)âˆ¨Â»op          # Active functions
  dyâ†faâŠÂ«(trâˆ§râ‰¥0)âˆ¨ro<r=0                    # Dyadic
  prâ†ğ•©âŠËœpiâ†/ğ•©<sepâ‹„obâ†prâŠËœuâ†âˆ§â·pr             # Objects to be loaded
  cnâ†piâˆ¾ltâ†/ğ•©â‰¥clâ†vi+nvâ‹„obâ†©obâˆ¾(cl-Ëœâ‰ u)+ltâŠğ•©  # Constants
  bkâ†bcâŠgi                                  # Block loads
  lbâ†/ğ•©=5+âŠ‘bB                               # List starts
  llâ†(Â¬lo/1Â«ps)+(âŠ¢-Â»)1â†“(loâˆ¾1)/+`lsâˆ¾0        # List Length
  drâ†/xs>lsâ‹„rtâ†/fo                          # Drop (block separator) and return
  flâ†(âŠ¢+dyÃ—âŠ¢âŠosË™)fa+dy                      # Function application site

  # Object code generation: numbers oc ordered by source location (after rev) oi
  orâ†â‹idorâˆ¾gâŠËœâˆ¾âŸ¨cn,cn,bk,bk,lb,lb,at,dr,oa+1âŒˆoaâŠos,fl,rtâŸ©
  ocâ†orâŠâˆ¾idocâˆ¾âŸ¨0Â¨cn,ob,1Â¨bk,1+â†•â‰ bk,11+lbâŠaa,ll,48+ao,6Â¨dr
               24+oaâŠr,16+dy+4Ã—faâŠtr,Â¯1â†“rcâ†7Â¨fxâŸ©
  # Output
  fzâ†âŸ¨0Â¨fx,Â¬fx,â†•â‰ fxâŸ©                        # Per-function data
  czâ†âŸ¨/1âˆ¾orâ‰¥(â‰ oc)-â‰ rt,fsc+â‰ Â¨dn,dn,0Â¨Â¨dnâŸ©    # Per-body data
  âŸ¨ocâˆ¾Â¯1âŠ‘rc,âˆ¾âŸ¨uâŠğ•¨âŸ©âˆ¾1â†“k,<Ë˜â‰>fz,<Ë˜â‰>czâŸ©       # Overall output
}
